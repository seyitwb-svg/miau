#!/usr/bin/env python3
"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    PROMETHEUS ULTRA TRADING BOT v3.0                        ‚ïë
‚ïë                    "170 Jahre seiner Zeit voraus"                           ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  3 SYSTEME:                                                                  ‚ïë
‚ïë  - VIPER SCALPER: Aggressive Scalping mit wissenschaftlichen Strategien     ‚ïë
‚ïë  - PHOENIX SWING: Swing Trading mit Multi-Timeframe Analysis                ‚ïë
‚ïë  - HYDRA CONSENSUS: 31 Strategien mit Ranking-System                        ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  Features: Order Book Analysis, Strategy Optimizer, Multi-Brain Architecture‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""

import ccxt
import pandas as pd
import numpy as np
import time
import json
import os
import threading
import queue
from datetime import datetime, timedelta
from collections import deque
import warnings
import traceback
import asyncio
from concurrent.futures import ThreadPoolExecutor
import hashlib
warnings.filterwarnings('ignore')

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ERWEITERTE INDIKATOREN - 40+ verschiedene Indikatoren f√ºr maximale Analyse!
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ExtendedIndicators:
    """Alle 40+ technischen Indikatoren in einer Klasse"""
    
    @staticmethod
    def fisher_transform(df: pd.DataFrame, period: int = 14) -> float:
        """Fisher Transform - Normalisiert Preise auf -100 bis +100"""
        if len(df) < period:
            return 0
        
        high = df['high'].iloc[-period:].max()
        low = df['low'].iloc[-period:].min()
        close = df['close'].iloc[-1]
        
        if high == low:
            return 0
        
        value = 2 * ((close - low) / (high - low)) - 1
        value = np.clip(value, -0.999, 0.999)
        fisher = 0.5 * np.log((1 + value) / (1 - value))
        return fisher
    
    @staticmethod
    def williams_r(df: pd.DataFrame, period: int = 14) -> float:
        """Williams %R - Oscillator zwischen -100 und 0"""
        if len(df) < period:
            return 0
        
        high = df['high'].iloc[-period:].max()
        low = df['low'].iloc[-period:].min()
        close = df['close'].iloc[-1]
        
        if high == low:
            return 0
        
        return -100 * (high - close) / (high - low)
    
    @staticmethod
    def kama(df: pd.DataFrame, fast: int = 2, slow: int = 30, period: int = 10) -> float:
        """Kaufman's Adaptive Moving Average"""
        if len(df) < period:
            return df['close'].iloc[-1]
        
        change = abs(df['close'].iloc[-1] - df['close'].iloc[-period])
        vol = df['close'].diff().abs().rolling(period).sum().iloc[-1]
        
        if vol == 0:
            return df['close'].iloc[-1]
        
        efficiency = change / vol
        fastest = 2 / (fast + 1)
        slowest = 2 / (slow + 1)
        smooth = (efficiency * (fastest - slowest) + slowest) ** 2
        
        # Vereinfachte Approximation
        return df['close'].iloc[-1]
    
    @staticmethod
    def roc(df: pd.DataFrame, period: int = 12) -> float:
        """Rate of Change - Momentum-Indicator"""
        if len(df) < period:
            return 0
        
        current = df['close'].iloc[-1]
        past = df['close'].iloc[-period]
        
        if past == 0:
            return 0
        
        return ((current - past) / past) * 100
    
    @staticmethod
    def momentum(df: pd.DataFrame, period: int = 10) -> float:
        """Price Momentum"""
        if len(df) < period:
            return 0
        
        return df['close'].iloc[-1] - df['close'].iloc[-period]
    
    @staticmethod
    def dmi_plus(df: pd.DataFrame, period: int = 14) -> float:
        """Directional Movement Indicator Plus"""
        if len(df) < period:
            return 0
        
        high_diff = df['high'].diff()
        low_diff = -df['low'].diff()
        
        plus_dm = np.where((high_diff > low_diff) & (high_diff > 0), high_diff, 0)
        tr = pd.concat([
            df['high'] - df['low'],
            (df['high'] - df['close'].shift()).abs(),
            (df['low'] - df['close'].shift()).abs()
        ], axis=1).max(axis=1)
        
        atr = tr.rolling(period).mean().iloc[-1]
        dmi_plus = 100 * plus_dm[-period:].sum() / (atr * period) if atr > 0 else 0
        
        return min(dmi_plus, 100)
    
    @staticmethod
    def dmi_minus(df: pd.DataFrame, period: int = 14) -> float:
        """Directional Movement Indicator Minus"""
        if len(df) < period:
            return 0
        
        high_diff = df['high'].diff()
        low_diff = -df['low'].diff()
        
        minus_dm = np.where((low_diff > high_diff) & (low_diff > 0), low_diff, 0)
        tr = pd.concat([
            df['high'] - df['low'],
            (df['high'] - df['close'].shift()).abs(),
            (df['low'] - df['close'].shift()).abs()
        ], axis=1).max(axis=1)
        
        atr = tr.rolling(period).mean().iloc[-1]
        dmi_minus = 100 * minus_dm[-period:].sum() / (atr * period) if atr > 0 else 0
        
        return min(dmi_minus, 100)
    
    @staticmethod
    def supertrend(df: pd.DataFrame, period: int = 10, multiplier: float = 3.0) -> float:
        """Supertrend Indicator - 1 = Uptrend, -1 = Downtrend"""
        if len(df) < period:
            return 0
        
        hl2 = (df['high'] + df['low']) / 2
        atr = df['close'].rolling(period).std() * multiplier
        
        basic_ub = hl2 + atr
        basic_lb = hl2 - atr
        
        final_ub = basic_ub.iloc[-1]
        final_lb = basic_lb.iloc[-1]
        
        close = df['close'].iloc[-1]
        
        return 1 if close > final_ub else (-1 if close < final_lb else 0)
    
    @staticmethod
    def linear_regression(df: pd.DataFrame, period: int = 20) -> float:
        """Linear Regression Slope"""
        if len(df) < period:
            return 0
        
        prices = df['close'].iloc[-period:].values
        x = np.arange(len(prices))
        
        slope = np.polyfit(x, prices, 1)[0]
        return slope * 100
    
    @staticmethod
    def trix(df: pd.DataFrame, period: int = 15) -> float:
        """TRIX - Triple Exponential Moving Average"""
        if len(df) < period * 3:
            return 0
        
        ema1 = df['close'].ewm(span=period).mean()
        ema2 = ema1.ewm(span=period).mean()
        ema3 = ema2.ewm(span=period).mean()
        
        trix_val = ema3.pct_change().iloc[-1] * 10000 if len(ema3) > 1 else 0
        
        return trix_val
    
    @staticmethod
    def moving_median(df: pd.DataFrame, period: int = 20) -> float:
        """Moving Median"""
        if len(df) < period:
            return df['close'].iloc[-1]
        
        return df['close'].iloc[-period:].median()
    
    @staticmethod
    def stoch_rsi(df: pd.DataFrame, period: int = 14, smoothk: int = 3, smoothd: int = 3) -> tuple:
        """Stochastic RSI"""
        if len(df) < period:
            return 0, 0
        
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        rs = gain / loss if loss.iloc[-1] != 0 else 0
        rsi = 100 - (100 / (1 + rs)).iloc[-1] if loss.iloc[-1] != 0 else 50
        
        rsi_min = 0
        rsi_max = 100
        
        stoch_rsi_val = (rsi - rsi_min) / (rsi_max - rsi_min) * 100
        
        return min(100, max(0, stoch_rsi_val)), 50
    
    @staticmethod
    def relative_vigor_index(df: pd.DataFrame, period: int = 10) -> float:
        """Relative Vigor Index"""
        if len(df) < period:
            return 50
        
        numerator = df['close'].iloc[-period:].sum() - df['open'].iloc[-period:].sum()
        denominator = df['high'].iloc[-period:].sum() - df['low'].iloc[-period:].sum()
        
        if denominator == 0:
            return 50
        
        rvi = 100 * (numerator / denominator)
        return np.clip(rvi, 0, 100)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê 
# ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
# ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù 
#                    EINSTELLUNGEN - HIER ANPASSEN!
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Config:
    """
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                      ALLE EINSTELLUNGEN HIER!                            ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # API CREDENTIALS - KuCoin Futures
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    API_KEY = "692283a9b40b2f00018925a3"
    API_SECRET = "db735baf-ff1c-4c51-8b9f-6f907003b3b4"
    API_PASSPHRASE = "Akay4747"
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # TRADING PARAMETER
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    # Wie viele Top-Coins nach Volumen gescannt werden sollen
    TOP_COINS_TO_SCAN = 85
    
    # Leverage-Einstellungen pro System
    VIPER_LEVERAGE = 20          # System 1: Scalping
    PHOENIX_LEVERAGE = 10        # System 2: Swing
    HYDRA_LEVERAGE = 15          # System 3: Consensus
    
    # Prozent vom Guthaben pro Trade (0.01 = 1%, 0.05 = 5%)
    POSITION_SIZE_PERCENT = 0.02  # 2% pro Trade - NIEDRIG F√úR TESTS!
    
    # Maximale gleichzeitige Positionen
    MAX_CONCURRENT_POSITIONS = 3
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # RISIKO MANAGEMENT
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    # Hard Stop-Loss (wird IMMER bei Exchange gesetzt!)
    HARD_STOP_LOSS_PERCENT = 3.0  # 3% vom Entry
    
    # Take Profit Ziele
    TAKE_PROFIT_1_PERCENT = 6.5   # Erstes TP
    TAKE_PROFIT_2_PERCENT = 9.0   # Zweites TP
    TAKE_PROFIT_3_PERCENT = 19.0   # Drittes TP
    
    # Trailing Stop
    TRAILING_STOP_ACTIVATION = 4.5  # Ab wann Trailing aktiv wird (%)
    TRAILING_STOP_DISTANCE = 2.6    # Abstand vom Hoch (%)
    
    # Tagesverlust-Limit
    MAX_DAILY_LOSS_PERCENT = 995.0    # Bot pausiert bei -5% Tagesverlust
    
    # Maximaler Drawdown
    MAX_DRAWDOWN_PERCENT = 9915.0     # Bot stoppt komplett bei -15%
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # KOSTEN-KALKULATION (f√ºr Netto-Profit Berechnung)
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    TAKER_FEE = 0.0006          # 0.06%
    MAKER_FEE = 0.0002          # 0.02%
    ESTIMATED_SLIPPAGE = 0.002  # 0.2%
    SPREAD_COST = 0.001         # 0.1%
    
    # Mindest-Brutto-Profit um netto positiv zu sein
    MIN_GROSS_PROFIT_TARGET = 0.055  # 5.5% Brutto f√ºr ~4% Netto
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # SYSTEM-SPEZIFISCHE EINSTELLUNGEN
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    # VIPER SCALPER
    VIPER_MIN_VOLUME_24H = 10_000_000   # Min. 24h Volume in USD
    VIPER_MAX_HOLD_TIME_SECONDS = 300   # Max 5 Minuten halten
    VIPER_MIN_VOLATILITY = 0.005        # Min 0.5% Volatilit√§t
    
    # PHOENIX SWING
    PHOENIX_MIN_TREND_STRENGTH = 25     # Min ADX f√ºr Trend
    PHOENIX_MAX_HOLD_TIME_HOURS = 24    # Max 24h halten
    
    # HYDRA CONSENSUS
    HYDRA_MIN_AGREEMENT = 12            # Min Strategien f√ºr Agreement
    HYDRA_GENIUS_STRATEGIES_ENABLED = True  # Die 11 Genius-Strategien
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # RANKING SYSTEM
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    INITIAL_ELO = 1500
    ELO_K_FACTOR = 32
    MIN_TRADES_FOR_RANKING = 5
    
    # Trades pro Tag basierend auf Elo-Rang
    TRADES_PER_DAY_BY_RANK = {
        1: 999,   # Platz 1: Unbegrenzt
        2: 50,
        3: 40,
        4: 30,
        5: 25,
        6: 20,
        7: 15,
        8: 12,
        9: 10,
        10: 8,
    }
    DEFAULT_TRADES_PER_DAY = 5  # F√ºr R√§nge > 10
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # STRATEGY OPTIMIZER SETTINGS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    OPTIMIZER_ENABLED = True
    OPTIMIZER_MIN_TRADES = 20           # Min Trades vor Optimierung
    OPTIMIZER_INTERVAL_HOURS = 6        # Alle 6 Stunden optimieren
    OPTIMIZER_PARAM_RANGES = {
        'rsi_oversold': (20, 35),
        'rsi_overbought': (65, 80),
        'ema_fast': (5, 15),
        'ema_slow': (15, 30),
        'bb_period': (15, 25),
        'bb_std': (1.5, 2.5),
        'atr_multiplier': (1.0, 3.0),
    }
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ORDER BOOK ANALYSIS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    ORDERBOOK_DEPTH = 20                # Wie tief ins Orderbook schauen
    ORDERBOOK_IMBALANCE_THRESHOLD = 1.5 # Ab wann Imbalance signifikant
    WHALE_ORDER_THRESHOLD = 50000       # Ab wann eine Order als "Whale" gilt (USD)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # LOGGING & CSV
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    LOG_FILE = "prometheus_log.txt"
    TRADE_CSV = "prometheus_trades.csv"
    RANKING_CSV = "prometheus_rankings.csv"
    STATE_FILE = "prometheus_state.json"
    
    # Vollst√§ndige Indikator-Logs aktivieren
    LOG_ALL_INDICATORS = True
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # TIMING
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    SCAN_INTERVAL_SECONDS = 10          # Wie oft nach neuen Trades scannen
    POSITION_CHECK_INTERVAL = 0.5        # Wie oft offene Positionen pr√ºfen (SCHNELLER f√ºr SL/TP!)
    RECONNECT_DELAY_SECONDS = 30        # Bei Verbindungsverlust
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ZEITBASIERTE FILTER
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    AVOID_TRADING_HOURS = []  # z.B. [(0, 4)] f√ºr 00:00-04:00 UTC
    AVOID_WEEKENDS = False


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# UTILITY CLASSES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Logger:
    """Thread-safe Logger mit vollst√§ndigen Fehlermeldungen"""
    
    def __init__(self, log_file: str):
        self.log_file = log_file
        self.lock = threading.Lock()
        self.log_queue = deque(maxlen=1000)  # Letzte 1000 Logs im Speicher
        
    def log(self, message: str, level: str = "INFO", full_traceback: bool = False):
        """Log mit Timestamp - KEINE ABGESCHNITTENEN FEHLERMELDUNGEN!"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        
        # Bei Errors: Vollst√§ndiger Traceback
        if level == "ERROR" and full_traceback:
            tb = traceback.format_exc()
            if tb and tb != "NoneType: None\n":
                message = f"{message}\n{'='*60}\nFULL TRACEBACK:\n{tb}{'='*60}"
        
        log_entry = f"[{timestamp}] [{level}] {message}"
        
        with self.lock:
            self.log_queue.append(log_entry)
            print(log_entry)
            
            try:
                with open(self.log_file, 'a', encoding='utf-8') as f:
                    f.write(log_entry + "\n")
            except Exception as e:
                print(f"[LOG WRITE ERROR] {e}")
    
    def get_recent_logs(self, count: int = 100) -> list:
        """Hole die letzten N Logs"""
        with self.lock:
            return list(self.log_queue)[-count:]


class StateManager:
    """Persistenter State f√ºr Bot-Neustart"""
    
    def __init__(self, state_file: str, logger: Logger):
        self.state_file = state_file
        self.logger = logger
        self.state = self._load_state()
        
    def _load_state(self) -> dict:
        """Lade State von Datei"""
        default_state = {
            'open_positions': {},
            'daily_pnl': 0.0,
            'daily_trades': 0,
            'last_trade_date': None,
            'strategy_rankings': {},
            'strategy_daily_trades': {},
            'total_pnl': 0.0,
            'start_balance': None,
            'peak_balance': 0.0,  # FIXED: War None
        }
        
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, 'r') as f:
                    loaded = json.load(f)
                    default_state.update(loaded)
                    self.logger.log(f"State loaded from {self.state_file}", "INFO")
            except Exception as e:
                self.logger.log(f"Error loading state: {e}", "WARNING")
        
        return default_state
    
    def save_state(self):
        """Speichere State in Datei"""
        try:
            with open(self.state_file, 'w') as f:
                json.dump(self.state, f, indent=2, default=str)
        except Exception as e:
            self.logger.log(f"Error saving state: {e}", "ERROR", True)
    
    def get(self, key: str, default=None):
        return self.state.get(key, default)
    
    def set(self, key: str, value):
        self.state[key] = value
        self.save_state()
    
    def update_nested(self, key: str, nested_key: str, value):
        if key not in self.state:
            self.state[key] = {}
        self.state[key][nested_key] = value
        self.save_state()


class TradeJournal:
    """
    PROFESSIONELLES CSV-SYSTEM v2
    - JEDE ZEILE = komplette Entry/Exit/Update mit ALLEN Indikatoren
    - KEINE NULL-Werte f√ºr Indikatoren (immer mit echten Werten oder 0)
    - JSON f√ºr Speicherung + CSV f√ºr Analyse
    - Thread-safe mit vollst√§ndiger Datenvalidierung
    """
    
    def __init__(self, csv_file: str, logger: Logger):
        self.csv_file = csv_file
        self.json_file = csv_file.replace('.csv', '_trades.json')
        self.logger = logger
        self.lock = threading.Lock()
        self.trades = {}  # Dict[trade_id] = dict mit kompletten Daten
        self.csv_rows = []  # Alle CSV-Reihen (Entry/Exit/Update)
        self._load_or_create()
    
    def _load_or_create(self):
        """Lade existierende Daten oder erstelle neu"""
        if os.path.exists(self.json_file):
            try:
                with open(self.json_file, 'r') as f:
                    data = json.load(f)
                    self.trades = data.get('trades', {})
                    self.csv_rows = data.get('csv_rows', [])
                self.logger.log(f"Loaded {len(self.trades)} trades, {len(self.csv_rows)} CSV rows", "INFO")
            except Exception as e:
                self.logger.log(f"Error loading JSON: {e}, starting fresh", "WARNING")
                self.trades = {}
                self.csv_rows = []
        
        # Erstelle CSV falls nicht vorhanden
        if not os.path.exists(self.csv_file):
            self._write_csv()
    
    def _save_json(self):
        """Speichere alle Daten zu JSON"""
        try:
            with open(self.json_file, 'w') as f:
                json.dump({'trades': self.trades, 'csv_rows': self.csv_rows}, f, indent=2, default=str)
        except Exception as e:
            self.logger.log(f"CRITICAL: JSON save failed: {e}", "ERROR", True)
    
    def _write_csv(self):
        """Schreibe CSV mit allen Reihen"""
        try:
            if not self.csv_rows:
                columns = self._get_column_names()
                df = pd.DataFrame(columns=columns)
                df.to_csv(self.csv_file, index=False)
                return
            
            df = pd.DataFrame(self.csv_rows)
            # Sicherstelle dass alle Spalten da sind
            for col in self._get_column_names():
                if col not in df.columns:
                    df[col] = None
            
            df = df[self._get_column_names()]
            df.to_csv(self.csv_file, index=False)
            
        except Exception as e:
            self.logger.log(f"CRITICAL: CSV write failed: {e}", "ERROR", True)
    
    def _get_column_names(self) -> list:
        """Definierte Spaltenreihenfolge - TOP 0.000001% VERSION!"""
        return [
            'row_type', 'trade_id', 'timestamp', 
            'symbol', 'system', 'strategy', 'side', 'leverage',
            'entry_price', 'current_price', 'exit_signal_price', 'target_exit_price', 'actual_exit_price', 'stop_loss_price',
            'highest_price', 'lowest_price',
            'liquidation_price', 'liquidation_distance',  # NEU: Liquidation Tracking
            'position_size', 'position_size_usd', 'contracts',
            'entry_fee', 'exit_fee', 'total_fees', 'slippage_entry', 'slippage_exit',
            'current_pnl', 'current_pnl_usd',  # Aktuelle PnL Werte
            'gross_pnl_percent', 'net_pnl_percent', 'gross_pnl_usd', 'net_pnl_usd',
            'pnl_at_highest', 'pnl_at_lowest', 'pnl_5pct_count', 'pnl_10pct_count', 'pnl_milestones', 'max_profit_reached',
            'milestone_reached',  # Welches Milestone wurde gerade erreicht
            'trailing_stop_active', 'trailing_stop_price',  # NEU: Trailing Stop Tracking
            'hold_time_seconds', 'exit_reason', 'strategy_confidence', 'agreement_count',
            # 40+ INDIKATOREN - IMMER GEF√úLLT!
            'ind_rsi_14', 'ind_rsi_7', 'ind_rsi_5',
            'ind_macd', 'ind_macd_signal', 'ind_macd_hist',
            'ind_ema_9', 'ind_ema_21', 'ind_ema_50', 'ind_ema_200',
            'ind_sma_20', 'ind_sma_50', 'ind_sma_200',
            'ind_bb_upper', 'ind_bb_middle', 'ind_bb_lower', 'ind_bb_width',
            'ind_atr_14', 'ind_adx', 'ind_plus_di', 'ind_minus_di',
            'ind_stoch_k', 'ind_stoch_d', 'ind_stoch_rsi',
            'ind_cci', 'ind_mfi', 'ind_rvi',
            'ind_obv', 'ind_vwap', 'ind_volume_sma',
            'ind_ichimoku_tenkan', 'ind_ichimoku_kijun', 'ind_ichimoku_cloud_color',
            'ind_fisher', 'ind_williams_r', 'ind_kama', 'ind_roc', 'ind_mom',
            'ind_dmi_plus', 'ind_dmi_minus', 'ind_supertrend',
            'ind_zigzag', 'ind_pivot_point', 'ind_gann',
            'ind_moving_median', 'ind_trix', 'ind_linear_regression',
            'ob_bid_volume', 'ob_ask_volume', 'ob_imbalance', 'ob_spread', 'ob_whale_bids', 'ob_whale_asks',
            'market_trend', 'volatility_1h', 'volume_24h', 'price_change_24h', 'btc_correlation', 'funding_rate',
            'account_balance_before', 'account_balance_after', 'daily_pnl_before', 'daily_trades_count',
            'notes'
        ]
    
    def _fill_missing_indicators(self, data: dict, default_indicators: dict) -> dict:
        """F√ºlle fehlende Indikatoren mit Defaults - KEINE NULL WERTE!"""
        filled = data.copy()
        
        # Alle m√∂glichen Indikatoren
        all_indicators = [
            'rsi_14', 'rsi_7', 'rsi_5',
            'macd', 'macd_signal', 'macd_hist',
            'ema_9', 'ema_21', 'ema_50', 'ema_200',
            'sma_20', 'sma_50', 'sma_200',
            'bb_upper', 'bb_middle', 'bb_lower', 'bb_width',
            'atr_14', 'adx', 'plus_di', 'minus_di',
            'stoch_k', 'stoch_d', 'stoch_rsi',
            'cci', 'mfi', 'rvi',
            'obv', 'vwap', 'volume_sma',
            'ichimoku_tenkan', 'ichimoku_kijun', 'ichimoku_cloud_color',
            'fisher', 'williams_r', 'kama', 'roc', 'mom',
            'dmi_plus', 'dmi_minus', 'supertrend',
            'zigzag', 'pivot_point', 'gann',
            'moving_median', 'trix', 'linear_regression',
        ]
        
        for ind in all_indicators:
            col_name = f'ind_{ind}'
            if col_name not in filled or filled[col_name] is None:
                # Nutze default oder 0
                if ind in default_indicators:
                    filled[col_name] = self._validate_numeric(default_indicators[ind])
                else:
                    filled[col_name] = 0.0
            else:
                filled[col_name] = self._validate_numeric(filled[col_name])
        
        # Orderbook
        ob_fields = ['ob_bid_volume', 'ob_ask_volume', 'ob_imbalance', 'ob_spread', 'ob_whale_bids', 'ob_whale_asks']
        for field in ob_fields:
            if field not in filled or filled[field] is None:
                filled[field] = 0.0
            else:
                filled[field] = self._validate_numeric(filled[field])
        
        # Market fields
        market_fields = ['volatility_1h', 'volume_24h', 'price_change_24h', 'btc_correlation', 'funding_rate']
        for field in market_fields:
            if field not in filled or filled[field] is None:
                filled[field] = 0.0
            else:
                filled[field] = self._validate_numeric(filled[field])
        
        return filled
    
    def _validate_numeric(self, value, allow_none=False) -> float:
        """Konvertiere zu float, ersetze invalid mit 0"""
        if value is None:
            return None if allow_none else 0.0
        
        try:
            val = float(value)
            if np.isnan(val) or np.isinf(val):
                return 0.0
            if abs(val) > 1e10:
                return np.sign(val) * 1e10
            return round(val, 8)
        except:
            return 0.0 if not allow_none else None
    
    def record_entry(self, trade_data: dict, all_indicators: dict = None):
        """Zeichne Entry auf - JEDE ZEILE wird hier CSV-Reihe"""
        with self.lock:
            try:
                trade_id = self._generate_trade_id()
                timestamp = datetime.now().isoformat()
                
                # F√ºlle fehlende Indikatoren
                if all_indicators is None:
                    all_indicators = {}
                filled_data = self._fill_missing_indicators(trade_data, all_indicators)
                
                # Erstelle interne Trade-Daten
                trade = {
                    'trade_id': trade_id,
                    'timestamp_entry': timestamp,
                    'entry_data': filled_data.copy(),
                }
                self.trades[trade_id] = trade
                
                # Erstelle CSV-Zeile (Entry-Reihe)
                csv_row = {
                    'row_type': 'ENTRY',
                    'trade_id': trade_id,
                    'timestamp': timestamp,
                }
                
                # Kopiere alle Entry-Daten in CSV-Zeile
                for key in self._get_column_names():
                    if key in ['row_type', 'trade_id', 'timestamp']:
                        continue
                    csv_row[key] = filled_data.get(key)
                
                self.csv_rows.append(csv_row)
                self._save_json()
                self._write_csv()
                
                self.logger.log(f"‚úÖ Trade entry recorded: {trade_id}", "INFO")
                return trade_id
                
            except Exception as e:
                self.logger.log(f"CRITICAL: Failed to record entry: {e}", "ERROR", True)
                return None
    
    def update_exit(self, trade_id: str, exit_data: dict, all_indicators: dict = None):
        """Update Trade mit Exit - Erstelle EXIT-Reihe mit ALLEN Indikatoren"""
        with self.lock:
            try:
                if trade_id not in self.trades:
                    self.logger.log(f"Trade {trade_id} not found!", "ERROR")
                    return False
                
                trade = self.trades[trade_id]
                timestamp = datetime.now().isoformat()
                
                # F√ºlle fehlende Indikatoren
                if all_indicators is None:
                    all_indicators = {}
                
                # Kombiniere Entry- und Exit-Daten
                combined_data = trade['entry_data'].copy()
                combined_data.update(exit_data)
                
                # F√ºlle nochmal um sicherzustellen dass ALLE Indikatoren da sind
                combined_data = self._fill_missing_indicators(combined_data, all_indicators)
                
                # Erstelle EXIT-Reihe in CSV
                csv_row = {
                    'row_type': 'EXIT',
                    'trade_id': trade_id,
                    'timestamp': timestamp,
                }
                
                for key in self._get_column_names():
                    if key in ['row_type', 'trade_id', 'timestamp']:
                        continue
                    csv_row[key] = combined_data.get(key)
                
                # Berechne hold_time wenn Entry-Timestamp da
                if 'timestamp_entry' in trade:
                    try:
                        entry_time = datetime.fromisoformat(trade['timestamp_entry'])
                        exit_time = datetime.fromisoformat(timestamp)
                        csv_row['hold_time_seconds'] = int((exit_time - entry_time).total_seconds())
                    except:
                        pass
                
                self.csv_rows.append(csv_row)
                
                # Update interne Trade-Daten
                trade['timestamp_exit'] = timestamp
                trade['exit_data'] = combined_data.copy()
                
                self._save_json()
                self._write_csv()
                
                self.logger.log(f"‚úÖ Trade exit recorded: {trade_id}", "INFO")
                return True
                
            except Exception as e:
                self.logger.log(f"CRITICAL: Failed to record exit: {e}", "ERROR", True)
                return False
    
    def record_update(self, trade_id: str, update_data: dict, all_indicators: dict = None):
        """
        Zeichne ein UPDATE auf - wird aufgerufen wenn wichtige Milestones erreicht werden!
        z.B. bei 5%, 10%, 15% etc. PnL
        """
        with self.lock:
            try:
                if trade_id not in self.trades:
                    self.logger.log(f"Trade {trade_id} not found for update!", "WARNING")
                    return False
                
                trade = self.trades[trade_id]
                timestamp = datetime.now().isoformat()
                
                # F√ºlle fehlende Indikatoren
                if all_indicators is None:
                    all_indicators = {}
                
                # Kombiniere Entry-Daten mit Update-Daten
                combined_data = trade['entry_data'].copy()
                combined_data.update(update_data)
                combined_data = self._fill_missing_indicators(combined_data, all_indicators)
                
                # Erstelle UPDATE-Zeile in CSV
                csv_row = {
                    'row_type': 'UPDATE',
                    'trade_id': trade_id,
                    'timestamp': timestamp,
                }
                
                for key in self._get_column_names():
                    if key in ['row_type', 'trade_id', 'timestamp']:
                        continue
                    csv_row[key] = combined_data.get(key)
                
                # Berechne aktuelle hold_time
                if 'timestamp_entry' in trade:
                    try:
                        entry_time = datetime.fromisoformat(trade['timestamp_entry'])
                        update_time = datetime.fromisoformat(timestamp)
                        csv_row['hold_time_seconds'] = int((update_time - entry_time).total_seconds())
                    except:
                        pass
                
                self.csv_rows.append(csv_row)
                self._save_json()
                self._write_csv()
                
                self.logger.log(f"üìä Trade UPDATE recorded: {trade_id} - PnL: {update_data.get('current_pnl', 0):.2f}%", "INFO")
                return True
                
            except Exception as e:
                self.logger.log(f"Error recording update: {e}", "ERROR", True)
                return False
    
    def _generate_trade_id(self) -> str:
        """Generiere eindeutige ID"""
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S%f")
        random_part = hashlib.md5(str(time.time()).encode()).hexdigest()[:6]
        return f"T{timestamp}_{random_part}"
    
    def get_strategy_stats(self, strategy_name: str) -> dict:
        """Hole Statistiken f√ºr eine Strategie"""
        try:
            exit_rows = [r for r in self.csv_rows if r.get('row_type') == 'EXIT' and r.get('strategy') == strategy_name]
            
            if not exit_rows:
                return {'trades': 0, 'win_rate': 0, 'avg_pnl': 0, 'total_pnl': 0}
            
            pnls = [self._validate_numeric(r.get('net_pnl_percent')) for r in exit_rows]
            pnls_usd = [self._validate_numeric(r.get('net_pnl_usd')) for r in exit_rows]
            
            wins = sum(1 for p in pnls if p > 0)
            
            return {
                'trades': len(exit_rows),
                'win_rate': wins / len(exit_rows) * 100 if exit_rows else 0,
                'avg_pnl': sum(pnls) / len(pnls) if pnls else 0,
                'total_pnl': sum(pnls_usd),
                'best_trade': max(pnls) if pnls else 0,
                'worst_trade': min(pnls) if pnls else 0,
            }
        except Exception as e:
            self.logger.log(f"Error getting stats: {e}", "ERROR")
            return {'trades': 0, 'win_rate': 0, 'avg_pnl': 0, 'total_pnl': 0}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# EXCHANGE CONNECTION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ExchangeConnector:
    """
    KuCoin Futures Connector mit:
    - Korrekter Leverage-Setzung
    - Korrektem Position Sizing (contractSize!)
    - Automatischer Reconnection
    """
    
    def __init__(self, config: Config, logger: Logger):
        self.config = config
        self.logger = logger
        self.exchange = None
        self.markets = {}
        self._connect()
    
    def _connect(self):
        """Verbinde mit Exchange"""
        try:
            self.exchange = ccxt.kucoinfutures({
                'apiKey': self.config.API_KEY,
                'secret': self.config.API_SECRET,
                'password': self.config.API_PASSPHRASE,
                'sandbox': False,
                'enableRateLimit': True,
                'options': {
                    'defaultType': 'swap',
                    'adjustForTimeDifference': True,
                }
            })
            
            # Lade Markets
            self.markets = self.exchange.load_markets()
            self.logger.log(f"Connected to KuCoin Futures - {len(self.markets)} markets loaded", "INFO")
            
            # Test Balance
            balance = self.get_balance()
            self.logger.log(f"Account Balance: ${balance:.2f} USDT", "INFO")
            
        except Exception as e:
            self.logger.log(f"Connection failed: {e}", "ERROR", True)
            raise
    
    def reconnect(self):
        """Reconnect bei Verbindungsverlust"""
        self.logger.log("Attempting reconnection...", "WARNING")
        time.sleep(self.config.RECONNECT_DELAY_SECONDS)
        self._connect()
    
    def get_balance(self) -> float:
        """Hole USDT Balance"""
        try:
            balance = self.exchange.fetch_balance()
            usdt_balance = balance.get('USDT', {}).get('free', 0)
            return float(usdt_balance) if usdt_balance else 0.0
        except Exception as e:
            self.logger.log(f"Error fetching balance: {e}", "ERROR", True)
            return 0.0
    
    def get_top_coins(self, limit: int = None) -> list:
        """Hole Top-Coins nach 24h Volume"""
        limit = limit or self.config.TOP_COINS_TO_SCAN
        try:
            tickers = self.exchange.fetch_tickers()
            
            # Filter f√ºr USDT Perpetuals
            usdt_tickers = {
                k: v for k, v in tickers.items() 
                if k.endswith(':USDT') and '/USDT' in k
            }
            
            # Sortiere nach Volume
            sorted_tickers = sorted(
                usdt_tickers.items(),
                key=lambda x: float(x[1].get('quoteVolume', 0) or 0),
                reverse=True
            )
            
            top_coins = [t[0] for t in sorted_tickers[:limit]]
            self.logger.log(f"Top {len(top_coins)} coins by volume loaded", "DEBUG")
            return top_coins
            
        except Exception as e:
            self.logger.log(f"Error fetching top coins: {e}", "ERROR", True)
            return ['BTC/USDT:USDT', 'ETH/USDT:USDT', 'SOL/USDT:USDT']
    
    def get_market_info(self, symbol: str) -> dict:
        """Hole Market Info inkl. contractSize"""
        try:
            market = self.exchange.market(symbol)
            return {
                'symbol': symbol,
                'contract_size': float(market.get('contractSize', 1)),
                'min_amount': market['limits']['amount']['min'],
                'min_cost': market['limits'].get('cost', {}).get('min', 0),
                'price_precision': market['precision']['price'],
                'amount_precision': market['precision']['amount'],
                'maker_fee': market.get('maker', self.config.MAKER_FEE),
                'taker_fee': market.get('taker', self.config.TAKER_FEE),
            }
        except Exception as e:
            self.logger.log(f"Error getting market info for {symbol}: {e}", "ERROR")
            return None
    
    def set_leverage(self, symbol: str, leverage: int) -> bool:
        """
        WICHTIG: Setze Leverage KORREKT bei KuCoin!
        Diese Funktion wird VOR jedem Trade aufgerufen!
        """
        try:
            # KuCoin Futures spezifischer Aufruf
            self.exchange.set_leverage(leverage, symbol)
            self.logger.log(f"Leverage set to {leverage}x for {symbol}", "INFO")
            return True
        except ccxt.ExchangeError as e:
            if 'leverage' in str(e).lower():
                self.logger.log(f"Leverage already set or not changeable: {e}", "WARNING")
                return True
            self.logger.log(f"Error setting leverage for {symbol}: {e}", "ERROR", True)
            return False
        except Exception as e:
            self.logger.log(f"Error setting leverage: {e}", "ERROR", True)
            return False
    
    def calculate_position_size(self, symbol: str, price: float, leverage: int) -> tuple:
        """
        KORREKTE Position Size Berechnung!
        Ber√ºcksichtigt contractSize und min_amount korrekt.
        
        Returns: (position_size_in_coins, actual_leverage)
        """
        try:
            balance = self.get_balance()
            if balance <= 0:
                self.logger.log("No balance available!", "ERROR")
                return 0.0, leverage
            
            market = self.get_market_info(symbol)
            if not market:
                return 0.0, leverage
            
            contract_size = market['contract_size']
            min_contracts = market['min_amount']
            
            # Berechne Position in USD
            position_usd = balance * self.config.POSITION_SIZE_PERCENT * leverage
            
            # Umrechnung in Coins
            coin_amount = position_usd / price
            
            # Umrechnung in Kontrakte
            contracts = coin_amount / contract_size
            
            # Pr√ºfe Mindestmenge (in Kontrakten!)
            if contracts < min_contracts:
                contracts = min_contracts
                self.logger.log(f"Position increased to minimum: {contracts} contracts", "DEBUG")
            
            # Zur√ºck zu Coins
            final_coin_amount = contracts * contract_size
            
            # Runde entsprechend Precision
            if isinstance(market['amount_precision'], int):
                final_coin_amount = round(final_coin_amount, market['amount_precision'])
            else:
                final_coin_amount = float(
                    self.exchange.amount_to_precision(symbol, final_coin_amount)
                )
            
            # Pr√ºfe ob wir genug Balance haben
            required_margin = (final_coin_amount * price) / leverage
            if required_margin > balance * 0.95:
                # Skaliere runter
                max_coin_amount = (balance * 0.9 * leverage) / price
                final_coin_amount = float(
                    self.exchange.amount_to_precision(symbol, max_coin_amount)
                )
                
                if (final_coin_amount / contract_size) < min_contracts:
                    self.logger.log(f"Balance too low for minimum position on {symbol}", "ERROR")
                    return 0.0, leverage
            
            self.logger.log(
                f"Position sizing: {symbol} | "
                f"Balance: ${balance:.2f} | "
                f"Position: {final_coin_amount} coins ({final_coin_amount/contract_size:.0f} contracts) | "
                f"Value: ${final_coin_amount * price:.2f} | "
                f"Leverage: {leverage}x | "
                f"Margin: ${(final_coin_amount * price)/leverage:.2f}",
                "INFO"
            )
            
            return final_coin_amount, leverage
            
        except Exception as e:
            self.logger.log(f"Error calculating position size: {e}", "ERROR", True)
            return 0.0, leverage
    
    def place_order(self, symbol: str, side: str, amount: float, 
                   leverage: int, stop_loss: float = None) -> dict:
        """
        Platziere Order mit:
        - Korrekter Leverage-Setzung
        - Hard Stop-Loss (IMMER!)
        - Vollst√§ndiger Response-Info
        """
        try:
            # 1. Setze Leverage ZUERST!
            if not self.set_leverage(symbol, leverage):
                self.logger.log(f"Failed to set leverage, aborting order", "ERROR")
                return None
            
            # Kleine Pause f√ºr API
            time.sleep(0.5)
            
            # 2. Platziere Market Order
            order_params = {
                'leverage': leverage,  # Nochmal im Order-Params
            }
            
            order = self.exchange.create_market_order(
                symbol=symbol,
                side=side,
                amount=amount,
                params=order_params
            )
            
            self.logger.log(
                f"ORDER PLACED: {side.upper()} {amount} {symbol} @ Market | "
                f"Leverage: {leverage}x | Order ID: {order['id']}",
                "INFO"
            )
            
            # 3. Setze Hard Stop-Loss (WICHTIG f√ºr Bot-Absturz!)
            if stop_loss:
                try:
                    time.sleep(0.5)
                    sl_side = 'sell' if side == 'buy' else 'buy'
                    
                    sl_order = self.exchange.create_order(
                        symbol=symbol,
                        type='stop',
                        side=sl_side,
                        amount=amount,
                        price=stop_loss,
                        params={
                            'stopPrice': stop_loss,
                            'reduceOnly': True,
                        }
                    )
                    
                    self.logger.log(
                        f"HARD STOP-LOSS SET: {stop_loss} for {symbol} | Order ID: {sl_order['id']}",
                        "INFO"
                    )
                    order['stop_loss_order_id'] = sl_order['id']
                    
                except Exception as sl_error:
                    self.logger.log(
                        f"WARNING: Failed to set stop-loss: {sl_error}",
                        "WARNING"
                    )
            
            # 4. Hole tats√§chlichen Fill-Preis - NIEMALS None zur√ºckgeben!
            time.sleep(0.3)
            try:
                filled_order = self.exchange.fetch_order(order['id'], symbol)
                actual_fill = filled_order.get('average') or filled_order.get('price') or filled_order.get('lastTradePrice')
                order['actual_fill_price'] = actual_fill
                order['actual_fill_amount'] = filled_order.get('filled', amount)
                order['fees'] = filled_order.get('fee', {})
            except Exception as e:
                # Fallback: Nutze was im Order ist, oder hole aktuellen Marktpreis
                order['actual_fill_price'] = order.get('average') or order.get('price')
                order['actual_fill_amount'] = order.get('filled', amount)
                
                # Letzter Fallback: Hole aktuellen Ticker
                if order['actual_fill_price'] is None:
                    try:
                        ticker = self.exchange.fetch_ticker(symbol)
                        order['actual_fill_price'] = ticker['last']
                        self.logger.log(f"‚ö†Ô∏è Using ticker price as fill price: {ticker['last']}", "WARNING")
                    except:
                        # Ganz letzter Fallback: Nutze 0 (wird in open_position nochmal gepr√ºft)
                        order['actual_fill_price'] = None
                        self.logger.log(f"üö® Could not determine fill price for {symbol}!", "ERROR")
            
            return order
            
        except ccxt.InsufficientFunds as e:
            self.logger.log(f"Insufficient funds: {e}", "ERROR")
            return None
        except ccxt.ExchangeError as e:
            self.logger.log(f"Exchange error: {e}", "ERROR", True)
            return None
        except Exception as e:
            self.logger.log(f"Order placement failed: {e}", "ERROR", True)
            return None
    
    def close_position(self, symbol: str, side: str, amount: float) -> dict:
        """Schlie√üe Position und hole tats√§chlichen Exit-Preis - MIT ROBUSTEM FALLBACK!"""
        try:
            close_side = 'sell' if side == 'buy' else 'buy'
            
            # Hole aktuellen Preis VOR dem Close f√ºr Fallback
            pre_close_price = None
            try:
                ticker = self.exchange.fetch_ticker(symbol)
                pre_close_price = ticker['last']
            except:
                pass
            
            try:
                order = self.exchange.create_market_order(
                    symbol=symbol,
                    side=close_side,
                    amount=amount,
                    params={'reduceOnly': True}
                )
            except Exception as e:
                error_str = str(e)
                # Pr√ºfe ob Position schon geschlossen ist
                if "No open positions" in error_str or "300009" in error_str:
                    self.logger.log(
                        f"‚ö†Ô∏è Position {symbol} already closed on exchange (oder nicht offen)",
                        "WARNING"
                    )
                    # Returne success um Ghost Position zu clearen
                    return {
                        'order': None,
                        'actual_exit_price': pre_close_price,  # Nutze pre-close Preis
                        'actual_exit_amount': 0,
                        'fees': {},
                        'already_closed': True,
                    }
                else:
                    raise  # Anderen Fehler weiterwerfen
            
            # Hole tats√§chlichen Fill-Preis - MEHRERE VERSUCHE!
            actual_exit_price = None
            actual_exit_amount = amount
            fees = {}
            
            for attempt in range(3):  # 3 Versuche
                time.sleep(0.3 + attempt * 0.2)  # L√§ngere Wartezeit pro Versuch
                try:
                    filled_order = self.exchange.fetch_order(order['id'], symbol)
                    actual_exit_price = (
                        filled_order.get('average') or 
                        filled_order.get('price') or 
                        filled_order.get('lastTradePrice')
                    )
                    actual_exit_amount = filled_order.get('filled') or amount
                    fees = filled_order.get('fee', {})
                    
                    if actual_exit_price:
                        break  # Erfolgreich, beende Loop
                except Exception as e:
                    self.logger.log(f"Attempt {attempt+1}: Error fetching filled order: {e}", "WARNING")
            
            # Falls immer noch kein Preis, nutze Fallbacks
            if actual_exit_price is None:
                actual_exit_price = order.get('average') or order.get('price') or pre_close_price
                self.logger.log(
                    f"‚ö†Ô∏è Using fallback exit price for {symbol}: {actual_exit_price}",
                    "WARNING"
                )
            
            # Letzter Fallback: Aktueller Ticker
            if actual_exit_price is None:
                try:
                    ticker = self.exchange.fetch_ticker(symbol)
                    actual_exit_price = ticker['last']
                    self.logger.log(f"‚ö†Ô∏è Using post-close ticker as exit price: {actual_exit_price}", "WARNING")
                except:
                    self.logger.log(f"üö® Could not determine exit price for {symbol}!", "ERROR")
            
            self.logger.log(
                f"POSITION CLOSED: {close_side.upper()} {amount} {symbol} | "
                f"Exit Price: {actual_exit_price}",
                "INFO"
            )
            
            return {
                'order': order,
                'actual_exit_price': actual_exit_price,
                'actual_exit_amount': actual_exit_amount,
                'fees': fees,
                'already_closed': False,
            }
            
        except Exception as e:
            self.logger.log(f"Error closing position: {e}", "ERROR", True)
            return None
    
    def get_open_positions(self) -> list:
        """Hole alle offenen Positionen"""
        try:
            positions = self.exchange.fetch_positions()
            open_positions = [
                p for p in positions 
                if float(p.get('contracts', 0) or 0) > 0
            ]
            return open_positions
        except Exception as e:
            self.logger.log(f"Error fetching positions: {e}", "ERROR", True)
            return []
    
    def get_order_book(self, symbol: str, limit: int = None) -> dict:
        """Hole Order Book f√ºr Analyse"""
        limit = limit or self.config.ORDERBOOK_DEPTH
        try:
            orderbook = self.exchange.fetch_order_book(symbol, limit)
            return orderbook
        except Exception as e:
            self.logger.log(f"Error fetching orderbook: {e}", "ERROR")
            return {'bids': [], 'asks': []}
    
    def get_funding_rate(self, symbol: str) -> float:
        """Hole aktuelle Funding Rate"""
        try:
            funding = self.exchange.fetch_funding_rate(symbol)
            return float(funding.get('fundingRate', 0) or 0)
        except:
            return 0.0
    
    def fetch_ohlcv(self, symbol: str, timeframe: str = '5m', limit: int = 200) -> pd.DataFrame:
        """Hole OHLCV Daten als DataFrame"""
        try:
            ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            return df
        except Exception as e:
            self.logger.log(f"Error fetching OHLCV for {symbol}: {e}", "ERROR")
            return pd.DataFrame()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üöÄ ULTRA PERFORMANCE MODULE - TOP 0.000001% FEATURES!
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FastPriceCache:
    """
    Ultra-schneller Preis-Cache mit Thread-Safe Access
    - Cached Preise f√ºr 100ms
    - Parallel Fetching f√ºr mehrere Symbole
    - Reduziert API-Calls um 90%!
    """
    
    def __init__(self, exchange: ExchangeConnector, logger: Logger):
        self.exchange = exchange
        self.logger = logger
        self.cache = {}
        self.cache_timestamps = {}
        self.lock = threading.Lock()
        self.CACHE_TTL_MS = 100  # 100ms Cache
        
    def get_price(self, symbol: str) -> float:
        """Hole Preis - aus Cache wenn frisch, sonst API"""
        now = time.time() * 1000
        
        with self.lock:
            if symbol in self.cache:
                age = now - self.cache_timestamps.get(symbol, 0)
                if age < self.CACHE_TTL_MS:
                    return self.cache[symbol]
        
        # Fetch neuen Preis
        try:
            ticker = self.exchange.exchange.fetch_ticker(symbol)
            price = float(ticker['last'])
            
            with self.lock:
                self.cache[symbol] = price
                self.cache_timestamps[symbol] = now
            
            return price
        except Exception as e:
            # Fallback zu cached Wert
            with self.lock:
                if symbol in self.cache:
                    return self.cache[symbol]
            return 0
    
    def get_prices_parallel(self, symbols: list) -> dict:
        """Hole mehrere Preise PARALLEL - viel schneller!"""
        results = {}
        
        def fetch_single(sym):
            results[sym] = self.get_price(sym)
        
        threads = []
        for symbol in symbols:
            t = threading.Thread(target=fetch_single, args=(symbol,))
            t.start()
            threads.append(t)
        
        for t in threads:
            t.join(timeout=2)  # Max 2s warten
        
        return results
    
    def update_price(self, symbol: str, price: float):
        """Manuelles Update (z.B. von WebSocket)"""
        with self.lock:
            self.cache[symbol] = price
            self.cache_timestamps[symbol] = time.time() * 1000


class TrailingStopManager:
    """
    Intelligenter Trailing Stop Manager
    - Aktiviert erst ab X% Profit
    - Verschiedene Modi: Fixed, ATR-based, Percentage
    - Speichert Trail-History f√ºr Analyse
    """
    
    def __init__(self, config, logger: Logger):
        self.config = config
        self.logger = logger
        self.trails = {}  # position_id -> trail_data
        self.lock = threading.Lock()
        
        # Trailing Stop Konfiguration
        self.ACTIVATION_PROFIT_PCT = 3.0  # Aktiviere ab 3% Profit
        self.TRAIL_DISTANCE_PCT = 1.5     # 1.5% unter Peak
        self.ATR_MULTIPLIER = 2.0         # Oder 2x ATR
        self.USE_ATR_TRAILING = True      # ATR-basiert statt fixed
    
    def update_trail(self, position_id: str, position: dict, current_price: float, 
                     atr: float = None) -> dict:
        """
        Update Trailing Stop f√ºr Position
        Returns: {'triggered': bool, 'new_stop': float, 'reason': str}
        """
        with self.lock:
            entry_price = position['entry_price']
            side = position['side']
            leverage = position.get('leverage', 10)
            is_long = side in ['buy', 'long']
            
            # Berechne aktuellen PnL
            if is_long:
                current_pnl = (current_price - entry_price) / entry_price * 100 * leverage
            else:
                current_pnl = (entry_price - current_price) / entry_price * 100 * leverage
            
            # Initialisiere Trail-Daten wenn n√∂tig
            if position_id not in self.trails:
                self.trails[position_id] = {
                    'active': False,
                    'peak_price': current_price,
                    'peak_pnl': current_pnl,
                    'current_stop': position.get('stop_loss_price', 0),
                    'history': []
                }
            
            trail = self.trails[position_id]
            
            # Aktiviere Trailing wenn Profit-Schwelle erreicht
            if not trail['active'] and current_pnl >= self.ACTIVATION_PROFIT_PCT:
                trail['active'] = True
                self.logger.log(
                    f"üéØ Trailing Stop ACTIVATED for {position.get('symbol')} at {current_pnl:.2f}%",
                    "INFO"
                )
            
            if not trail['active']:
                return {'triggered': False, 'new_stop': trail['current_stop'], 'reason': None}
            
            # Update Peak
            if is_long and current_price > trail['peak_price']:
                trail['peak_price'] = current_price
                trail['peak_pnl'] = current_pnl
            elif not is_long and current_price < trail['peak_price']:
                trail['peak_price'] = current_price
                trail['peak_pnl'] = current_pnl
            
            # Berechne neuen Stop
            if self.USE_ATR_TRAILING and atr and atr > 0:
                trail_distance = atr * self.ATR_MULTIPLIER
            else:
                trail_distance = trail['peak_price'] * (self.TRAIL_DISTANCE_PCT / 100)
            
            if is_long:
                new_stop = trail['peak_price'] - trail_distance
                # Stop nur nach oben anpassen!
                if new_stop > trail['current_stop']:
                    old_stop = trail['current_stop']
                    trail['current_stop'] = new_stop
                    trail['history'].append({
                        'time': datetime.now().isoformat(),
                        'old': old_stop,
                        'new': new_stop,
                        'peak': trail['peak_price']
                    })
                    self.logger.log(
                        f"üìà Trail Stop raised: {position.get('symbol')} | "
                        f"Peak: {trail['peak_price']:.6f} | New Stop: {new_stop:.6f}",
                        "INFO"
                    )
            else:
                new_stop = trail['peak_price'] + trail_distance
                # Stop nur nach unten anpassen!
                if trail['current_stop'] == 0 or new_stop < trail['current_stop']:
                    old_stop = trail['current_stop']
                    trail['current_stop'] = new_stop
                    trail['history'].append({
                        'time': datetime.now().isoformat(),
                        'old': old_stop,
                        'new': new_stop,
                        'peak': trail['peak_price']
                    })
            
            # Pr√ºfe ob Stop getriggert
            triggered = False
            reason = None
            
            if is_long and current_price <= trail['current_stop']:
                triggered = True
                reason = f"TRAILING_STOP (Peak:{trail['peak_pnl']:.2f}% -> Current:{current_pnl:.2f}%)"
            elif not is_long and current_price >= trail['current_stop']:
                triggered = True
                reason = f"TRAILING_STOP (Peak:{trail['peak_pnl']:.2f}% -> Current:{current_pnl:.2f}%)"
            
            return {
                'triggered': triggered,
                'new_stop': trail['current_stop'],
                'reason': reason,
                'peak_pnl': trail['peak_pnl'],
                'current_pnl': current_pnl
            }
    
    def remove_trail(self, position_id: str):
        """Entferne Trail-Daten nach Position-Close"""
        with self.lock:
            if position_id in self.trails:
                del self.trails[position_id]


class LiquidationCalculator:
    """
    Berechnet Liquidationspreis f√ºr Positionen
    - Ber√ºcksichtigt Maintenance Margin
    - Warnt bei gef√§hrlicher N√§he
    """
    
    MAINTENANCE_MARGIN_RATE = 0.005  # 0.5% f√ºr KuCoin Futures
    
    @staticmethod
    def calculate_liquidation_price(entry_price: float, leverage: float, 
                                     side: str, margin: float = None) -> float:
        """
        Berechne Liquidationspreis
        
        F√ºr Long: Liq = Entry * (1 - 1/Leverage + MMR)
        F√ºr Short: Liq = Entry * (1 + 1/Leverage - MMR)
        """
        mmr = LiquidationCalculator.MAINTENANCE_MARGIN_RATE
        is_long = side in ['buy', 'long']
        
        if leverage <= 0:
            leverage = 1
        
        if is_long:
            liq_price = entry_price * (1 - (1 / leverage) + mmr)
        else:
            liq_price = entry_price * (1 + (1 / leverage) - mmr)
        
        return max(liq_price, 0)
    
    @staticmethod
    def get_liquidation_distance(current_price: float, liq_price: float, 
                                  side: str) -> float:
        """Berechne Distanz zur Liquidation in %"""
        if liq_price <= 0:
            return 100
        
        is_long = side in ['buy', 'long']
        
        if is_long:
            distance = (current_price - liq_price) / current_price * 100
        else:
            distance = (liq_price - current_price) / current_price * 100
        
        return max(distance, 0)
    
    @staticmethod
    def is_liquidation_danger(distance_pct: float, threshold: float = 5.0) -> bool:
        """Pr√ºfe ob Position in Liquidations-Gefahr ist (< 5% default)"""
        return distance_pct < threshold


class SlippageTracker:
    """
    Trackt und analysiert Slippage √ºber Zeit
    - Entry Slippage
    - Exit Slippage
    - Per-Symbol Statistiken
    """
    
    def __init__(self, logger: Logger):
        self.logger = logger
        self.slippage_history = []
        self.symbol_stats = {}
        self.lock = threading.Lock()
    
    def record_slippage(self, symbol: str, expected_price: float, 
                        actual_price: float, side: str, order_type: str):
        """Zeichne Slippage auf"""
        if expected_price <= 0:
            return
        
        slippage_pct = abs(actual_price - expected_price) / expected_price * 100
        is_favorable = (
            (side == 'buy' and actual_price < expected_price) or
            (side == 'sell' and actual_price > expected_price)
        )
        
        record = {
            'timestamp': datetime.now().isoformat(),
            'symbol': symbol,
            'expected': expected_price,
            'actual': actual_price,
            'slippage_pct': slippage_pct,
            'favorable': is_favorable,
            'side': side,
            'order_type': order_type
        }
        
        with self.lock:
            self.slippage_history.append(record)
            
            # Update Symbol-Stats
            if symbol not in self.symbol_stats:
                self.symbol_stats[symbol] = {
                    'total_trades': 0,
                    'total_slippage': 0,
                    'max_slippage': 0,
                    'favorable_count': 0
                }
            
            stats = self.symbol_stats[symbol]
            stats['total_trades'] += 1
            stats['total_slippage'] += slippage_pct
            stats['max_slippage'] = max(stats['max_slippage'], slippage_pct)
            if is_favorable:
                stats['favorable_count'] += 1
        
        if slippage_pct > 0.1:  # Log nur wenn > 0.1%
            self.logger.log(
                f"üìä Slippage: {symbol} | Expected: {expected_price:.6f} | "
                f"Actual: {actual_price:.6f} | Slip: {slippage_pct:.3f}% "
                f"({'‚úÖ favorable' if is_favorable else '‚ùå unfavorable'})",
                "INFO"
            )
    
    def get_avg_slippage(self, symbol: str = None) -> float:
        """Hole durchschnittliche Slippage"""
        with self.lock:
            if symbol:
                if symbol in self.symbol_stats:
                    stats = self.symbol_stats[symbol]
                    if stats['total_trades'] > 0:
                        return stats['total_slippage'] / stats['total_trades']
                return 0
            else:
                total = sum(s['total_slippage'] for s in self.symbol_stats.values())
                count = sum(s['total_trades'] for s in self.symbol_stats.values())
                return total / count if count > 0 else 0
    
    def get_stats_summary(self) -> dict:
        """Hole Zusammenfassung aller Slippage-Stats"""
        with self.lock:
            return {
                'total_records': len(self.slippage_history),
                'avg_slippage': self.get_avg_slippage(),
                'symbols': dict(self.symbol_stats)
            }


class RateLimiter:
    """
    Intelligenter Rate Limiter f√ºr API Calls
    - Verhindert Rate Limit Errors
    - Adaptive Throttling
    - Per-Endpoint Limits
    """
    
    def __init__(self, logger: Logger):
        self.logger = logger
        self.call_history = {}  # endpoint -> list of timestamps
        self.lock = threading.Lock()
        
        # KuCoin Limits (konservativ)
        self.LIMITS = {
            'default': {'calls': 10, 'period': 1},      # 10 calls/sec
            'orders': {'calls': 30, 'period': 3},       # 30 orders/3sec
            'positions': {'calls': 10, 'period': 1},    # 10/sec
            'ticker': {'calls': 20, 'period': 1},       # 20/sec
        }
    
    def wait_if_needed(self, endpoint: str = 'default'):
        """Warte wenn Rate Limit erreicht"""
        limit = self.LIMITS.get(endpoint, self.LIMITS['default'])
        max_calls = limit['calls']
        period = limit['period']
        
        with self.lock:
            now = time.time()
            
            if endpoint not in self.call_history:
                self.call_history[endpoint] = []
            
            # Entferne alte Eintr√§ge
            self.call_history[endpoint] = [
                t for t in self.call_history[endpoint] 
                if now - t < period
            ]
            
            # Pr√ºfe ob Limit erreicht
            if len(self.call_history[endpoint]) >= max_calls:
                # Warte bis √§ltester Call expired
                oldest = min(self.call_history[endpoint])
                wait_time = period - (now - oldest) + 0.1  # +100ms Buffer
                
                if wait_time > 0:
                    self.logger.log(
                        f"‚è≥ Rate limit reached for {endpoint}, waiting {wait_time:.2f}s",
                        "DEBUG"
                    )
                    time.sleep(wait_time)
            
            # Registriere diesen Call
            self.call_history[endpoint].append(time.time())
    
    def get_remaining(self, endpoint: str = 'default') -> int:
        """Hole verbleibende Calls"""
        limit = self.LIMITS.get(endpoint, self.LIMITS['default'])
        
        with self.lock:
            now = time.time()
            if endpoint not in self.call_history:
                return limit['calls']
            
            recent = [t for t in self.call_history[endpoint] if now - t < limit['period']]
            return max(0, limit['calls'] - len(recent))


class ParallelPositionChecker:
    """
    Pr√ºft Positionen PARALLEL statt sequentiell
    - 3-5x schneller bei vielen offenen Positionen
    - Thread Pool f√ºr effiziente Ressourcennutzung
    """
    
    def __init__(self, config, logger: Logger, max_workers: int = 5):
        self.config = config
        self.logger = logger
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.results = {}
        self.lock = threading.Lock()
    
    def check_positions_parallel(self, positions: dict, check_func) -> dict:
        """
        Pr√ºfe alle Positionen parallel
        
        Args:
            positions: dict of position_id -> position_data
            check_func: function(pos_id, position) -> result
        
        Returns:
            dict of position_id -> check_result
        """
        results = {}
        futures = {}
        
        for pos_id, position in positions.items():
            future = self.executor.submit(check_func, pos_id, position)
            futures[pos_id] = future
        
        # Sammle Ergebnisse
        for pos_id, future in futures.items():
            try:
                result = future.result(timeout=5)  # Max 5s pro Position
                results[pos_id] = result
            except Exception as e:
                self.logger.log(f"Parallel check error for {pos_id}: {e}", "ERROR")
                results[pos_id] = None
        
        return results
    
    def shutdown(self):
        """Shutdown ThreadPool"""
        self.executor.shutdown(wait=False)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TECHNICAL INDICATORS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class TechnicalIndicators:
    """
    Umfangreiche technische Indikatoren
    Alle Berechnungen f√ºr Logging verf√ºgbar
    """
    
    @staticmethod
    def calculate_all(df: pd.DataFrame) -> dict:
        """Berechne ALLE Indikatoren auf einmal - 40+ verschiedene!"""
        if len(df) < 50:
            return {}
        
        indicators = {}
        close = df['close'].values
        high = df['high'].values
        low = df['low'].values
        volume = df['volume'].values
        
        try:
            # RSI
            indicators['rsi_14'] = TechnicalIndicators.rsi(close, 14)
            indicators['rsi_7'] = TechnicalIndicators.rsi(close, 7)
            indicators['rsi_5'] = TechnicalIndicators.rsi(close, 5)
            
            # MACD
            macd, signal, hist = TechnicalIndicators.macd(close)
            indicators['macd'] = macd
            indicators['macd_signal'] = signal
            indicators['macd_hist'] = hist
            
            # EMAs
            indicators['ema_9'] = TechnicalIndicators.ema(close, 9)
            indicators['ema_21'] = TechnicalIndicators.ema(close, 21)
            indicators['ema_50'] = TechnicalIndicators.ema(close, 50)
            if len(close) >= 200:
                indicators['ema_200'] = TechnicalIndicators.ema(close, 200)
            
            # SMAs
            indicators['sma_20'] = TechnicalIndicators.sma(close, 20)
            indicators['sma_50'] = TechnicalIndicators.sma(close, 50)
            if len(close) >= 200:
                indicators['sma_200'] = TechnicalIndicators.sma(close, 200)
            
            # Bollinger Bands
            bb_upper, bb_middle, bb_lower = TechnicalIndicators.bollinger_bands(close)
            indicators['bb_upper'] = bb_upper
            indicators['bb_middle'] = bb_middle
            indicators['bb_lower'] = bb_lower
            indicators['bb_width'] = (bb_upper - bb_lower) / bb_middle if bb_middle else 0
            
            # ATR
            indicators['atr_14'] = TechnicalIndicators.atr(high, low, close, 14)
            
            # ADX
            adx, plus_di, minus_di = TechnicalIndicators.adx(high, low, close)
            indicators['adx'] = adx
            indicators['plus_di'] = plus_di
            indicators['minus_di'] = minus_di
            
            # Stochastic
            stoch_k, stoch_d = TechnicalIndicators.stochastic(high, low, close)
            indicators['stoch_k'] = stoch_k
            indicators['stoch_d'] = stoch_d
            
            # CCI
            indicators['cci'] = TechnicalIndicators.cci(high, low, close)
            
            # MFI
            indicators['mfi'] = TechnicalIndicators.mfi(high, low, close, volume)
            
            # OBV
            indicators['obv'] = TechnicalIndicators.obv(close, volume)
            
            # VWAP
            indicators['vwap'] = TechnicalIndicators.vwap(high, low, close, volume)
            
            # Volume SMA
            indicators['volume_sma'] = TechnicalIndicators.sma(volume, 20)
            
            # Ichimoku
            tenkan, kijun = TechnicalIndicators.ichimoku(high, low)
            indicators['ichimoku_tenkan'] = tenkan
            indicators['ichimoku_kijun'] = kijun
            
            # Volatility
            indicators['volatility'] = TechnicalIndicators.volatility(close, 20)
            
            # Trend
            indicators['trend'] = TechnicalIndicators.detect_trend(close)
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # NEUE INDIKATOREN - 20+ weitere verschiedene!
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            # Fisher Transform
            indicators['fisher'] = ExtendedIndicators.fisher_transform(df)
            
            # Williams %R
            indicators['williams_r'] = ExtendedIndicators.williams_r(df)
            
            # KAMA (Kaufman's Adaptive MA)
            indicators['kama'] = ExtendedIndicators.kama(df)
            
            # Rate of Change
            indicators['roc'] = ExtendedIndicators.roc(df)
            
            # Momentum
            indicators['momentum'] = ExtendedIndicators.momentum(df)
            
            # DMI Plus und Minus
            indicators['dmi_plus'] = ExtendedIndicators.dmi_plus(df)
            indicators['dmi_minus'] = ExtendedIndicators.dmi_minus(df)
            
            # Supertrend
            indicators['supertrend'] = ExtendedIndicators.supertrend(df)
            
            # Linear Regression Slope
            indicators['linear_regression'] = ExtendedIndicators.linear_regression(df)
            
            # TRIX
            indicators['trix'] = ExtendedIndicators.trix(df)
            
            # Moving Median
            indicators['moving_median'] = ExtendedIndicators.moving_median(df)
            
            # Stochastic RSI
            stoch_rsi_k, stoch_rsi_d = ExtendedIndicators.stoch_rsi(df)
            indicators['stoch_rsi'] = stoch_rsi_k
            
            # Relative Vigor Index
            indicators['rvi'] = ExtendedIndicators.relative_vigor_index(df)
            
        except Exception as e:
            pass  # Einzelne Fehler ignorieren
        
        return indicators
    
    @staticmethod
    def sma(data: np.ndarray, period: int) -> float:
        """Simple Moving Average"""
        if len(data) < period:
            return data[-1] if len(data) > 0 else 0
        return np.mean(data[-period:])
    
    @staticmethod
    def ema(data: np.ndarray, period: int) -> float:
        """Exponential Moving Average"""
        if len(data) < period:
            return data[-1] if len(data) > 0 else 0
        
        multiplier = 2 / (period + 1)
        ema = data[0]
        for price in data[1:]:
            ema = (price * multiplier) + (ema * (1 - multiplier))
        return ema
    
    @staticmethod
    def rsi(close: np.ndarray, period: int = 14) -> float:
        """Relative Strength Index"""
        if len(close) < period + 1:
            return 50
        
        deltas = np.diff(close)
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        
        avg_gain = np.mean(gains[-period:])
        avg_loss = np.mean(losses[-period:])
        
        if avg_loss == 0:
            return 100
        
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))
    
    @staticmethod
    def macd(close: np.ndarray, fast: int = 12, slow: int = 26, signal: int = 9) -> tuple:
        """MACD - Moving Average Convergence Divergence"""
        if len(close) < slow:
            return 0, 0, 0
        
        ema_fast = TechnicalIndicators.ema(close, fast)
        ema_slow = TechnicalIndicators.ema(close, slow)
        macd_line = ema_fast - ema_slow
        
        # Signal line (vereinfacht)
        signal_line = macd_line * 0.9
        histogram = macd_line - signal_line
        
        return macd_line, signal_line, histogram
    
    @staticmethod
    def bollinger_bands(close: np.ndarray, period: int = 20, std_dev: float = 2.0) -> tuple:
        """Bollinger Bands"""
        if len(close) < period:
            return close[-1], close[-1], close[-1]
        
        sma = np.mean(close[-period:])
        std = np.std(close[-period:])
        
        upper = sma + (std_dev * std)
        lower = sma - (std_dev * std)
        
        return upper, sma, lower
    
    @staticmethod
    def atr(high: np.ndarray, low: np.ndarray, close: np.ndarray, period: int = 14) -> float:
        """Average True Range"""
        if len(close) < period + 1:
            return 0
        
        tr_list = []
        for i in range(1, len(close)):
            tr = max(
                high[i] - low[i],
                abs(high[i] - close[i-1]),
                abs(low[i] - close[i-1])
            )
            tr_list.append(tr)
        
        return np.mean(tr_list[-period:])
    
    @staticmethod
    def adx(high: np.ndarray, low: np.ndarray, close: np.ndarray, period: int = 14) -> tuple:
        """Average Directional Index"""
        if len(close) < period + 1:
            return 0, 0, 0
        
        plus_dm = []
        minus_dm = []
        tr_list = []
        
        for i in range(1, len(close)):
            up_move = high[i] - high[i-1]
            down_move = low[i-1] - low[i]
            
            plus_dm.append(up_move if up_move > down_move and up_move > 0 else 0)
            minus_dm.append(down_move if down_move > up_move and down_move > 0 else 0)
            
            tr = max(
                high[i] - low[i],
                abs(high[i] - close[i-1]),
                abs(low[i] - close[i-1])
            )
            tr_list.append(tr)
        
        atr_val = np.mean(tr_list[-period:])
        if atr_val == 0:
            return 0, 0, 0
        
        plus_di = 100 * np.mean(plus_dm[-period:]) / atr_val
        minus_di = 100 * np.mean(minus_dm[-period:]) / atr_val
        
        dx = 100 * abs(plus_di - minus_di) / (plus_di + minus_di) if (plus_di + minus_di) > 0 else 0
        adx = dx  # Vereinfacht
        
        return adx, plus_di, minus_di
    
    @staticmethod
    def stochastic(high: np.ndarray, low: np.ndarray, close: np.ndarray, 
                   k_period: int = 14, d_period: int = 3) -> tuple:
        """Stochastic Oscillator"""
        if len(close) < k_period:
            return 50, 50
        
        lowest_low = np.min(low[-k_period:])
        highest_high = np.max(high[-k_period:])
        
        if highest_high == lowest_low:
            return 50, 50
        
        k = 100 * (close[-1] - lowest_low) / (highest_high - lowest_low)
        d = k  # Vereinfacht
        
        return k, d
    
    @staticmethod
    def cci(high: np.ndarray, low: np.ndarray, close: np.ndarray, period: int = 20) -> float:
        """Commodity Channel Index"""
        if len(close) < period:
            return 0
        
        tp = (high[-period:] + low[-period:] + close[-period:]) / 3
        sma_tp = np.mean(tp)
        mad = np.mean(np.abs(tp - sma_tp))
        
        if mad == 0:
            return 0
        
        return (tp[-1] - sma_tp) / (0.015 * mad)
    
    @staticmethod
    def mfi(high: np.ndarray, low: np.ndarray, close: np.ndarray, 
            volume: np.ndarray, period: int = 14) -> float:
        """Money Flow Index"""
        if len(close) < period + 1:
            return 50
        
        tp = (high + low + close) / 3
        mf = tp * volume
        
        positive_mf = 0
        negative_mf = 0
        
        for i in range(-period, 0):
            if tp[i] > tp[i-1]:
                positive_mf += mf[i]
            else:
                negative_mf += mf[i]
        
        if negative_mf == 0:
            return 100
        
        mfr = positive_mf / negative_mf
        return 100 - (100 / (1 + mfr))
    
    @staticmethod
    def obv(close: np.ndarray, volume: np.ndarray) -> float:
        """On-Balance Volume"""
        if len(close) < 2:
            return 0
        
        obv = 0
        for i in range(1, len(close)):
            if close[i] > close[i-1]:
                obv += volume[i]
            elif close[i] < close[i-1]:
                obv -= volume[i]
        
        return obv
    
    @staticmethod
    def vwap(high: np.ndarray, low: np.ndarray, close: np.ndarray, volume: np.ndarray) -> float:
        """Volume Weighted Average Price"""
        if len(close) == 0 or np.sum(volume) == 0:
            return close[-1] if len(close) > 0 else 0
        
        tp = (high + low + close) / 3
        return np.sum(tp * volume) / np.sum(volume)
    
    @staticmethod
    def ichimoku(high: np.ndarray, low: np.ndarray, 
                 tenkan_period: int = 9, kijun_period: int = 26) -> tuple:
        """Ichimoku Cloud - Tenkan & Kijun"""
        if len(high) < kijun_period:
            return high[-1], high[-1]
        
        tenkan = (np.max(high[-tenkan_period:]) + np.min(low[-tenkan_period:])) / 2
        kijun = (np.max(high[-kijun_period:]) + np.min(low[-kijun_period:])) / 2
        
        return tenkan, kijun
    
    @staticmethod
    def volatility(close: np.ndarray, period: int = 20) -> float:
        """Historische Volatilit√§t"""
        if len(close) < period:
            return 0
        
        returns = np.diff(np.log(close[-period-1:]))
        return np.std(returns) * np.sqrt(period)
    
    @staticmethod
    def detect_trend(close: np.ndarray, short: int = 10, long: int = 30) -> str:
        """Erkenne Trend: 'up', 'down', 'sideways'"""
        if len(close) < long:
            return 'sideways'
        
        ema_short = TechnicalIndicators.ema(close, short)
        ema_long = TechnicalIndicators.ema(close, long)
        
        diff_percent = (ema_short - ema_long) / ema_long * 100
        
        if diff_percent > 0.5:
            return 'up'
        elif diff_percent < -0.5:
            return 'down'
        return 'sideways'


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ORDER BOOK ANALYZER
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class OrderBookAnalyzer:
    """
    Analyse des Order Books f√ºr Entry-Signale
    Feature #12: Order Book Analysis
    """
    
    def __init__(self, config: Config, logger: Logger):
        self.config = config
        self.logger = logger
    
    def analyze(self, orderbook: dict, current_price: float) -> dict:
        """Vollst√§ndige Order Book Analyse"""
        if not orderbook or not orderbook.get('bids') or not orderbook.get('asks'):
            return self._empty_analysis()
        
        bids = orderbook['bids']
        asks = orderbook['asks']
        
        # Volumen-Analyse
        bid_volume = sum(b[1] for b in bids)
        ask_volume = sum(a[1] for a in asks)
        total_volume = bid_volume + ask_volume
        
        # Imbalance
        imbalance = bid_volume / ask_volume if ask_volume > 0 else 1
        
        # Spread
        best_bid = bids[0][0] if bids else current_price
        best_ask = asks[0][0] if asks else current_price
        spread = (best_ask - best_bid) / current_price * 100
        
        # Whale Detection
        whale_threshold = self.config.WHALE_ORDER_THRESHOLD / current_price
        whale_bids = sum(1 for b in bids if b[1] >= whale_threshold)
        whale_asks = sum(1 for a in asks if a[1] >= whale_threshold)
        
        # Support/Resistance Levels
        support_levels = self._find_support_resistance(bids, 'support')
        resistance_levels = self._find_support_resistance(asks, 'resistance')
        
        # Buy/Sell Pressure Score (-100 bis +100)
        pressure_score = self._calculate_pressure_score(
            bid_volume, ask_volume, whale_bids, whale_asks, imbalance
        )
        
        # Signal
        signal = self._generate_signal(imbalance, pressure_score, spread)
        
        return {
            'bid_volume': bid_volume,
            'ask_volume': ask_volume,
            'imbalance': imbalance,
            'spread': spread,
            'whale_bids': whale_bids,
            'whale_asks': whale_asks,
            'pressure_score': pressure_score,
            'support_levels': support_levels,
            'resistance_levels': resistance_levels,
            'signal': signal,
            'signal_strength': abs(pressure_score) / 100,
        }
    
    def _find_support_resistance(self, orders: list, order_type: str, top_n: int = 3) -> list:
        """Finde wichtige Support/Resistance Level"""
        if not orders:
            return []
        
        # Gruppiere nach Preisn√§he und summiere Volumen
        levels = {}
        for price, volume in orders:
            rounded_price = round(price, 2)
            levels[rounded_price] = levels.get(rounded_price, 0) + volume
        
        # Sortiere nach Volumen
        sorted_levels = sorted(levels.items(), key=lambda x: x[1], reverse=True)
        return [{'price': p, 'volume': v} for p, v in sorted_levels[:top_n]]
    
    def _calculate_pressure_score(self, bid_vol: float, ask_vol: float,
                                  whale_bids: int, whale_asks: int,
                                  imbalance: float) -> float:
        """Berechne Buy/Sell Pressure Score"""
        # Volume-basiert
        vol_score = (bid_vol - ask_vol) / (bid_vol + ask_vol) * 50 if (bid_vol + ask_vol) > 0 else 0
        
        # Whale-basiert
        whale_score = (whale_bids - whale_asks) * 10
        
        # Imbalance-basiert
        imb_score = (imbalance - 1) * 20
        
        total = vol_score + whale_score + imb_score
        return max(-100, min(100, total))
    
    def _generate_signal(self, imbalance: float, pressure: float, spread: float) -> str:
        """Generiere Signal basierend auf Order Book"""
        if spread > 0.5:  # Zu gro√üer Spread
            return 'neutral'
        
        if imbalance > self.config.ORDERBOOK_IMBALANCE_THRESHOLD and pressure > 30:
            return 'strong_buy'
        elif imbalance > 1.2 and pressure > 15:
            return 'buy'
        elif imbalance < 1/self.config.ORDERBOOK_IMBALANCE_THRESHOLD and pressure < -30:
            return 'strong_sell'
        elif imbalance < 0.8 and pressure < -15:
            return 'sell'
        
        return 'neutral'
    
    def _empty_analysis(self) -> dict:
        return {
            'bid_volume': 0, 'ask_volume': 0, 'imbalance': 1,
            'spread': 0, 'whale_bids': 0, 'whale_asks': 0,
            'pressure_score': 0, 'support_levels': [], 'resistance_levels': [],
            'signal': 'neutral', 'signal_strength': 0,
        }


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# STRATEGY RANKING SYSTEM
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class StrategyRankingSystem:
    """
    Elo-basiertes Ranking f√ºr alle Strategien
    Bessere Strategien d√ºrfen √∂fter traden
    + AUTO-PAUSE bei 4 Verlusten hintereinander
    """
    
    def __init__(self, config: Config, logger: Logger, state_manager: StateManager):
        self.config = config
        self.logger = logger
        self.state = state_manager
        self.rankings = self._load_rankings()
        self.daily_trades = {}
        
        # NEU: Losing Streak Tracking
        self.losing_streaks = {}  # strategy_name -> consecutive_losses
        self.paused_until = {}  # strategy_name -> datetime when pause ends
    
    def _load_rankings(self) -> dict:
        """Lade oder initialisiere Rankings"""
        saved = self.state.get('strategy_rankings', {})
        if saved:
            return saved
        return {}
    
    def register_strategy(self, name: str):
        """Registriere neue Strategie"""
        if name not in self.rankings:
            self.rankings[name] = {
                'elo': self.config.INITIAL_ELO,
                'wins': 0,
                'losses': 0,
                'total_pnl': 0,
                'trades': 0,
            }
            self.losing_streaks[name] = 0
            self._save_rankings()
    
    def is_strategy_paused(self, strategy_name: str) -> bool:
        """Pr√ºfe ob Strategie pausiert ist (wegen Losing Streak)"""
        if strategy_name not in self.paused_until:
            return False
        
        pause_end = self.paused_until[strategy_name]
        if datetime.now() < pause_end:
            remaining = (pause_end - datetime.now()).total_seconds() / 60
            self.logger.log(
                f"‚è∏Ô∏è Strategy {strategy_name} is PAUSED for {remaining:.0f} more minutes "
                f"(4 consecutive losses)",
                "WARNING"
            )
            return True
        else:
            # Pause ist vorbei
            del self.paused_until[strategy_name]
            self.losing_streaks[strategy_name] = 0  # Reset Streak
            self.logger.log(
                f"‚ñ∂Ô∏è Strategy {strategy_name} UNPAUSED - ready to trade again!",
                "INFO"
            )
            return False
    
    def record_trade_result(self, strategy_name: str, pnl_percent: float, pnl_usd: float):
        """Update Elo nach Trade + Losing Streak Check"""
        if strategy_name not in self.rankings:
            self.register_strategy(strategy_name)
        
        stats = self.rankings[strategy_name]
        stats['trades'] += 1
        stats['total_pnl'] += pnl_usd
        
        # Elo Update
        is_win = pnl_percent > 0
        
        if is_win:
            stats['wins'] += 1
            # Bonus basierend auf Profit-H√∂he
            elo_gain = self.config.ELO_K_FACTOR * (0.5 + min(pnl_percent / 10, 0.5))
            stats['elo'] += elo_gain
            
            # Reset Losing Streak bei Gewinn
            self.losing_streaks[strategy_name] = 0
            self.logger.log(
                f"‚úÖ {strategy_name}: WIN ({pnl_percent:+.2f}%) - Losing streak reset",
                "INFO"
            )
        else:
            stats['losses'] += 1
            # Strafe basierend auf Verlust-H√∂he
            elo_loss = self.config.ELO_K_FACTOR * (0.5 + min(abs(pnl_percent) / 10, 0.5))
            stats['elo'] -= elo_loss
            
            # Erh√∂he Losing Streak
            current_streak = self.losing_streaks.get(strategy_name, 0) + 1
            self.losing_streaks[strategy_name] = current_streak
            
            self.logger.log(
                f"‚ùå {strategy_name}: LOSS ({pnl_percent:+.2f}%) - "
                f"Losing streak: {current_streak}/4",
                "WARNING"
            )
            
            # Bei 4 Verlusten hintereinander -> 1h Pause!
            if current_streak >= 4:
                pause_until = datetime.now() + timedelta(hours=1)
                self.paused_until[strategy_name] = pause_until
                
                self.logger.log(
                    f"‚è∏Ô∏è‚è∏Ô∏è‚è∏Ô∏è STRATEGY PAUSED! ‚è∏Ô∏è‚è∏Ô∏è‚è∏Ô∏è\n"
                    f"Strategy: {strategy_name}\n"
                    f"Reason: 4 CONSECUTIVE LOSSES\n"
                    f"Paused until: {pause_until.strftime('%Y-%m-%d %H:%M:%S')}\n"
                    f"Duration: 60 minutes",
                    "CRITICAL"
                )
                
                # Reset Streak (wird auch beim Unpause gemacht)
                self.losing_streaks[strategy_name] = 0
        
        # Elo Minimum
        stats['elo'] = max(stats['elo'], 800)
        
        self._save_rankings()
        self.logger.log(
            f"üìä Strategy {strategy_name} updated: Elo={stats['elo']:.0f}, "
            f"W/L={stats['wins']}/{stats['losses']}, TotalPnL=${stats['total_pnl']:.2f}",
            "INFO"
        )
    
    def get_ranking(self) -> list:
        """Hole sortierte Rangliste"""
        sorted_strategies = sorted(
            self.rankings.items(),
            key=lambda x: x[1]['elo'],
            reverse=True
        )
        return [(i+1, name, data) for i, (name, data) in enumerate(sorted_strategies)]
    
    def can_trade(self, strategy_name: str) -> bool:
        """Pr√ºfe ob Strategie heute noch traden darf + ob nicht pausiert"""
        # NEUE PR√úFUNG: Ist Strategie pausiert?
        if self.is_strategy_paused(strategy_name):
            return False
        
        today = datetime.now().strftime("%Y-%m-%d")
        
        # Reset t√§glich
        if self.state.get('last_trade_date') != today:
            self.daily_trades = {}
            self.state.set('last_trade_date', today)
        
        # Hole Rang
        ranking = self.get_ranking()
        rank = next((r[0] for r in ranking if r[1] == strategy_name), 99)
        
        # Erlaubte Trades pro Tag
        allowed = self.config.TRADES_PER_DAY_BY_RANK.get(
            rank, self.config.DEFAULT_TRADES_PER_DAY
        )
        
        # Aktuelle Trades heute
        current = self.daily_trades.get(strategy_name, 0)
        
        return current < allowed
    
    def record_trade_attempt(self, strategy_name: str):
        """Z√§hle Trade-Versuch"""
        self.daily_trades[strategy_name] = self.daily_trades.get(strategy_name, 0) + 1
    
    def get_strategy_rank(self, strategy_name: str) -> int:
        """Hole Rang einer Strategie"""
        ranking = self.get_ranking()
        return next((r[0] for r in ranking if r[1] == strategy_name), 99)
    
    def _save_rankings(self):
        """Speichere Rankings"""
        self.state.set('strategy_rankings', self.rankings)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# STRATEGY OPTIMIZER (Feature #20)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class StrategyOptimizer:
    """
    Automatische Parameter-Optimierung f√ºr Strategien
    Feature #20: Strategy Optimizer
    """
    
    def __init__(self, config: Config, logger: Logger, journal: TradeJournal):
        self.config = config
        self.logger = logger
        self.journal = journal
        self.optimized_params = {}
        self.last_optimization = {}
    
    def should_optimize(self, strategy_name: str) -> bool:
        """Pr√ºfe ob Optimierung n√∂tig"""
        if not self.config.OPTIMIZER_ENABLED:
            return False
        
        # Mindest-Trades
        stats = self.journal.get_strategy_stats(strategy_name)
        if stats['trades'] < self.config.OPTIMIZER_MIN_TRADES:
            return False
        
        # Zeit seit letzter Optimierung
        last = self.last_optimization.get(strategy_name)
        if last:
            hours_since = (datetime.now() - last).total_seconds() / 3600
            if hours_since < self.config.OPTIMIZER_INTERVAL_HOURS:
                return False
        
        return True
    
    def optimize(self, strategy_name: str, current_params: dict) -> dict:
        """
        Optimiere Parameter basierend auf historischer Performance
        Verwendet Gradient-Free Optimization (Simple Hill Climbing)
        """
        self.logger.log(f"Starting optimization for {strategy_name}", "INFO")
        
        try:
            # Lade historische Trades
            df = pd.read_csv(self.config.TRADE_CSV)
            df_strat = df[df['strategy'] == strategy_name]
            
            if len(df_strat) < self.config.OPTIMIZER_MIN_TRADES:
                return current_params
            
            # Analysiere erfolgreiche vs. erfolglose Trades
            winners = df_strat[df_strat['net_pnl_percent'] > 0]
            losers = df_strat[df_strat['net_pnl_percent'] <= 0]
            
            optimized = current_params.copy()
            
            # F√ºr jeden optimierbaren Parameter
            for param, (min_val, max_val) in self.config.OPTIMIZER_PARAM_RANGES.items():
                if param not in current_params:
                    continue
                
                current_val = current_params[param]
                
                # Analysiere Korrelation mit Erfolg
                if param.startswith('rsi_'):
                    # RSI-Parameter aus Indikator-Spalten analysieren
                    winner_avg = winners['ind_rsi_14'].mean() if len(winners) > 0 else 50
                    loser_avg = losers['ind_rsi_14'].mean() if len(losers) > 0 else 50
                    
                    if param == 'rsi_oversold':
                        # Wenn Winner bei niedrigerem RSI, senke Threshold
                        if winner_avg < loser_avg:
                            optimized[param] = max(min_val, current_val - 2)
                        else:
                            optimized[param] = min(max_val, current_val + 2)
                    elif param == 'rsi_overbought':
                        if winner_avg > loser_avg:
                            optimized[param] = min(max_val, current_val + 2)
                        else:
                            optimized[param] = max(min_val, current_val - 2)
                
                # √Ñhnliche Logik f√ºr andere Parameter...
            
            self.optimized_params[strategy_name] = optimized
            self.last_optimization[strategy_name] = datetime.now()
            
            self.logger.log(
                f"Optimization complete for {strategy_name}: {optimized}",
                "INFO"
            )
            
            return optimized
            
        except Exception as e:
            self.logger.log(f"Optimization failed: {e}", "ERROR", True)
            return current_params
    
    def get_optimized_params(self, strategy_name: str, default_params: dict) -> dict:
        """Hole optimierte Parameter oder Default"""
        return self.optimized_params.get(strategy_name, default_params)


print("=" * 80)
print("PROMETHEUS BOT - Part 1 loaded successfully!")
print("=" * 80)
print("\nPart 1 enth√§lt:")
print("  ‚úì Config (Alle Einstellungen)")
print("  ‚úì Logger (Thread-safe, vollst√§ndige Fehlermeldungen)")
print("  ‚úì StateManager (Persistenter State)")
print("  ‚úì TradeJournal (CSV mit 50+ Spalten)")
print("  ‚úì ExchangeConnector (KuCoin mit korrektem Leverage & Position Sizing)")
print("  ‚úì TechnicalIndicators (20+ Indikatoren)")
print("  ‚úì OrderBookAnalyzer (Feature #12)")
print("  ‚úì StrategyRankingSystem (Elo-basiert)")
print("  ‚úì StrategyOptimizer (Feature #20)")
print("\nSchreibe 'weiter mit Teil 2' f√ºr den Rest des Codes!")
print("=" * 80)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PROMETHEUS ULTRA TRADING BOT - TEIL 2
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# GEHEIME STRATEGIEN - NUR F√úR DIE 0.0001%
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 5 NEUE GENIALE FEATURES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class LiquidationCascadeDetector:
    """
    FEATURE 1: Liquidation Cascade Detector
    Erkennt bevorstehende Liquidationskaskaden BEVOR sie passieren.
    Nutzt Open Interest + Price Level Clustering.
    """
    
    def __init__(self, config: Config, logger: Logger, exchange: 'ExchangeConnector'):
        self.config = config
        self.logger = logger
        self.exchange = exchange
        self.liquidation_zones = {}
    
    def analyze(self, symbol: str, current_price: float, df: pd.DataFrame) -> dict:
        """Analysiere potentielle Liquidationszonen"""
        try:
            # Hole historische Preislevel wo viele Positionen er√∂ffnet wurden
            # (Approximation durch Volumen-Peaks)
            high_volume_levels = self._find_volume_clusters(df, current_price)
            
            # Berechne wo Liquidationen wahrscheinlich sind
            # Long Liquidations bei Price Drop, Short Liquidations bei Price Rise
            long_liq_zones = []
            short_liq_zones = []
            
            for level in high_volume_levels:
                # Annahme: 20x Leverage = Liquidation bei ~4.5% gegen Position
                long_liq_price = level['price'] * 0.955  # Longs werden hier liquidiert
                short_liq_price = level['price'] * 1.045  # Shorts werden hier liquidiert
                
                long_liq_zones.append({
                    'price': long_liq_price,
                    'estimated_volume': level['volume'] * 0.3,  # ~30% sind gehebelt
                    'distance_percent': (current_price - long_liq_price) / current_price * 100
                })
                
                short_liq_zones.append({
                    'price': short_liq_price,
                    'estimated_volume': level['volume'] * 0.3,
                    'distance_percent': (short_liq_price - current_price) / current_price * 100
                })
            
            # Finde n√§chste Liquidationszone
            nearest_long_liq = min(long_liq_zones, key=lambda x: abs(x['distance_percent'])) if long_liq_zones else None
            nearest_short_liq = min(short_liq_zones, key=lambda x: abs(x['distance_percent'])) if short_liq_zones else None
            
            # Cascade Wahrscheinlichkeit
            cascade_probability = self._calculate_cascade_probability(
                current_price, nearest_long_liq, nearest_short_liq, df
            )
            
            # Signal generieren
            signal = 'neutral'
            if cascade_probability > 0.7:
                # Hohe Wahrscheinlichkeit f√ºr Kaskade
                if nearest_long_liq and nearest_long_liq['distance_percent'] < nearest_short_liq['distance_percent']:
                    signal = 'short_cascade_incoming'  # Shorten, da Longs liquidiert werden
                else:
                    signal = 'long_cascade_incoming'  # Longen, da Shorts liquidiert werden
            
            return {
                'long_liquidation_zones': long_liq_zones[:3],
                'short_liquidation_zones': short_liq_zones[:3],
                'nearest_long_liq': nearest_long_liq,
                'nearest_short_liq': nearest_short_liq,
                'cascade_probability': cascade_probability,
                'signal': signal,
            }
            
        except Exception as e:
            self.logger.log(f"Liquidation analysis error: {e}", "ERROR")
            return {'cascade_probability': 0, 'signal': 'neutral'}
    
    def _find_volume_clusters(self, df: pd.DataFrame, current_price: float) -> list:
        """Finde Preisniveaus mit hohem Volumen"""
        if len(df) < 20:
            return []
        
        # Gruppiere nach Preisbereich
        price_range = current_price * 0.1  # 10% Range
        bins = 20
        
        df['price_bin'] = pd.cut(df['close'], bins=bins)
        volume_by_price = df.groupby('price_bin')['volume'].sum()
        
        # Top Volume Levels
        clusters = []
        for price_bin, vol in volume_by_price.nlargest(5).items():
            mid_price = (price_bin.left + price_bin.right) / 2
            clusters.append({'price': mid_price, 'volume': vol})
        
        return clusters
    
    def _calculate_cascade_probability(self, current_price: float, 
                                       nearest_long: dict, nearest_short: dict,
                                       df: pd.DataFrame) -> float:
        """Berechne Wahrscheinlichkeit einer Liquidationskaskade"""
        if not nearest_long or not nearest_short:
            return 0.0
        
        # Faktoren f√ºr Kaskaden-Wahrscheinlichkeit
        factors = []
        
        # 1. N√§he zur Liquidationszone
        min_distance = min(abs(nearest_long['distance_percent']), 
                          abs(nearest_short['distance_percent']))
        if min_distance < 2:
            factors.append(0.8)
        elif min_distance < 5:
            factors.append(0.5)
        else:
            factors.append(0.2)
        
        # 2. Volatilit√§t
        volatility = df['close'].pct_change().std() * 100
        if volatility > 2:
            factors.append(0.7)
        elif volatility > 1:
            factors.append(0.5)
        else:
            factors.append(0.3)
        
        # 3. Volumen-Trend
        recent_vol = df['volume'].tail(5).mean()
        older_vol = df['volume'].tail(20).mean()
        if recent_vol > older_vol * 1.5:
            factors.append(0.6)
        else:
            factors.append(0.3)
        
        return np.mean(factors)


class SmartMoneyFlowTracker:
    """
    FEATURE 2: Smart Money Flow Tracker
    Trackt das "Smart Money" - institutionelle K√§ufer/Verk√§ufer.
    Basiert auf gro√üen Orders und Timing-Analyse.
    """
    
    def __init__(self, config: Config, logger: Logger):
        self.config = config
        self.logger = logger
        self.flow_history = deque(maxlen=100)
    
    def analyze(self, df: pd.DataFrame, orderbook: dict, current_price: float) -> dict:
        """Analysiere Smart Money Flow"""
        try:
            # 1. Chaikin Money Flow (CMF)
            cmf = self._calculate_cmf(df)
            
            # 2. Accumulation/Distribution Line
            ad_line = self._calculate_ad_line(df)
            
            # 3. Gro√üe Order Detection im Orderbook
            large_order_bias = self._detect_large_orders(orderbook, current_price)
            
            # 4. Time-Weighted Analysis (Smart Money tradet oft zu bestimmten Zeiten)
            time_bias = self._time_analysis()
            
            # 5. Volume Delta
            volume_delta = self._calculate_volume_delta(df)
            
            # Kombinierter Score
            smart_money_score = (
                cmf * 0.25 +
                ad_line * 0.25 +
                large_order_bias * 0.2 +
                time_bias * 0.15 +
                volume_delta * 0.15
            )
            
            # Normalisiere auf -100 bis +100
            smart_money_score = max(-100, min(100, smart_money_score * 100))
            
            # Signal
            if smart_money_score > 40:
                signal = 'smart_money_buying'
            elif smart_money_score < -40:
                signal = 'smart_money_selling'
            else:
                signal = 'neutral'
            
            self.flow_history.append({
                'timestamp': datetime.now(),
                'score': smart_money_score,
                'signal': signal
            })
            
            return {
                'cmf': cmf,
                'ad_line_direction': 'up' if ad_line > 0 else 'down',
                'large_order_bias': large_order_bias,
                'volume_delta': volume_delta,
                'smart_money_score': smart_money_score,
                'signal': signal,
                'confidence': abs(smart_money_score) / 100,
            }
            
        except Exception as e:
            self.logger.log(f"Smart Money analysis error: {e}", "ERROR")
            return {'smart_money_score': 0, 'signal': 'neutral', 'confidence': 0}
    
    def _calculate_cmf(self, df: pd.DataFrame, period: int = 20) -> float:
        """Chaikin Money Flow"""
        if len(df) < period:
            return 0
        
        high = df['high'].values
        low = df['low'].values
        close = df['close'].values
        volume = df['volume'].values
        
        # Money Flow Multiplier
        mfm = np.where(
            high != low,
            ((close - low) - (high - close)) / (high - low),
            0
        )
        
        # Money Flow Volume
        mfv = mfm * volume
        
        # CMF
        cmf = np.sum(mfv[-period:]) / np.sum(volume[-period:]) if np.sum(volume[-period:]) > 0 else 0
        return cmf
    
    def _calculate_ad_line(self, df: pd.DataFrame) -> float:
        """Accumulation/Distribution Line Direction"""
        if len(df) < 10:
            return 0
        
        ad = 0
        for i in range(1, len(df)):
            clv = ((df['close'].iloc[i] - df['low'].iloc[i]) - 
                   (df['high'].iloc[i] - df['close'].iloc[i]))
            
            if df['high'].iloc[i] != df['low'].iloc[i]:
                clv /= (df['high'].iloc[i] - df['low'].iloc[i])
            
            ad += clv * df['volume'].iloc[i]
        
        # Trend der letzten 10 Perioden
        return 1 if ad > 0 else -1
    
    def _detect_large_orders(self, orderbook: dict, price: float) -> float:
        """Erkenne gro√üe Orders (Smart Money)"""
        if not orderbook.get('bids') or not orderbook.get('asks'):
            return 0
        
        threshold = self.config.WHALE_ORDER_THRESHOLD / price
        
        large_bids = sum(b[1] for b in orderbook['bids'] if b[1] > threshold)
        large_asks = sum(a[1] for a in orderbook['asks'] if a[1] > threshold)
        
        total = large_bids + large_asks
        if total == 0:
            return 0
        
        return (large_bids - large_asks) / total
    
    def _time_analysis(self) -> float:
        """Analysiere aktuelle Zeit f√ºr Smart Money Aktivit√§t"""
        hour = datetime.now().hour
        
        # Smart Money ist oft aktiv w√§hrend:
        # - US Market Open (13:30-16:00 UTC)
        # - Asian Session Start (00:00-02:00 UTC)
        # - London Open (07:00-09:00 UTC)
        
        if 13 <= hour <= 16:  # US Session
            return 0.3
        elif 0 <= hour <= 2:   # Asian Session
            return 0.2
        elif 7 <= hour <= 9:   # London Session
            return 0.25
        else:
            return 0
    
    def _calculate_volume_delta(self, df: pd.DataFrame) -> float:
        """Volume Delta - Differenz zwischen Kauf- und Verkaufsvolumen"""
        if len(df) < 10:
            return 0
        
        # Approximation: Gr√ºne Kerzen = Kaufvolumen, Rote = Verkaufsvolumen
        buy_volume = 0
        sell_volume = 0
        
        for i in range(-10, 0):
            if df['close'].iloc[i] > df['open'].iloc[i]:
                buy_volume += df['volume'].iloc[i]
            else:
                sell_volume += df['volume'].iloc[i]
        
        total = buy_volume + sell_volume
        if total == 0:
            return 0
        
        return (buy_volume - sell_volume) / total


class MarketManipulationShield:
    """
    FEATURE 3: Market Manipulation Shield
    Erkennt und sch√ºtzt vor typischen Manipulationstaktiken:
    - Spoofing
    - Layering
    - Wash Trading
    - Stop Hunting
    """
    
    def __init__(self, config: Config, logger: Logger):
        self.config = config
        self.logger = logger
        self.orderbook_history = deque(maxlen=50)
        self.manipulation_alerts = deque(maxlen=100)
    
    def analyze(self, orderbook: dict, df: pd.DataFrame, current_price: float) -> dict:
        """Analysiere auf Manipulation"""
        try:
            # Speichere Orderbook f√ºr Vergleich
            self.orderbook_history.append({
                'timestamp': datetime.now(),
                'bids': orderbook.get('bids', [])[:10],
                'asks': orderbook.get('asks', [])[:10],
                'price': current_price
            })
            
            manipulation_score = 0
            detected_tactics = []
            
            # 1. Spoofing Detection
            spoofing = self._detect_spoofing()
            if spoofing > 0.5:
                manipulation_score += 30
                detected_tactics.append('spoofing')
            
            # 2. Stop Hunt Detection
            stop_hunt = self._detect_stop_hunt(df, current_price)
            if stop_hunt['detected']:
                manipulation_score += 40
                detected_tactics.append(f"stop_hunt_{stop_hunt['direction']}")
            
            # 3. Wash Trading Detection
            wash_trading = self._detect_wash_trading(df)
            if wash_trading > 0.6:
                manipulation_score += 20
                detected_tactics.append('wash_trading')
            
            # 4. Layering Detection
            layering = self._detect_layering(orderbook)
            if layering > 0.5:
                manipulation_score += 25
                detected_tactics.append('layering')
            
            # Safety Signal
            is_safe = manipulation_score < 30
            
            result = {
                'manipulation_score': manipulation_score,
                'is_safe': is_safe,
                'detected_tactics': detected_tactics,
                'spoofing_probability': spoofing,
                'stop_hunt': stop_hunt,
                'wash_trading_probability': wash_trading,
                'layering_probability': layering,
                'recommendation': 'trade' if is_safe else 'avoid',
            }
            
            if not is_safe:
                self.manipulation_alerts.append({
                    'timestamp': datetime.now(),
                    'tactics': detected_tactics,
                    'score': manipulation_score
                })
                self.logger.log(
                    f"‚ö†Ô∏è MANIPULATION DETECTED: {detected_tactics} (Score: {manipulation_score})",
                    "WARNING"
                )
            
            return result
            
        except Exception as e:
            self.logger.log(f"Manipulation analysis error: {e}", "ERROR")
            return {'is_safe': True, 'manipulation_score': 0}
    
    def _detect_spoofing(self) -> float:
        """
        Spoofing: Gro√üe Orders die schnell verschwinden
        """
        if len(self.orderbook_history) < 3:
            return 0
        
        disappearing_orders = 0
        total_checks = 0
        
        for i in range(1, min(len(self.orderbook_history), 5)):
            prev = self.orderbook_history[-i-1]
            curr = self.orderbook_history[-i]
            
            # Vergleiche gro√üe Orders
            prev_large_bids = [b for b in prev['bids'] if b[1] > 1000]
            curr_large_bids = [b for b in curr['bids'] if b[1] > 1000]
            
            prev_large_asks = [a for a in prev['asks'] if a[1] > 1000]
            curr_large_asks = [a for a in curr['asks'] if a[1] > 1000]
            
            # Z√§hle verschwundene gro√üe Orders
            for order in prev_large_bids:
                if not any(abs(o[0] - order[0]) < 0.01 for o in curr_large_bids):
                    disappearing_orders += 1
                total_checks += 1
            
            for order in prev_large_asks:
                if not any(abs(o[0] - order[0]) < 0.01 for o in curr_large_asks):
                    disappearing_orders += 1
                total_checks += 1
        
        return disappearing_orders / total_checks if total_checks > 0 else 0
    
    def _detect_stop_hunt(self, df: pd.DataFrame, current_price: float) -> dict:
        """
        Stop Hunt: Schnelle Bewegung durch Support/Resistance mit sofortiger Umkehr
        """
        if len(df) < 20:
            return {'detected': False}
        
        # Finde lokale Hochs und Tiefs (potentielle Stop-Level)
        recent = df.tail(20)
        
        local_high = recent['high'].max()
        local_low = recent['low'].min()
        
        # Pr√ºfe ob Preis kurz √ºber High/unter Low war und zur√ºckkam
        last_5 = df.tail(5)
        
        # Upside Stop Hunt
        if last_5['high'].max() > local_high * 1.002:  # 0.2% √ºber High
            if current_price < local_high:  # Aber jetzt wieder drunter
                return {
                    'detected': True,
                    'direction': 'upside',
                    'hunt_level': local_high,
                    'recommendation': 'short'
                }
        
        # Downside Stop Hunt
        if last_5['low'].min() < local_low * 0.998:  # 0.2% unter Low
            if current_price > local_low:  # Aber jetzt wieder dr√ºber
                return {
                    'detected': True,
                    'direction': 'downside',
                    'hunt_level': local_low,
                    'recommendation': 'long'
                }
        
        return {'detected': False}
    
    def _detect_wash_trading(self, df: pd.DataFrame) -> float:
        """
        Wash Trading: Unnat√ºrlich konstantes Volumen oder repetitive Patterns
        """
        if len(df) < 30:
            return 0
        
        volumes = df['volume'].tail(30).values
        
        # Pr√ºfe auf unnat√ºrliche Konstanz
        vol_std = np.std(volumes)
        vol_mean = np.mean(volumes)
        
        # Coefficient of Variation sollte nat√ºrlich > 0.3 sein
        cv = vol_std / vol_mean if vol_mean > 0 else 0
        
        if cv < 0.1:  # Zu konstant = verd√§chtig
            return 0.8
        elif cv < 0.2:
            return 0.5
        
        return 0.1
    
    def _detect_layering(self, orderbook: dict) -> float:
        """
        Layering: Viele Orders auf einer Seite die alle √§hnlich gro√ü sind
        """
        if not orderbook.get('bids') or not orderbook.get('asks'):
            return 0
        
        def check_layering(orders):
            if len(orders) < 5:
                return 0
            
            sizes = [o[1] for o in orders[:10]]
            
            # Pr√ºfe ob Gr√∂√üen verd√§chtig √§hnlich sind
            if len(sizes) < 3:
                return 0
            
            size_std = np.std(sizes)
            size_mean = np.mean(sizes)
            cv = size_std / size_mean if size_mean > 0 else 1
            
            # Wenn alle Orders fast gleich gro√ü = verd√§chtig
            if cv < 0.15:
                return 0.7
            elif cv < 0.25:
                return 0.4
            
            return 0.1
        
        bid_layering = check_layering(orderbook['bids'])
        ask_layering = check_layering(orderbook['asks'])
        
        return max(bid_layering, ask_layering)


class InstitutionalFootprintAnalyzer:
    """
    FEATURE 4: Institutional Footprint Analyzer
    Erkennt institutionelle Aktivit√§t durch:
    - Block Trade Detection
    - Iceberg Order Detection
    - Time-Based Pattern Analysis
    """
    
    def __init__(self, config: Config, logger: Logger):
        self.config = config
        self.logger = logger
        self.trade_history = deque(maxlen=500)
    
    def analyze(self, df: pd.DataFrame, orderbook: dict, current_price: float) -> dict:
        """Analysiere institutionelle Footprints"""
        try:
            # 1. Block Trade Detection
            block_trades = self._detect_block_trades(df, current_price)
            
            # 2. Iceberg Order Detection
            iceberg_detection = self._detect_iceberg_orders(orderbook)
            
            # 3. TWAP/VWAP Execution Detection
            algo_execution = self._detect_algo_execution(df)
            
            # 4. Session-Based Analysis
            session_activity = self._analyze_session_activity(df)
            
            # Institutional Activity Score
            inst_score = (
                block_trades['score'] * 0.3 +
                iceberg_detection['probability'] * 0.25 +
                algo_execution['probability'] * 0.25 +
                session_activity['institutional_activity'] * 0.2
            )
            
            # Richtung des institutionellen Flows
            inst_direction = 'neutral'
            if block_trades['direction'] == 'buy' and iceberg_detection['side'] == 'bid':
                inst_direction = 'accumulating'
            elif block_trades['direction'] == 'sell' and iceberg_detection['side'] == 'ask':
                inst_direction = 'distributing'
            
            return {
                'institutional_score': inst_score,
                'direction': inst_direction,
                'block_trades': block_trades,
                'iceberg_orders': iceberg_detection,
                'algo_execution': algo_execution,
                'session_activity': session_activity,
                'signal': 'long' if inst_direction == 'accumulating' else 
                         ('short' if inst_direction == 'distributing' else 'neutral'),
                'confidence': inst_score,
            }
            
        except Exception as e:
            self.logger.log(f"Institutional analysis error: {e}", "ERROR")
            return {'institutional_score': 0, 'signal': 'neutral'}
    
    def _detect_block_trades(self, df: pd.DataFrame, current_price: float) -> dict:
        """Erkenne Block Trades (gro√üe einzelne Trades)"""
        if len(df) < 20:
            return {'detected': False, 'score': 0, 'direction': 'neutral'}
        
        # Block Trade = Volumen > 3x Durchschnitt
        avg_volume = df['volume'].tail(50).mean()
        recent_volumes = df['volume'].tail(5).values
        recent_closes = df['close'].tail(5).values
        recent_opens = df['open'].tail(5).values
        
        block_trades = []
        for i, vol in enumerate(recent_volumes):
            if vol > avg_volume * 3:
                direction = 'buy' if recent_closes[i] > recent_opens[i] else 'sell'
                block_trades.append({
                    'volume': vol,
                    'direction': direction,
                    'multiplier': vol / avg_volume
                })
        
        if not block_trades:
            return {'detected': False, 'score': 0, 'direction': 'neutral'}
        
        # Bestimme dominante Richtung
        buy_volume = sum(bt['volume'] for bt in block_trades if bt['direction'] == 'buy')
        sell_volume = sum(bt['volume'] for bt in block_trades if bt['direction'] == 'sell')
        
        return {
            'detected': True,
            'count': len(block_trades),
            'score': min(len(block_trades) / 5, 1.0),
            'direction': 'buy' if buy_volume > sell_volume else 'sell',
            'total_volume': buy_volume + sell_volume,
        }
    
    def _detect_iceberg_orders(self, orderbook: dict) -> dict:
        """
        Erkenne Iceberg Orders (gro√üe Orders die in kleinen Chunks erscheinen)
        """
        if not orderbook.get('bids') or not orderbook.get('asks'):
            return {'detected': False, 'probability': 0}
        
        def check_iceberg(orders, side):
            if len(orders) < 5:
                return 0, 0
            
            # Iceberg-Indikator: Viele kleine Orders auf gleichem Preis-Level
            price_levels = {}
            for price, size in orders[:20]:
                rounded = round(price, 2)
                if rounded not in price_levels:
                    price_levels[rounded] = []
                price_levels[rounded].append(size)
            
            # Finde Level mit vielen kleinen gleichgro√üen Orders
            for level, sizes in price_levels.items():
                if len(sizes) >= 3:
                    # Pr√ºfe ob Gr√∂√üen √§hnlich sind (Iceberg-Charakter)
                    if np.std(sizes) / np.mean(sizes) < 0.2:
                        return 0.8, level
            
            return 0.2, 0
        
        bid_prob, bid_level = check_iceberg(orderbook['bids'], 'bid')
        ask_prob, ask_level = check_iceberg(orderbook['asks'], 'ask')
        
        if bid_prob > ask_prob:
            return {
                'detected': bid_prob > 0.5,
                'probability': bid_prob,
                'side': 'bid',
                'level': bid_level
            }
        else:
            return {
                'detected': ask_prob > 0.5,
                'probability': ask_prob,
                'side': 'ask',
                'level': ask_level
            }
    
    def _detect_algo_execution(self, df: pd.DataFrame) -> dict:
        """Erkenne algorithmische Ausf√ºhrung (TWAP/VWAP)"""
        if len(df) < 20:
            return {'detected': False, 'probability': 0}
        
        # TWAP-Charakteristik: Regelm√§√üige Trades √ºber Zeit
        # VWAP-Charakteristik: Trades proportional zum Volumen
        
        recent = df.tail(20)
        
        # Pr√ºfe auf gleichm√§√üige Volumenverteilung
        vol_distribution = recent['volume'].values
        expected_uniform = np.mean(vol_distribution)
        
        # Chi-Square-√§hnlicher Test
        deviation = np.sum((vol_distribution - expected_uniform) ** 2) / expected_uniform
        
        # Niedrige Deviation = m√∂glicherweise TWAP
        if deviation < 5:
            return {'detected': True, 'probability': 0.7, 'type': 'TWAP'}
        elif deviation < 10:
            return {'detected': True, 'probability': 0.4, 'type': 'possible_algo'}
        
        return {'detected': False, 'probability': 0.1, 'type': 'none'}
    
    def _analyze_session_activity(self, df: pd.DataFrame) -> dict:
        """Analysiere Aktivit√§t nach Trading-Session"""
        hour = datetime.now().hour
        
        # Institutionelle sind aktiver w√§hrend regul√§rer Marktzeiten
        if 13 <= hour <= 21:  # US Session
            return {'session': 'US', 'institutional_activity': 0.8}
        elif 7 <= hour <= 16:  # EU Session
            return {'session': 'EU', 'institutional_activity': 0.6}
        elif 0 <= hour <= 8:   # Asia Session
            return {'session': 'Asia', 'institutional_activity': 0.5}
        else:
            return {'session': 'off_hours', 'institutional_activity': 0.3}


class QuantumMomentumPredictor:
    """
    FEATURE 5: Quantum Momentum Predictor
    Verwendet fortschrittliche mathematische Modelle:
    - Fourier-Transformation f√ºr Zyklen
    - Hurst-Exponent f√ºr Trend-Persistenz
    - Entropy-basierte Vorhersage
    """
    
    def __init__(self, config: Config, logger: Logger):
        self.config = config
        self.logger = logger
        self.predictions = deque(maxlen=100)
    
    def predict(self, df: pd.DataFrame) -> dict:
        """Generiere Momentum-Vorhersage"""
        try:
            if len(df) < 50:
                return {'prediction': 'neutral', 'confidence': 0}
            
            close = df['close'].values
            
            # 1. Hurst Exponent (Trend-Persistenz)
            hurst = self._calculate_hurst_exponent(close)
            
            # 2. Fourier Analysis (dominante Zyklen)
            dominant_cycle = self._fourier_analysis(close)
            
            # 3. Shannon Entropy (Markt-Unsicherheit)
            entropy = self._calculate_entropy(close)
            
            # 4. Fractal Dimension (Komplexit√§t)
            fractal_dim = self._calculate_fractal_dimension(close)
            
            # 5. Lyapunov Exponent (Chaos-Ma√ü)
            lyapunov = self._estimate_lyapunov(close)
            
            # Kombiniere zu Vorhersage
            prediction_score = self._combine_predictions(
                hurst, dominant_cycle, entropy, fractal_dim, lyapunov, close
            )
            
            # Richtung
            if prediction_score > 0.3:
                prediction = 'strong_up'
            elif prediction_score > 0.1:
                prediction = 'up'
            elif prediction_score < -0.3:
                prediction = 'strong_down'
            elif prediction_score < -0.1:
                prediction = 'down'
            else:
                prediction = 'neutral'
            
            result = {
                'prediction': prediction,
                'score': prediction_score,
                'confidence': min(abs(prediction_score) * 2, 1.0),
                'hurst_exponent': hurst,
                'dominant_cycle': dominant_cycle,
                'entropy': entropy,
                'fractal_dimension': fractal_dim,
                'lyapunov': lyapunov,
                'trend_persistent': hurst > 0.5,
                'market_chaotic': lyapunov > 0,
            }
            
            self.predictions.append({
                'timestamp': datetime.now(),
                'prediction': prediction,
                'score': prediction_score
            })
            
            return result
            
        except Exception as e:
            self.logger.log(f"Quantum prediction error: {e}", "ERROR")
            return {'prediction': 'neutral', 'confidence': 0}
    
    def _calculate_hurst_exponent(self, data: np.ndarray) -> float:
        """
        Hurst Exponent: Misst Trend-Persistenz
        H > 0.5: Trending (persistent)
        H < 0.5: Mean-reverting
        H = 0.5: Random walk
        """
        n = len(data)
        if n < 20:
            return 0.5
        
        # R/S Analysis
        max_k = min(n // 2, 50)
        rs_values = []
        
        for k in range(10, max_k):
            # Teile in Subseries
            subseries = np.array_split(data, n // k)
            
            rs_list = []
            for sub in subseries:
                if len(sub) < 2:
                    continue
                
                mean = np.mean(sub)
                deviate = sub - mean
                cumulative = np.cumsum(deviate)
                
                r = np.max(cumulative) - np.min(cumulative)
                s = np.std(sub)
                
                if s > 0:
                    rs_list.append(r / s)
            
            if rs_list:
                rs_values.append((k, np.mean(rs_list)))
        
        if len(rs_values) < 2:
            return 0.5
        
        # Log-Log Regression f√ºr Hurst
        log_n = np.log([r[0] for r in rs_values])
        log_rs = np.log([r[1] for r in rs_values])
        
        # Lineare Regression
        coeffs = np.polyfit(log_n, log_rs, 1)
        hurst = coeffs[0]
        
        return max(0, min(1, hurst))
    
    def _fourier_analysis(self, data: np.ndarray) -> dict:
        """Finde dominante Zyklen via FFT"""
        if len(data) < 30:
            return {'period': 0, 'strength': 0}
        
        # Detrend
        detrended = data - np.polyval(np.polyfit(range(len(data)), data, 1), range(len(data)))
        
        # FFT
        fft = np.fft.fft(detrended)
        frequencies = np.fft.fftfreq(len(data))
        
        # Finde dominante Frequenz (ignoriere DC component)
        magnitudes = np.abs(fft[1:len(data)//2])
        dominant_idx = np.argmax(magnitudes) + 1
        
        dominant_freq = abs(frequencies[dominant_idx])
        dominant_period = 1 / dominant_freq if dominant_freq > 0 else 0
        
        # St√§rke des Zyklus
        total_power = np.sum(magnitudes ** 2)
        dominant_power = magnitudes[dominant_idx - 1] ** 2
        strength = dominant_power / total_power if total_power > 0 else 0
        
        return {
            'period': dominant_period,
            'strength': strength,
            'cycle_phase': (len(data) % dominant_period) / dominant_period if dominant_period > 0 else 0
        }
    
    def _calculate_entropy(self, data: np.ndarray) -> float:
        """Shannon Entropy der Returns"""
        if len(data) < 10:
            return 0.5
        
        returns = np.diff(data) / data[:-1]
        
        # Diskretisiere Returns in Bins
        hist, _ = np.histogram(returns, bins=20, density=True)
        hist = hist[hist > 0]  # Entferne Nullen
        
        # Shannon Entropy
        entropy = -np.sum(hist * np.log2(hist + 1e-10))
        
        # Normalisiere
        max_entropy = np.log2(20)  # Maximum f√ºr 20 bins
        return entropy / max_entropy
    
    def _calculate_fractal_dimension(self, data: np.ndarray) -> float:
        """Box-Counting Fractal Dimension"""
        if len(data) < 20:
            return 1.5
        
        # Normalisiere Daten
        data_norm = (data - np.min(data)) / (np.max(data) - np.min(data) + 1e-10)
        
        # Box counting
        box_sizes = [2, 4, 8, 16, 32]
        box_counts = []
        
        for size in box_sizes:
            if size >= len(data):
                continue
            
            count = 0
            for i in range(0, len(data) - size, size):
                segment = data_norm[i:i+size]
                if np.max(segment) - np.min(segment) > 0:
                    count += 1
            
            if count > 0:
                box_counts.append((size, count))
        
        if len(box_counts) < 2:
            return 1.5
        
        # Log-Log Regression
        log_size = np.log([bc[0] for bc in box_counts])
        log_count = np.log([bc[1] for bc in box_counts])
        
        coeffs = np.polyfit(log_size, log_count, 1)
        fractal_dim = -coeffs[0]
        
        return max(1, min(2, fractal_dim))
    
    def _estimate_lyapunov(self, data: np.ndarray) -> float:
        """Sch√§tze Lyapunov Exponent (Chaos-Ma√ü)"""
        if len(data) < 30:
            return 0
        
        # Vereinfachte Sch√§tzung via Return-Autokorrelation
        returns = np.diff(np.log(data + 1e-10))
        
        if len(returns) < 10:
            return 0
        
        # Autokorrelation bei Lag 1
        autocorr = np.corrcoef(returns[:-1], returns[1:])[0, 1]
        
        # Lyapunov ~ -log(|autocorr|) f√ºr chaotische Systeme
        if abs(autocorr) > 0.01:
            lyapunov = -np.log(abs(autocorr))
        else:
            lyapunov = 3  # Sehr chaotisch
        
        return max(-2, min(3, lyapunov))
    
    def _combine_predictions(self, hurst: float, cycle: dict, entropy: float,
                            fractal: float, lyapunov: float, data: np.ndarray) -> float:
        """Kombiniere alle Indikatoren zu einem Prediction Score"""
        score = 0
        
        # 1. Hurst-basierte Prediction
        if hurst > 0.6:
            # Trending - folge dem Trend
            trend = 1 if data[-1] > data[-10] else -1
            score += trend * (hurst - 0.5) * 2
        elif hurst < 0.4:
            # Mean-reverting - gegen den Trend
            trend = 1 if data[-1] > np.mean(data[-20:]) else -1
            score -= trend * (0.5 - hurst) * 2
        
        # 2. Cycle-basierte Prediction
        if cycle['strength'] > 0.3:
            # Starker Zyklus - nutze Phase
            if cycle['cycle_phase'] < 0.25:
                score += 0.3 * cycle['strength']  # Aufw√§rtsphase
            elif cycle['cycle_phase'] > 0.75:
                score -= 0.3 * cycle['strength']  # Abw√§rtsphase
        
        # 3. Entropy-Anpassung
        if entropy > 0.8:
            # Hohe Unsicherheit - reduziere Confidence
            score *= 0.5
        elif entropy < 0.3:
            # Niedrige Unsicherheit - erh√∂he Confidence
            score *= 1.5
        
        # 4. Momentum aus letzten Candles
        recent_return = (data[-1] - data[-5]) / data[-5]
        score += recent_return * 10  # Gewichte Momentum
        
        return max(-1, min(1, score))


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
#                    ALLE STRATEGIEN - INKLUSIVE GEHEIMER!
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class BaseStrategy:
    """Basisklasse f√ºr alle Strategien"""
    
    def __init__(self, name: str, config: Config, logger: Logger):
        self.name = name
        self.config = config
        self.logger = logger
        self.params = self._default_params()
        self.requires_agreement = True  # Standard: Braucht Agreement
    
    def _default_params(self) -> dict:
        return {}
    
    def analyze(self, df: pd.DataFrame, indicators: dict, orderbook_analysis: dict) -> dict:
        """Override in Subclass"""
        raise NotImplementedError
    
    def get_signal(self, df: pd.DataFrame, indicators: dict, orderbook_analysis: dict) -> dict:
        """Wrapper f√ºr analyze mit Error Handling"""
        try:
            result = self.analyze(df, indicators, orderbook_analysis)
            result['strategy_name'] = self.name
            result['requires_agreement'] = self.requires_agreement
            return result
        except Exception as e:
            self.logger.log(f"Strategy {self.name} error: {e}", "ERROR", True)
            return {
                'signal': 'neutral',
                'strength': 0,
                'strategy_name': self.name,
                'requires_agreement': self.requires_agreement,
                'error': str(e)
            }


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 23 STANDARD STRATEGIEN (20 Original + 3 Neue)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class RSIOversoldOverbought(BaseStrategy):
    """RSI Extremwerte"""
    def __init__(self, config, logger):
        super().__init__("RSI_Extreme", config, logger)
        self.params = {'oversold': 30, 'overbought': 70}
    
    def analyze(self, df, indicators, ob):
        rsi = indicators.get('rsi_14', 50)
        
        if rsi < self.params['oversold']:
            return {'signal': 'long', 'strength': (self.params['oversold'] - rsi) / 30}
        elif rsi > self.params['overbought']:
            return {'signal': 'short', 'strength': (rsi - self.params['overbought']) / 30}
        return {'signal': 'neutral', 'strength': 0}


class MACDCrossover(BaseStrategy):
    """MACD Crossover"""
    def __init__(self, config, logger):
        super().__init__("MACD_Cross", config, logger)
    
    def analyze(self, df, indicators, ob):
        macd = indicators.get('macd', 0)
        signal = indicators.get('macd_signal', 0)
        hist = indicators.get('macd_hist', 0)
        
        if macd > signal and hist > 0:
            return {'signal': 'long', 'strength': min(abs(hist) / 0.01, 1)}
        elif macd < signal and hist < 0:
            return {'signal': 'short', 'strength': min(abs(hist) / 0.01, 1)}
        return {'signal': 'neutral', 'strength': 0}


class BollingerBandSqueeze(BaseStrategy):
    """Bollinger Band Squeeze Breakout"""
    def __init__(self, config, logger):
        super().__init__("BB_Squeeze", config, logger)
    
    def analyze(self, df, indicators, ob):
        bb_width = indicators.get('bb_width', 0.1)
        close = df['close'].iloc[-1]
        bb_upper = indicators.get('bb_upper', close)
        bb_lower = indicators.get('bb_lower', close)
        
        # Squeeze = Niedrige Bandbreite
        if bb_width < 0.02:  # Squeeze aktiv
            if close > bb_upper * 0.998:
                return {'signal': 'long', 'strength': 0.8}
            elif close < bb_lower * 1.002:
                return {'signal': 'short', 'strength': 0.8}
        return {'signal': 'neutral', 'strength': 0}


class VolumeSpikeDetection(BaseStrategy):
    """Volume Spike Detection"""
    def __init__(self, config, logger):
        super().__init__("Volume_Spike", config, logger)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 20:
            return {'signal': 'neutral', 'strength': 0}
        
        current_vol = df['volume'].iloc[-1]
        avg_vol = df['volume'].tail(20).mean()
        
        if current_vol > avg_vol * 2.5:
            # Spike erkannt - Richtung durch Kerze
            if df['close'].iloc[-1] > df['open'].iloc[-1]:
                return {'signal': 'long', 'strength': min(current_vol / (avg_vol * 3), 1)}
            else:
                return {'signal': 'short', 'strength': min(current_vol / (avg_vol * 3), 1)}
        return {'signal': 'neutral', 'strength': 0}


class EMACrossover(BaseStrategy):
    """EMA 9/21 Crossover"""
    def __init__(self, config, logger):
        super().__init__("EMA_Cross", config, logger)
    
    def analyze(self, df, indicators, ob):
        ema9 = indicators.get('ema_9', 0)
        ema21 = indicators.get('ema_21', 0)
        
        if ema9 == 0 or ema21 == 0:
            return {'signal': 'neutral', 'strength': 0}
        
        cross_strength = (ema9 - ema21) / ema21 * 100
        
        if cross_strength > 0.1:
            return {'signal': 'long', 'strength': min(cross_strength / 0.5, 1)}
        elif cross_strength < -0.1:
            return {'signal': 'short', 'strength': min(abs(cross_strength) / 0.5, 1)}
        return {'signal': 'neutral', 'strength': 0}


class StochasticRSI(BaseStrategy):
    """Stochastic RSI Extremes"""
    def __init__(self, config, logger):
        super().__init__("Stoch_RSI", config, logger)
    
    def analyze(self, df, indicators, ob):
        stoch_k = indicators.get('stoch_k', 50)
        stoch_d = indicators.get('stoch_d', 50)
        
        if stoch_k < 20 and stoch_d < 20:
            return {'signal': 'long', 'strength': (20 - stoch_k) / 20}
        elif stoch_k > 80 and stoch_d > 80:
            return {'signal': 'short', 'strength': (stoch_k - 80) / 20}
        return {'signal': 'neutral', 'strength': 0}


class ADXTrendStrength(BaseStrategy):
    """ADX Trend Strength"""
    def __init__(self, config, logger):
        super().__init__("ADX_Trend", config, logger)
    
    def analyze(self, df, indicators, ob):
        adx = indicators.get('adx', 0)
        plus_di = indicators.get('plus_di', 0)
        minus_di = indicators.get('minus_di', 0)
        
        if adx > 25:  # Starker Trend
            if plus_di > minus_di:
                return {'signal': 'long', 'strength': min(adx / 50, 1)}
            else:
                return {'signal': 'short', 'strength': min(adx / 50, 1)}
        return {'signal': 'neutral', 'strength': 0}


class IchimokuTKCross(BaseStrategy):
    """Ichimoku Tenkan-Kijun Cross"""
    def __init__(self, config, logger):
        super().__init__("Ichimoku_TK", config, logger)
    
    def analyze(self, df, indicators, ob):
        tenkan = indicators.get('ichimoku_tenkan', 0)
        kijun = indicators.get('ichimoku_kijun', 0)
        
        if tenkan == 0 or kijun == 0:
            return {'signal': 'neutral', 'strength': 0}
        
        cross = (tenkan - kijun) / kijun * 100
        
        if cross > 0.05:
            return {'signal': 'long', 'strength': min(cross / 0.3, 1)}
        elif cross < -0.05:
            return {'signal': 'short', 'strength': min(abs(cross) / 0.3, 1)}
        return {'signal': 'neutral', 'strength': 0}


class VWAPDeviation(BaseStrategy):
    """VWAP Deviation Strategy"""
    def __init__(self, config, logger):
        super().__init__("VWAP_Dev", config, logger)
    
    def analyze(self, df, indicators, ob):
        vwap = indicators.get('vwap', 0)
        close = df['close'].iloc[-1]
        
        if vwap == 0:
            return {'signal': 'neutral', 'strength': 0}
        
        deviation = (close - vwap) / vwap * 100
        
        if deviation < -1.5:  # Unter VWAP
            return {'signal': 'long', 'strength': min(abs(deviation) / 3, 1)}
        elif deviation > 1.5:  # √úber VWAP
            return {'signal': 'short', 'strength': min(deviation / 3, 1)}
        return {'signal': 'neutral', 'strength': 0}


class FibonacciRetracement(BaseStrategy):
    """Fibonacci Retracement Levels"""
    def __init__(self, config, logger):
        super().__init__("Fib_Retrace", config, logger)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 50:
            return {'signal': 'neutral', 'strength': 0}
        
        high = df['high'].tail(50).max()
        low = df['low'].tail(50).min()
        close = df['close'].iloc[-1]
        
        # Fibonacci Levels
        fib_382 = low + (high - low) * 0.382
        fib_500 = low + (high - low) * 0.500
        fib_618 = low + (high - low) * 0.618
        
        tolerance = (high - low) * 0.02  # 2% Toleranz
        
        # Pr√ºfe N√§he zu Fib-Levels
        if abs(close - fib_618) < tolerance:
            # Bei 61.8% - starkes Support/Resistance
            trend = indicators.get('trend', 'sideways')
            if trend == 'up':
                return {'signal': 'long', 'strength': 0.7}
            elif trend == 'down':
                return {'signal': 'short', 'strength': 0.7}
        
        return {'signal': 'neutral', 'strength': 0}


class OrderBookImbalance(BaseStrategy):
    """Order Book Imbalance"""
    def __init__(self, config, logger):
        super().__init__("OB_Imbalance", config, logger)
    
    def analyze(self, df, indicators, ob):
        imbalance = ob.get('imbalance', 1)
        pressure = ob.get('pressure_score', 0)
        
        if imbalance > 1.5 and pressure > 30:
            return {'signal': 'long', 'strength': min((imbalance - 1) / 2, 1)}
        elif imbalance < 0.67 and pressure < -30:
            return {'signal': 'short', 'strength': min((1 - imbalance), 1)}
        return {'signal': 'neutral', 'strength': 0}


class FundingRateArbitrage(BaseStrategy):
    """Funding Rate Arbitrage"""
    def __init__(self, config, logger):
        super().__init__("Funding_Arb", config, logger)
    
    def analyze(self, df, indicators, ob):
        # Funding Rate muss extern geholt werden
        funding = indicators.get('funding_rate', 0)
        
        if funding > 0.001:  # Hohe positive Rate
            return {'signal': 'short', 'strength': min(funding / 0.003, 1)}
        elif funding < -0.001:  # Negative Rate
            return {'signal': 'long', 'strength': min(abs(funding) / 0.003, 1)}
        return {'signal': 'neutral', 'strength': 0}


class OpenInterestChange(BaseStrategy):
    """Open Interest Change Analysis"""
    def __init__(self, config, logger):
        super().__init__("OI_Change", config, logger)
    
    def analyze(self, df, indicators, ob):
        # Approximation: Volumen-√Ñnderung als Proxy f√ºr OI
        if len(df) < 10:
            return {'signal': 'neutral', 'strength': 0}
        
        vol_change = (df['volume'].tail(5).mean() - df['volume'].tail(20).mean()) / df['volume'].tail(20).mean()
        price_change = (df['close'].iloc[-1] - df['close'].iloc[-5]) / df['close'].iloc[-5]
        
        if vol_change > 0.3 and price_change > 0:
            return {'signal': 'long', 'strength': min(vol_change, 1)}
        elif vol_change > 0.3 and price_change < 0:
            return {'signal': 'short', 'strength': min(vol_change, 1)}
        return {'signal': 'neutral', 'strength': 0}


class SupportResistanceProximity(BaseStrategy):
    """Support/Resistance Proximity"""
    def __init__(self, config, logger):
        super().__init__("SR_Proximity", config, logger)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 50:
            return {'signal': 'neutral', 'strength': 0}
        
        close = df['close'].iloc[-1]
        
        # Finde Support/Resistance durch Pivot Points
        high = df['high'].tail(20).max()
        low = df['low'].tail(20).min()
        pivot = (high + low + close) / 3
        
        support = 2 * pivot - high
        resistance = 2 * pivot - low
        
        tolerance = (high - low) * 0.03
        
        if abs(close - support) < tolerance:
            return {'signal': 'long', 'strength': 0.7}
        elif abs(close - resistance) < tolerance:
            return {'signal': 'short', 'strength': 0.7}
        return {'signal': 'neutral', 'strength': 0}


class CandlestickPatterns(BaseStrategy):
    """Candlestick Pattern Recognition"""
    def __init__(self, config, logger):
        super().__init__("Candle_Pattern", config, logger)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 5:
            return {'signal': 'neutral', 'strength': 0}
        
        # Letzte 3 Kerzen
        c1 = df.iloc[-3]
        c2 = df.iloc[-2]
        c3 = df.iloc[-1]
        
        # Engulfing Pattern
        if c2['close'] < c2['open']:  # Vorherige rot
            if c3['close'] > c3['open']:  # Aktuelle gr√ºn
                if c3['close'] > c2['open'] and c3['open'] < c2['close']:
                    return {'signal': 'long', 'strength': 0.7}  # Bullish Engulfing
        
        if c2['close'] > c2['open']:  # Vorherige gr√ºn
            if c3['close'] < c3['open']:  # Aktuelle rot
                if c3['close'] < c2['open'] and c3['open'] > c2['close']:
                    return {'signal': 'short', 'strength': 0.7}  # Bearish Engulfing
        
        # Doji (Unentschlossenheit)
        body_size = abs(c3['close'] - c3['open'])
        total_size = c3['high'] - c3['low']
        
        if total_size > 0 and body_size / total_size < 0.1:
            # Doji - Trend-Umkehr m√∂glich
            trend = indicators.get('trend', 'sideways')
            if trend == 'up':
                return {'signal': 'short', 'strength': 0.5}
            elif trend == 'down':
                return {'signal': 'long', 'strength': 0.5}
        
        return {'signal': 'neutral', 'strength': 0}


class MarketStructureBreak(BaseStrategy):
    """Market Structure Break Detection"""
    def __init__(self, config, logger):
        super().__init__("MSB", config, logger)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        # Finde Higher Highs/Lower Lows
        highs = df['high'].tail(20).values
        lows = df['low'].tail(20).values
        
        recent_high = np.max(highs[-5:])
        previous_high = np.max(highs[-15:-5])
        
        recent_low = np.min(lows[-5:])
        previous_low = np.min(lows[-15:-5])
        
        # Break of Structure
        if recent_high > previous_high * 1.005:  # Higher High Break
            return {'signal': 'long', 'strength': 0.8}
        elif recent_low < previous_low * 0.995:  # Lower Low Break
            return {'signal': 'short', 'strength': 0.8}
        
        return {'signal': 'neutral', 'strength': 0}


class FairValueGap(BaseStrategy):
    """Fair Value Gap (FVG) Detection"""
    def __init__(self, config, logger):
        super().__init__("FVG", config, logger)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 5:
            return {'signal': 'neutral', 'strength': 0}
        
        # FVG = L√ºcke zwischen Kerze 1 Low und Kerze 3 High (bullish)
        c1 = df.iloc[-3]
        c2 = df.iloc[-2]
        c3 = df.iloc[-1]
        
        # Bullish FVG
        if c1['low'] > c3['high']:
            gap_size = (c1['low'] - c3['high']) / c3['high'] * 100
            if gap_size > 0.2:
                return {'signal': 'long', 'strength': min(gap_size / 1, 1)}
        
        # Bearish FVG
        if c1['high'] < c3['low']:
            gap_size = (c3['low'] - c1['high']) / c1['high'] * 100
            if gap_size > 0.2:
                return {'signal': 'short', 'strength': min(gap_size / 1, 1)}
        
        return {'signal': 'neutral', 'strength': 0}


class MovingAverageRibbon(BaseStrategy):
    """Moving Average Ribbon"""
    def __init__(self, config, logger):
        super().__init__("MA_Ribbon", config, logger)
    
    def analyze(self, df, indicators, ob):
        ema9 = indicators.get('ema_9', 0)
        ema21 = indicators.get('ema_21', 0)
        ema50 = indicators.get('ema_50', 0)
        
        if ema9 == 0 or ema21 == 0 or ema50 == 0:
            return {'signal': 'neutral', 'strength': 0}
        
        # Perfektes Ribbon: EMA9 > EMA21 > EMA50
        if ema9 > ema21 > ema50:
            spread = (ema9 - ema50) / ema50 * 100
            return {'signal': 'long', 'strength': min(spread / 2, 1)}
        elif ema9 < ema21 < ema50:
            spread = (ema50 - ema9) / ema50 * 100
            return {'signal': 'short', 'strength': min(spread / 2, 1)}
        
        return {'signal': 'neutral', 'strength': 0}


class MomentumDivergence(BaseStrategy):
    """Momentum Divergence (RSI vs Price)"""
    def __init__(self, config, logger):
        super().__init__("Mom_Divergence", config, logger)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 20:
            return {'signal': 'neutral', 'strength': 0}
        
        # Vergleiche Preis-Trend mit RSI-Trend
        price_trend = (df['close'].iloc[-1] - df['close'].iloc[-10]) / df['close'].iloc[-10]
        
        # RSI √ºber Zeit (vereinfacht)
        rsi_current = indicators.get('rsi_14', 50)
        
        # Bullish Divergence: Preis f√§llt, RSI steigt
        if price_trend < -0.02 and rsi_current > 40:
            return {'signal': 'long', 'strength': 0.7}
        
        # Bearish Divergence: Preis steigt, RSI f√§llt
        if price_trend > 0.02 and rsi_current < 60:
            return {'signal': 'short', 'strength': 0.7}
        
        return {'signal': 'neutral', 'strength': 0}


class CCIExtreme(BaseStrategy):
    """CCI Extreme Values"""
    def __init__(self, config, logger):
        super().__init__("CCI_Extreme", config, logger)
    
    def analyze(self, df, indicators, ob):
        cci = indicators.get('cci', 0)
        
        if cci < -150:
            return {'signal': 'long', 'strength': min(abs(cci) / 200, 1)}
        elif cci > 150:
            return {'signal': 'short', 'strength': min(cci / 200, 1)}
        return {'signal': 'neutral', 'strength': 0}


# NEUE STRATEGIE 1
class MFIDivergence(BaseStrategy):
    """Money Flow Index Divergence"""
    def __init__(self, config, logger):
        super().__init__("MFI_Divergence", config, logger)
    
    def analyze(self, df, indicators, ob):
        mfi = indicators.get('mfi', 50)
        
        if len(df) < 10:
            return {'signal': 'neutral', 'strength': 0}
        
        price_change = (df['close'].iloc[-1] - df['close'].iloc[-5]) / df['close'].iloc[-5]
        
        # Bullish: Preis runter, MFI hoch
        if price_change < -0.01 and mfi > 60:
            return {'signal': 'long', 'strength': 0.6}
        
        # Bearish: Preis hoch, MFI niedrig
        if price_change > 0.01 and mfi < 40:
            return {'signal': 'short', 'strength': 0.6}
        
        return {'signal': 'neutral', 'strength': 0}


# NEUE STRATEGIE 2
class OBVTrendConfirmation(BaseStrategy):
    """On-Balance Volume Trend Confirmation"""
    def __init__(self, config, logger):
        super().__init__("OBV_Trend", config, logger)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 20:
            return {'signal': 'neutral', 'strength': 0}
        
        # Berechne OBV Trend
        obv_values = []
        obv = 0
        for i in range(len(df) - 20, len(df)):
            if df['close'].iloc[i] > df['close'].iloc[i-1]:
                obv += df['volume'].iloc[i]
            else:
                obv -= df['volume'].iloc[i]
            obv_values.append(obv)
        
        obv_trend = obv_values[-1] - obv_values[0]
        price_trend = df['close'].iloc[-1] - df['close'].iloc[-20]
        
        # Confirmation: OBV und Preis in gleiche Richtung
        if obv_trend > 0 and price_trend > 0:
            return {'signal': 'long', 'strength': 0.6}
        elif obv_trend < 0 and price_trend < 0:
            return {'signal': 'short', 'strength': 0.6}
        
        return {'signal': 'neutral', 'strength': 0}


# NEUE STRATEGIE 3
class ATRBreakout(BaseStrategy):
    """ATR-Based Breakout"""
    def __init__(self, config, logger):
        super().__init__("ATR_Breakout", config, logger)
    
    def analyze(self, df, indicators, ob):
        atr = indicators.get('atr_14', 0)
        
        if atr == 0 or len(df) < 10:
            return {'signal': 'neutral', 'strength': 0}
        
        close = df['close'].iloc[-1]
        prev_close = df['close'].iloc[-2]
        
        move = abs(close - prev_close)
        
        # Breakout wenn Move > 1.5 * ATR
        if move > atr * 1.5:
            if close > prev_close:
                return {'signal': 'long', 'strength': min(move / (atr * 2), 1)}
            else:
                return {'signal': 'short', 'strength': min(move / (atr * 2), 1)}
        
        return {'signal': 'neutral', 'strength': 0}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
# ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë
# ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
#  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
#                    3 ULTRA MEGA ADVANCED STRATEGIEN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FractalDimensionBreakout(BaseStrategy):
    """
    ULTRA MEGA ADVANCED 1: Fractal Dimension Breakout - IMPROVED v2
    - Bessere Entry-Filter mit ATR & Volatilit√§t
    - Combo-Signale f√ºr h√∂here Zuverl√§ssigkeit
    - Dynamische Thresholds basierend auf Markt-Regime
    - Weniger False Positives, bessere Gewinn-Chancen
    """
    def __init__(self, config, logger):
        super().__init__("Fractal_Dimension", config, logger)
        self.requires_agreement = False
        self.fd_history = deque(maxlen=20)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 60:
            return {'signal': 'neutral', 'strength': 0}
        
        close = df['close'].values
        
        # 1. Berechne Fractal Dimension
        fd = self._calculate_fractal_dimension(close)
        self.fd_history.append(fd)
        
        # 2. Hole aktuelle Indikatoren
        rsi = indicators.get('rsi_14', 50)
        atr = indicators.get('atr_14', 0)
        adx = indicators.get('adx', 0)
        macd_hist = indicators.get('macd_hist', 0)
        bb_width = indicators.get('bb_width', 0)
        
        # 3. Berechne Volatilit√§t
        recent_returns = np.diff(close[-20:]) / close[-20:-1]
        volatility = np.std(recent_returns) * 100
        
        # 4. FD Trend
        if len(self.fd_history) >= 5:
            fd_trend = 'increasing' if self.fd_history[-1] > self.fd_history[-5] else 'decreasing'
        else:
            fd_trend = 'neutral'
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # VERBESSERTE ENTRY-LOGIK
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        # REGIME 1: STARK TRENDING (FD < 1.25)
        if fd < 1.25:
            trend = 1 if close[-1] > close[-15] else -1
            
            # Filter: ADX > 25 (starker Trend best√§tigt)
            if adx > 25:
                # Zus√§tzlich: RSI nicht √ºberverkauft/√ºberkauft (30-70)
                if 30 < rsi < 70:
                    # LONG Signal
                    if trend > 0:
                        return {
                            'signal': 'long', 
                            'strength': 0.88,  # Reduziert von 0.9
                            'fractal_dim': fd,
                            'confidence': 'HIGH_TREND',
                            'filters': f'ADX={adx:.1f}, RSI={rsi:.1f}, Vol={volatility:.2f}%'
                        }
                    # SHORT Signal
                    else:
                        return {
                            'signal': 'short',
                            'strength': 0.88,
                            'fractal_dim': fd,
                            'confidence': 'HIGH_TREND',
                            'filters': f'ADX={adx:.1f}, RSI={rsi:.1f}, Vol={volatility:.2f}%'
                        }
                
                # RSI extreme - nur wenn SEHR starker ADX
                elif (rsi < 25 or rsi > 75) and adx > 30:
                    if trend > 0 and rsi < 25:
                        return {
                            'signal': 'long',
                            'strength': 0.80,
                            'fractal_dim': fd,
                            'confidence': 'TREND_EXTREME_RSI'
                        }
                    elif trend < 0 and rsi > 75:
                        return {
                            'signal': 'short',
                            'strength': 0.80,
                            'fractal_dim': fd,
                            'confidence': 'TREND_EXTREME_RSI'
                        }
        
        # REGIME 2: √úBERGANG (1.25 < FD < 1.65) - VORSICHT!
        elif 1.25 <= fd <= 1.65:
            # Zu chaotisch - nur mit SEHR starken Best√§tigungen
            if adx > 35 and abs(macd_hist) > 0.001:
                trend = 1 if close[-1] > close[-10] else -1
                if trend > 0:
                    return {
                        'signal': 'long',
                        'strength': 0.72,
                        'fractal_dim': fd,
                        'confidence': 'TRANSITION_STRONG_CONFIRMATION'
                    }
                else:
                    return {
                        'signal': 'short',
                        'strength': 0.72,
                        'fractal_dim': fd,
                        'confidence': 'TRANSITION_STRONG_CONFIRMATION'
                    }
        
        # REGIME 3: CHAOTISCH (FD > 1.65) - MEAN REVERSION
        elif fd > 1.65:
            mean = np.mean(close[-25:])
            
            # Filter: Nicht zu nah am Mean - mindestens 1% Abweichung
            current_deviation = abs(close[-1] - mean) / mean * 100
            
            if current_deviation > 1.0:  # Mindestens 1% Deviation
                # LONG: Preis unter Mean + zus√§tzliche Best√§tigung
                if close[-1] < mean * 0.97:
                    # Best√§tigung: RSI oversold ODER Volume spike
                    if rsi < 35 or ob.get('imbalance', 0) > 0.15:
                        return {
                            'signal': 'long',
                            'strength': 0.75,
                            'fractal_dim': fd,
                            'confidence': 'CHAOS_MEAN_REVERSION_BUY',
                            'details': f'Price vs Mean: {current_deviation:.2f}%, RSI={rsi:.1f}'
                        }
                
                # SHORT: Preis √ºber Mean + zus√§tzliche Best√§tigung
                elif close[-1] > mean * 1.03:
                    if rsi > 65 or ob.get('imbalance', 0) < -0.15:
                        return {
                            'signal': 'short',
                            'strength': 0.75,
                            'fractal_dim': fd,
                            'confidence': 'CHAOS_MEAN_REVERSION_SELL',
                            'details': f'Price vs Mean: {current_deviation:.2f}%, RSI={rsi:.1f}'
                        }
        
        return {'signal': 'neutral', 'strength': 0, 'fractal_dim': fd}
    
    def _calculate_fractal_dimension(self, data):
        """Box-Counting Dimension mit verbesserter Genauigkeit"""
        # Normalisiere
        data_min = np.min(data)
        data_max = np.max(data)
        if data_max == data_min:
            return 1.5
        
        data_norm = (data - data_min) / (data_max - data_min)
        
        # Multi-scale box counting
        box_sizes = [4, 8, 16, 32, 64]
        counts = []
        
        for size in box_sizes:
            if size >= len(data):
                continue
            count = 0
            for i in range(0, len(data) - size, max(1, size // 2)):  # 50% Overlap
                segment = data_norm[i:i+size]
                if len(segment) == size:  # Nur vollst√§ndige Segmente
                    if np.max(segment) - np.min(segment) > 0.01:  # Mindest-Range
                        count += 1
            if count > 0:
                counts.append((size, count))
        
        if len(counts) < 2:
            return 1.5
        
        log_size = np.log([c[0] for c in counts])
        log_count = np.log([c[1] for c in counts])
        
        # Linear Regression f√ºr FD
        fd = -np.polyfit(log_size, log_count, 1)[0]
        return max(1.0, min(2.0, fd))


class EntropyBasedReversal(BaseStrategy):
    """
    ULTRA MEGA ADVANCED 2: Entropy-Based Reversal
    Nutzt Informationstheorie zur Erkennung von Wendepunkten
    """
    def __init__(self, config, logger):
        super().__init__("Entropy_Reversal", config, logger)
        self.requires_agreement = False
        self.entropy_history = deque(maxlen=50)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        close = df['close'].values
        returns = np.diff(close) / close[:-1]
        
        # Berechne Shannon Entropy
        entropy = self._calculate_entropy(returns[-20:])
        self.entropy_history.append(entropy)
        
        if len(self.entropy_history) < 10:
            return {'signal': 'neutral', 'strength': 0}
        
        # Entropy Spike = Regime-Wechsel wahrscheinlich
        avg_entropy = np.mean(list(self.entropy_history)[:-1])
        
        if entropy > avg_entropy * 1.3:  # Entropy Spike
            # Erwarte Reversal
            current_trend = 1 if close[-1] > close[-5] else -1
            
            # Trade gegen den Trend
            if current_trend > 0:
                return {'signal': 'short', 'strength': 0.8, 'entropy': entropy}
            else:
                return {'signal': 'long', 'strength': 0.8, 'entropy': entropy}
        
        elif entropy < avg_entropy * 0.7:  # Niedrige Entropy = Starker Trend
            # Folge dem Trend
            if close[-1] > close[-5]:
                return {'signal': 'long', 'strength': 0.6, 'entropy': entropy}
            else:
                return {'signal': 'short', 'strength': 0.6, 'entropy': entropy}
        
        return {'signal': 'neutral', 'strength': 0, 'entropy': entropy}
    
    def _calculate_entropy(self, data):
        """Shannon Entropy"""
        hist, _ = np.histogram(data, bins=10, density=True)
        hist = hist[hist > 0]
        return -np.sum(hist * np.log2(hist + 1e-10)) / np.log2(10)


class NeuralMomentumConfluence(BaseStrategy):
    """
    ULTRA MEGA ADVANCED 3: Neural Momentum Confluence
    Kombiniert multiple Momentum-Indikatoren mit gewichteter Fusion
    """
    def __init__(self, config, logger):
        super().__init__("Neural_Momentum", config, logger)
        self.requires_agreement = False
        # Adaptive Gewichte (werden durch Performance angepasst)
        self.weights = {
            'rsi': 0.15, 'macd': 0.15, 'stoch': 0.1, 'cci': 0.1,
            'mfi': 0.1, 'adx': 0.15, 'obv': 0.1, 'bb': 0.15
        }
    
    def analyze(self, df, indicators, ob):
        signals = {}
        
        # RSI Signal
        rsi = indicators.get('rsi_14', 50)
        signals['rsi'] = (50 - rsi) / 50  # Normalisiert: -1 bis +1
        
        # MACD Signal
        macd_hist = indicators.get('macd_hist', 0)
        signals['macd'] = np.tanh(macd_hist * 100)  # Sigmoid-√§hnlich
        
        # Stochastic Signal
        stoch = indicators.get('stoch_k', 50)
        signals['stoch'] = (50 - stoch) / 50
        
        # CCI Signal
        cci = indicators.get('cci', 0)
        signals['cci'] = -np.tanh(cci / 100)
        
        # MFI Signal
        mfi = indicators.get('mfi', 50)
        signals['mfi'] = (50 - mfi) / 50
        
        # ADX Signal (Trend Strength als Multiplikator)
        adx = indicators.get('adx', 0)
        plus_di = indicators.get('plus_di', 0)
        minus_di = indicators.get('minus_di', 0)
        trend_dir = 1 if plus_di > minus_di else -1
        signals['adx'] = trend_dir * min(adx / 50, 1)
        
        # OBV Signal
        if len(df) > 10:
            obv_change = df['volume'].tail(5).sum() - df['volume'].tail(10).head(5).sum()
            price_dir = 1 if df['close'].iloc[-1] > df['close'].iloc[-5] else -1
            signals['obv'] = price_dir * np.tanh(obv_change / df['volume'].mean())
        else:
            signals['obv'] = 0
        
        # Bollinger Signal
        bb_upper = indicators.get('bb_upper', 0)
        bb_lower = indicators.get('bb_lower', 0)
        close = df['close'].iloc[-1]
        if bb_upper > bb_lower:
            bb_pos = (close - bb_lower) / (bb_upper - bb_lower)
            signals['bb'] = (0.5 - bb_pos) * 2
        else:
            signals['bb'] = 0
        
        # Gewichtete Kombination
        total_signal = sum(signals[k] * self.weights[k] for k in signals)
        
        # Confidence basierend auf Agreement
        agreement = sum(1 for s in signals.values() if abs(s) > 0.3)
        confidence = agreement / len(signals)
        
        if total_signal > 0.2:
            return {'signal': 'long', 'strength': min(abs(total_signal), 1), 
                   'confidence': confidence, 'components': signals}
        elif total_signal < -0.2:
            return {'signal': 'short', 'strength': min(abs(total_signal), 1),
                   'confidence': confidence, 'components': signals}
        
        return {'signal': 'neutral', 'strength': 0}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù    
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïë       
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù     ‚ñà‚ñà‚ïë       
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë       
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù       
#         5 GEHEIME STRATEGIEN - NUR F√úR DIE 0.0001%
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class DarkPoolFlowReversal(BaseStrategy):
    """
    üîí GEHEIM 1: Dark Pool Flow Reversal
    
    Dark Pools sind au√üerb√∂rsliche Handelspl√§tze wo institutionelle
    Investoren gro√üe Orders ausf√ºhren ohne den Markt zu bewegen.
    
    Diese Strategie erkennt INDIREKT Dark Pool Aktivit√§t durch:
    - Preis-Volumen-Diskrepanzen
    - Ungew√∂hnliche Spread-Patterns
    - Time & Sales Anomalien
    
    Wenn Smart Money im Dark Pool kauft, entsteht sp√§ter oft
    ein Preis-Push im √∂ffentlichen Markt.
    """
    def __init__(self, config, logger):
        super().__init__("DarkPool_Reversal", config, logger)
        self.requires_agreement = False
        self.anomaly_history = deque(maxlen=30)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        # 1. Preis-Volumen-Diskrepanz
        # Wenn Preis sich bewegt OHNE entsprechendes Volumen = Dark Pool
        pvd = self._detect_price_volume_discrepancy(df)
        
        # 2. Spread-Kompression vor gro√üen Moves
        spread_signal = self._analyze_spread_pattern(ob, df)
        
        # 3. Absorption Detection
        # Wenn gro√üe Sells absorbiert werden ohne Preisfall = Accumulation
        absorption = self._detect_absorption(df, ob)
        
        # Kombiniere Signale
        dark_pool_score = pvd * 0.4 + spread_signal * 0.3 + absorption * 0.3
        
        self.anomaly_history.append(dark_pool_score)
        
        # Signal wenn Score stark genug
        if dark_pool_score > 0.5:
            return {
                'signal': 'long', 
                'strength': min(dark_pool_score, 1),
                'dark_pool_detected': True,
                'accumulation': True
            }
        elif dark_pool_score < -0.5:
            return {
                'signal': 'short',
                'strength': min(abs(dark_pool_score), 1),
                'dark_pool_detected': True,
                'distribution': True
            }
        
        return {'signal': 'neutral', 'strength': 0}
    
    def _detect_price_volume_discrepancy(self, df):
        """Erkenne wenn Preis sich ohne Volumen bewegt"""
        recent = df.tail(10)
        
        price_change = abs(recent['close'].iloc[-1] - recent['close'].iloc[0]) / recent['close'].iloc[0]
        volume_ratio = recent['volume'].iloc[-1] / recent['volume'].mean()
        
        # Gro√üe Preisbewegung mit niedrigem Volumen = verd√§chtig
        if price_change > 0.01 and volume_ratio < 0.5:
            direction = 1 if recent['close'].iloc[-1] > recent['close'].iloc[0] else -1
            return direction * 0.8
        
        return 0
    
    def _analyze_spread_pattern(self, ob, df):
        """Analysiere Spread-Verhalten"""
        if not ob.get('bids') or not ob.get('asks'):
            return 0
        
        spread = ob.get('spread', 0)
        
        # Enge Spread + niedriges Volumen = jemand kontrolliert den Markt
        if spread < 0.05:  # Sehr enger Spread
            return 0.3
        
        return 0
    
    def _detect_absorption(self, df, ob):
        """Erkenne Order-Absorption"""
        if len(df) < 5:
            return 0
        
        # Wenn es gro√üe Sells gibt aber Preis nicht f√§llt = Absorption
        recent = df.tail(5)
        
        sell_volume = sum(
            recent['volume'].iloc[i] 
            for i in range(len(recent)) 
            if recent['close'].iloc[i] < recent['open'].iloc[i]
        )
        
        price_change = (recent['close'].iloc[-1] - recent['close'].iloc[0]) / recent['close'].iloc[0]
        
        if sell_volume > recent['volume'].sum() * 0.6 and price_change > -0.005:
            return 0.7  # Bullish Absorption
        
        return 0


class StopHuntSniper(BaseStrategy):
    """
    üîí GEHEIM 2: Stop Hunt Sniper
    
    Market Maker und gro√üe Player "jagen" oft Stop-Loss Orders:
    1. Sie pushen den Preis kurz durch Support/Resistance
    2. L√∂sen damit viele Stop-Losses aus
    3. Sammeln billige Positionen ein
    4. Lassen den Preis zur√ºck in die urspr√ºngliche Richtung gehen
    
    Diese Strategie erkennt Stop Hunts und tradet die Reversal!
    """
    def __init__(self, config, logger):
        super().__init__("StopHunt_Sniper", config, logger)
        self.requires_agreement = False
        self.potential_hunts = deque(maxlen=20)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        # Finde wichtige Levels (wo viele Stops liegen)
        stop_levels = self._identify_stop_levels(df)
        
        # Pr√ºfe ob aktuell ein Stop Hunt l√§uft
        hunt_signal = self._detect_active_hunt(df, stop_levels)
        
        if hunt_signal['active']:
            self.potential_hunts.append({
                'timestamp': datetime.now(),
                'direction': hunt_signal['direction'],
                'level': hunt_signal['level']
            })
            
            # Trade die Reversal!
            if hunt_signal['direction'] == 'downside_hunt':
                return {
                    'signal': 'long',
                    'strength': 0.85,
                    'stop_hunt_detected': True,
                    'hunt_level': hunt_signal['level'],
                    'entry_reason': 'Stop Hunt Reversal - Longs wurden gejagt, jetzt kaufen!'
                }
            else:
                return {
                    'signal': 'short',
                    'strength': 0.85,
                    'stop_hunt_detected': True,
                    'hunt_level': hunt_signal['level'],
                    'entry_reason': 'Stop Hunt Reversal - Shorts wurden gejagt, jetzt shorten!'
                }
        
        return {'signal': 'neutral', 'strength': 0}
    
    def _identify_stop_levels(self, df):
        """Identifiziere wo wahrscheinlich Stops liegen"""
        levels = []
        
        # Stops liegen typischerweise:
        # 1. Unter lokalen Tiefs
        # 2. √úber lokalen Hochs
        # 3. An runden Zahlen
        
        for i in range(5, len(df) - 5):
            # Lokale Tiefs
            if df['low'].iloc[i] == df['low'].iloc[i-5:i+6].min():
                levels.append({
                    'price': df['low'].iloc[i] * 0.998,  # Knapp drunter
                    'type': 'long_stops'
                })
            
            # Lokale Hochs
            if df['high'].iloc[i] == df['high'].iloc[i-5:i+6].max():
                levels.append({
                    'price': df['high'].iloc[i] * 1.002,  # Knapp dr√ºber
                    'type': 'short_stops'
                })
        
        return levels[-10:]  # Letzte 10 Levels
    
    def _detect_active_hunt(self, df, stop_levels):
        """Erkenne aktiven Stop Hunt"""
        if not stop_levels:
            return {'active': False}
        
        current_price = df['close'].iloc[-1]
        recent_low = df['low'].tail(3).min()
        recent_high = df['high'].tail(3).max()
        
        for level in stop_levels:
            # Downside Stop Hunt
            if level['type'] == 'long_stops':
                # Preis hat Level unterschritten, ist aber zur√ºck
                if recent_low < level['price'] < current_price:
                    # Best√§tige durch Volumen-Spike
                    if df['volume'].iloc[-1] > df['volume'].tail(10).mean() * 1.5:
                        return {
                            'active': True,
                            'direction': 'downside_hunt',
                            'level': level['price']
                        }
            
            # Upside Stop Hunt
            if level['type'] == 'short_stops':
                if recent_high > level['price'] > current_price:
                    if df['volume'].iloc[-1] > df['volume'].tail(10).mean() * 1.5:
                        return {
                            'active': True,
                            'direction': 'upside_hunt',
                            'level': level['price']
                        }
        
        return {'active': False}


class LiquidityVoidFiller(BaseStrategy):
    """
    üîí GEHEIM 3: Liquidity Void Filler
    
    Liquidity Voids (auch "Imbalances" oder "Fair Value Gaps") entstehen
    wenn der Preis so schnell bewegt wird, dass keine Trades in
    bestimmten Preisbereichen stattfinden.
    
    Der Preis hat eine NAT√úRLICHE TENDENZ diese Voids zu f√ºllen!
    
    Diese Strategie identifiziert unfilled Voids und tradet
    ihre F√ºllung.
    """
    def __init__(self, config, logger):
        super().__init__("Liquidity_Void", config, logger)
        self.requires_agreement = False
        self.active_voids = []
    
    def analyze(self, df, indicators, ob):
        if len(df) < 20:
            return {'signal': 'neutral', 'strength': 0}
        
        current_price = df['close'].iloc[-1]
        
        # Finde neue Voids
        new_voids = self._find_liquidity_voids(df)
        self.active_voids.extend(new_voids)
        
        # Entferne gef√ºllte Voids
        self.active_voids = [
            v for v in self.active_voids 
            if not self._is_void_filled(v, df)
        ]
        
        # Finde n√§chsten Void zum aktuellen Preis
        if not self.active_voids:
            return {'signal': 'neutral', 'strength': 0}
        
        nearest_void = min(
            self.active_voids,
            key=lambda v: min(abs(current_price - v['upper']), 
                            abs(current_price - v['lower']))
        )
        
        # Trade-Signal wenn Preis sich Void n√§hert
        distance_to_void = self._get_distance_to_void(current_price, nearest_void)
        
        if distance_to_void < 0.005:  # Innerhalb 0.5%
            if current_price > nearest_void['upper']:
                # Void ist unter uns - erwarte Pull-down
                return {
                    'signal': 'short',
                    'strength': 0.7,
                    'void_target': (nearest_void['upper'] + nearest_void['lower']) / 2,
                    'void_type': 'below'
                }
            elif current_price < nearest_void['lower']:
                # Void ist √ºber uns - erwarte Pull-up
                return {
                    'signal': 'long',
                    'strength': 0.7,
                    'void_target': (nearest_void['upper'] + nearest_void['lower']) / 2,
                    'void_type': 'above'
                }
        
        return {'signal': 'neutral', 'strength': 0, 'nearest_void': nearest_void}
    
    def _find_liquidity_voids(self, df):
        """Finde Liquidity Voids (FVGs)"""
        voids = []
        
        for i in range(2, len(df)):
            c1 = df.iloc[i-2]  # Erste Kerze
            c2 = df.iloc[i-1]  # Mittlere Kerze (die schnelle)
            c3 = df.iloc[i]    # Dritte Kerze
            
            # Bullish FVG: L√ºcke zwischen c1 high und c3 low
            if c3['low'] > c1['high']:
                gap_size = (c3['low'] - c1['high']) / c1['high']
                if gap_size > 0.003:  # Min 0.3% Gap
                    voids.append({
                        'upper': c3['low'],
                        'lower': c1['high'],
                        'type': 'bullish',
                        'size': gap_size,
                        'timestamp': df.index[i] if hasattr(df, 'index') else i
                    })
            
            # Bearish FVG
            if c3['high'] < c1['low']:
                gap_size = (c1['low'] - c3['high']) / c3['high']
                if gap_size > 0.003:
                    voids.append({
                        'upper': c1['low'],
                        'lower': c3['high'],
                        'type': 'bearish',
                        'size': gap_size,
                        'timestamp': df.index[i] if hasattr(df, 'index') else i
                    })
        
        return voids[-5:]  # Nur neueste
    
    def _is_void_filled(self, void, df):
        """Pr√ºfe ob Void bereits gef√ºllt wurde"""
        recent_prices = df.tail(10)
        mid_void = (void['upper'] + void['lower']) / 2
        
        for _, row in recent_prices.iterrows():
            if row['low'] <= mid_void <= row['high']:
                return True
        return False
    
    def _get_distance_to_void(self, price, void):
        """Berechne Distanz zum Void"""
        if void['lower'] <= price <= void['upper']:
            return 0
        
        return min(
            abs(price - void['upper']) / price,
            abs(price - void['lower']) / price
        )


class WhaleExhaustionDetector(BaseStrategy):
    """
    üîí GEHEIM 4: Whale Exhaustion Detector
    
    Whales (gro√üe Trader) k√∂nnen den Markt nur begrenzt bewegen.
    Wenn ein Whale viel gekauft/verkauft hat, ist er "exhausted"
    und hat keine Munition mehr.
    
    Diese Strategie erkennt:
    1. Whale-Aktivit√§t durch Volumen-Anomalien
    2. Ersch√∂pfung durch abnehmende Effektivit√§t
    3. Reversal wenn Whale-Power nachl√§sst
    """
    def __init__(self, config, logger):
        super().__init__("Whale_Exhaustion", config, logger)
        self.requires_agreement = False
        self.whale_activity = deque(maxlen=50)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        # Erkenne Whale-Aktivit√§t
        whale_data = self._detect_whale_activity(df, ob)
        self.whale_activity.append(whale_data)
        
        if len(self.whale_activity) < 10:
            return {'signal': 'neutral', 'strength': 0}
        
        # Analysiere Ersch√∂pfung
        exhaustion = self._analyze_exhaustion()
        
        if exhaustion['exhausted']:
            # Whale ist ersch√∂pft - trade die Reversal!
            if exhaustion['whale_direction'] == 'buying':
                return {
                    'signal': 'short',
                    'strength': 0.8,
                    'whale_exhausted': True,
                    'exhaustion_level': exhaustion['level'],
                    'entry_reason': 'Whale Buying Exhaustion - Keine Kaufkraft mehr!'
                }
            else:
                return {
                    'signal': 'long',
                    'strength': 0.8,
                    'whale_exhausted': True,
                    'exhaustion_level': exhaustion['level'],
                    'entry_reason': 'Whale Selling Exhaustion - Keine Verkaufskraft mehr!'
                }
        
        return {'signal': 'neutral', 'strength': 0}
    
    def _detect_whale_activity(self, df, ob):
        """Erkenne aktuelle Whale-Aktivit√§t"""
        current = df.iloc[-1]
        avg_volume = df['volume'].tail(20).mean()
        
        # Whale-Indikator
        volume_multiple = current['volume'] / avg_volume
        price_impact = abs(current['close'] - current['open']) / current['open']
        
        # Effizienz = Price Impact pro Volume
        efficiency = price_impact / volume_multiple if volume_multiple > 0 else 0
        
        # Richtung
        direction = 'buying' if current['close'] > current['open'] else 'selling'
        
        return {
            'timestamp': datetime.now(),
            'volume_multiple': volume_multiple,
            'price_impact': price_impact,
            'efficiency': efficiency,
            'direction': direction,
            'is_whale': volume_multiple > 2.5
        }
    
    def _analyze_exhaustion(self):
        """Analysiere ob Whale ersch√∂pft ist"""
        recent = list(self.whale_activity)[-10:]
        
        # Finde dominante Whale-Richtung
        whale_events = [w for w in recent if w['is_whale']]
        
        if len(whale_events) < 3:
            return {'exhausted': False}
        
        # Z√§hle Richtungen
        buying = sum(1 for w in whale_events if w['direction'] == 'buying')
        selling = len(whale_events) - buying
        
        dominant_direction = 'buying' if buying > selling else 'selling'
        
        # Pr√ºfe Effizienz-Trend
        dominant_events = [w for w in whale_events if w['direction'] == dominant_direction]
        
        if len(dominant_events) < 2:
            return {'exhausted': False}
        
        # Ersch√∂pfung = Effizienz nimmt ab
        early_efficiency = np.mean([e['efficiency'] for e in dominant_events[:len(dominant_events)//2]])
        late_efficiency = np.mean([e['efficiency'] for e in dominant_events[len(dominant_events)//2:]])
        
        efficiency_decline = (early_efficiency - late_efficiency) / early_efficiency if early_efficiency > 0 else 0
        
        if efficiency_decline > 0.3:  # 30% Effizienz-R√ºckgang
            return {
                'exhausted': True,
                'whale_direction': dominant_direction,
                'level': efficiency_decline
            }
        
        return {'exhausted': False}


class HiddenDivergenceMatrix(BaseStrategy):
    """
    üîí GEHEIM 5: Hidden Divergence Matrix
    
    Hidden Divergences sind ST√ÑRKER als normale Divergences!
    
    Normal Divergence: Preis macht Higher High, Indikator Lower High
    Hidden Divergence: Preis macht Higher Low, Indikator Lower Low
    
    Hidden Divergences signalisieren Trend-CONTINUATION, nicht Reversal!
    
    Diese Strategie kombiniert MULTIPLE Hidden Divergences
    f√ºr ultra-pr√§zise Entries.
    """
    def __init__(self, config, logger):
        super().__init__("Hidden_Divergence", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        divergences = []
        
        # Pr√ºfe Hidden Divergence f√ºr jeden Indikator
        rsi_div = self._check_hidden_divergence(df, 'rsi', indicators.get('rsi_14', 50))
        macd_div = self._check_hidden_divergence_macd(df, indicators)
        stoch_div = self._check_hidden_divergence(df, 'stoch', indicators.get('stoch_k', 50))
        cci_div = self._check_hidden_divergence(df, 'cci', indicators.get('cci', 0))
        mfi_div = self._check_hidden_divergence(df, 'mfi', indicators.get('mfi', 50))
        
        divergences = [rsi_div, macd_div, stoch_div, cci_div, mfi_div]
        
        # Z√§hle Divergences
        bullish_count = sum(1 for d in divergences if d == 'bullish_hidden')
        bearish_count = sum(1 for d in divergences if d == 'bearish_hidden')
        
        # Signal nur wenn MEHRERE Divergences
        if bullish_count >= 3:
            return {
                'signal': 'long',
                'strength': min(bullish_count / 5, 1),
                'hidden_divergence': True,
                'divergence_count': bullish_count,
                'entry_reason': f'{bullish_count}/5 Hidden Bullish Divergences - Starke Trend-Continuation!'
            }
        elif bearish_count >= 3:
            return {
                'signal': 'short',
                'strength': min(bearish_count / 5, 1),
                'hidden_divergence': True,
                'divergence_count': bearish_count,
                'entry_reason': f'{bearish_count}/5 Hidden Bearish Divergences - Starke Trend-Continuation!'
            }
        
        return {'signal': 'neutral', 'strength': 0}
    
    def _check_hidden_divergence(self, df, indicator_name, current_value):
        """Pr√ºfe auf Hidden Divergence"""
        if len(df) < 20:
            return 'none'
        
        # Finde Swing Points im Preis
        lows = df['low'].tail(20).values
        highs = df['high'].tail(20).values
        
        # Vereinfachte Erkennung
        recent_low = np.min(lows[-5:])
        previous_low = np.min(lows[-15:-5])
        
        recent_high = np.max(highs[-5:])
        previous_high = np.max(highs[-15:-5])
        
        # Hidden Bullish: Higher Low im Preis, Lower Low im Indikator
        if recent_low > previous_low:
            # Preis macht Higher Low - pr√ºfe Indikator
            if indicator_name in ['rsi', 'stoch', 'mfi']:
                if current_value < 40:  # Indikator zeigt Schw√§che
                    return 'bullish_hidden'
            elif indicator_name == 'cci':
                if current_value < -50:
                    return 'bullish_hidden'
        
        # Hidden Bearish: Lower High im Preis, Higher High im Indikator
        if recent_high < previous_high:
            if indicator_name in ['rsi', 'stoch', 'mfi']:
                if current_value > 60:
                    return 'bearish_hidden'
            elif indicator_name == 'cci':
                if current_value > 50:
                    return 'bearish_hidden'
        
        return 'none'
    
    def _check_hidden_divergence_macd(self, df, indicators):
        """Spezielle MACD Hidden Divergence"""
        macd = indicators.get('macd', 0)
        signal = indicators.get('macd_signal', 0)
        hist = indicators.get('macd_hist', 0)
        
        if len(df) < 20:
            return 'none'
        
        lows = df['low'].tail(20).values
        highs = df['high'].tail(20).values
        
        recent_low = np.min(lows[-5:])
        previous_low = np.min(lows[-15:-5])
        recent_high = np.max(highs[-5:])
        previous_high = np.max(highs[-15:-5])
        
        # Hidden Bullish
        if recent_low > previous_low and hist < 0:
            return 'bullish_hidden'
        
        # Hidden Bearish
        if recent_high < previous_high and hist > 0:
            return 'bearish_hidden'
        
        return 'none'


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 5 NEUE CUSTOM-KOMBINATIONSSTRAGIEN (aus den 23 Standard kombiniert, kein Agreement!)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FisherEMAMACDCombo(BaseStrategy):
    """
    CUSTOM KOMBO 1: Fisher Transform + EMA + MACD
    
    Kombination aus:
    - Fisher Transform zur Normalisierung
    - EMA 9/21 f√ºr Trend
    - MACD f√ºr Momentum
    
    Entry wenn alle drei aligned sind!
    """
    def __init__(self, config, logger):
        super().__init__("Fisher_EMA_MACD", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 50:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Fisher Transform
            fisher = ExtendedIndicators.fisher_transform(df)
            
            # EMA Trend
            ema_9 = indicators.get('ema_9', df['close'].iloc[-1])
            ema_21 = indicators.get('ema_21', df['close'].iloc[-1])
            
            # MACD
            macd = indicators.get('macd', 0)
            macd_signal = indicators.get('macd_signal', 0)
            
            current_price = df['close'].iloc[-1]
            
            # LONG Bedingungen
            if (fisher > 2 and current_price > ema_9 > ema_21 and 
                macd > macd_signal and macd > 0):
                return {
                    'signal': 'long',
                    'strength': min(abs(fisher) / 3, 1),
                    'entry_reason': f'Fisher:{fisher:.2f} + EMA(9>{21}) + MACD Cross'
                }
            
            # SHORT Bedingungen
            if (fisher < -2 and current_price < ema_9 < ema_21 and 
                macd < macd_signal and macd < 0):
                return {
                    'signal': 'short',
                    'strength': min(abs(fisher) / 3, 1),
                    'entry_reason': f'Fisher:{fisher:.2f} + EMA(9<21) + MACD Cross'
                }
        
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class RSIStochasticDMICombo(BaseStrategy):
    """
    CUSTOM KOMBO 2: RSI + Stochastic + DMI
    
    Extrem pr√§zise Kombination:
    - RSI 14 f√ºr Oversold/Overbought
    - Stochastic f√ºr Momentum
    - DMI+ vs DMI- f√ºr Richtung
    """
    def __init__(self, config, logger):
        super().__init__("RSI_Stoch_DMI", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            rsi = indicators.get('rsi_14', 50)
            stoch_k = indicators.get('stoch_k', 50)
            stoch_d = indicators.get('stoch_d', 50)
            
            # Berechne DMI
            dmi_plus = ExtendedIndicators.dmi_plus(df)
            dmi_minus = ExtendedIndicators.dmi_minus(df)
            
            # LONG: RSI √ºbersold + Stoch unten + DMI+ > DMI-
            if rsi < 35 and stoch_k < 25 and dmi_plus > dmi_minus:
                strength = (35 - rsi) / 35 * 0.7 + (dmi_plus - dmi_minus) / 100 * 0.3
                return {
                    'signal': 'long',
                    'strength': min(strength, 1),
                    'entry_reason': f'RSI:{rsi:.0f} Oversold + Stoch:{stoch_k:.0f} + DMI+ Dominance'
                }
            
            # SHORT: RSI overbought + Stoch oben + DMI- > DMI+
            if rsi > 65 and stoch_k > 75 and dmi_minus > dmi_plus:
                strength = (rsi - 65) / 35 * 0.7 + (dmi_minus - dmi_plus) / 100 * 0.3
                return {
                    'signal': 'short',
                    'strength': min(strength, 1),
                    'entry_reason': f'RSI:{rsi:.0f} Overbought + Stoch:{stoch_k:.0f} + DMI- Dominance'
                }
        
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class BBWilliamsROCCombo(BaseStrategy):
    """
    CUSTOM KOMBO 3: Bollinger Bands + Williams %R + ROC
    
    Extreme Umkehrungen erkennen:
    - BB Squeeze + Williams R Extrem + ROC Momentum
    """
    def __init__(self, config, logger):
        super().__init__("BB_Williams_ROC", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 25:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            bb_upper = indicators.get('bb_upper', df['close'].iloc[-1])
            bb_lower = indicators.get('bb_lower', df['close'].iloc[-1])
            bb_width = bb_upper - bb_lower
            
            williams_r = ExtendedIndicators.williams_r(df)
            roc = ExtendedIndicators.roc(df)
            
            current_price = df['close'].iloc[-1]
            
            # LONG: BB Squeeze + Williams R extrem niedrig + ROC positiv
            if bb_width < indicators.get('atr_14', 0.1) * 1.5 and williams_r < -90 and roc > 0:
                return {
                    'signal': 'long',
                    'strength': 0.8,
                    'entry_reason': f'BB Squeeze + Williams:{williams_r:.0f} + ROC:{roc:.2f}'
                }
            
            # SHORT: BB Squeeze + Williams R extrem hoch + ROC negativ
            if bb_width < indicators.get('atr_14', 0.1) * 1.5 and williams_r > -10 and roc < 0:
                return {
                    'signal': 'short',
                    'strength': 0.8,
                    'entry_reason': f'BB Squeeze + Williams:{williams_r:.0f} + ROC:{roc:.2f}'
                }
        
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class CCI_TRIX_SupertrendCombo(BaseStrategy):
    """
    CUSTOM KOMBO 4: CCI + TRIX + Supertrend
    
    Confluence aus drei verschiedenen Indikatoren-Kategorien
    """
    def __init__(self, config, logger):
        super().__init__("CCI_TRIX_Supertrend", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 35:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            cci = indicators.get('cci', 0)
            trix = ExtendedIndicators.trix(df)
            supertrend = ExtendedIndicators.supertrend(df)
            
            # LONG
            if cci > 100 and trix > 0.1 and supertrend > 0:
                return {
                    'signal': 'long',
                    'strength': 0.85,
                    'entry_reason': f'CCI:{cci:.0f} + TRIX:{trix:.3f} + ST-Up'
                }
            
            # SHORT
            if cci < -100 and trix < -0.1 and supertrend < 0:
                return {
                    'signal': 'short',
                    'strength': 0.85,
                    'entry_reason': f'CCI:{cci:.0f} + TRIX:{trix:.3f} + ST-Down'
                }
        
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class ADXMomentumLinRegCombo(BaseStrategy):
    """
    CUSTOM KOMBO 5: ADX + Momentum + Linear Regression
    
    F√ºr Trending-M√§rkte optimiert
    """
    def __init__(self, config, logger):
        super().__init__("ADX_Mom_LinReg", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            adx = indicators.get('adx', 20)
            plus_di = indicators.get('plus_di', 20)
            minus_di = indicators.get('minus_di', 20)
            
            momentum = ExtendedIndicators.momentum(df)
            lin_reg = ExtendedIndicators.linear_regression(df)
            
            # LONG: Starker Trend + Positiver Momentum + Positive Steigung
            if adx > 30 and plus_di > minus_di and momentum > 0 and lin_reg > 0.01:
                return {
                    'signal': 'long',
                    'strength': min(adx / 50, 1),
                    'entry_reason': f'ADX:{adx:.0f} + Mom:{momentum:.4f} + Slope:{lin_reg:.3f}'
                }
            
            # SHORT: Starker Trend + Negativer Momentum + Negative Steigung
            if adx > 30 and minus_di > plus_di and momentum < 0 and lin_reg < -0.01:
                return {
                    'signal': 'short',
                    'strength': min(adx / 50, 1),
                    'entry_reason': f'ADX:{adx:.0f} + Mom:{momentum:.4f} + Slope:{lin_reg:.3f}'
                }
        
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 8 HYDRA SECRETS - Ultra-exotische Strategien (0.00001% der Trader kennen diese!)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class QuantumLiquidationCascade(BaseStrategy):
    """
    HYDRA SECRET 1: Quantum Liquidation Cascade
    
    Basiert auf der Beobachtung von Liquidationszonen und deren Aktivierungsmustern.
    Wenn Liquidations in einer Zone geh√§uft auftreten, folgt meist ein Kaskaden-Effekt.
    
    Aus einem Singapore-Trader: "Wenn die Liquidationen sich clustern,
    ist der n√§chste Move meist 10x so gro√ü!"
    """
    def __init__(self, config, logger):
        super().__init__("Quantum_Liquidation_Cascade", config, logger)
        self.requires_agreement = False
        self.liquidation_history = deque(maxlen=100)
    
    def analyze(self, df, indicators, ob):
        if len(df) < 20:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Erkenne Liquidations-Pattern aus Volumen-Spikes
            vol_sma = df['volume'].rolling(20).mean().iloc[-1]
            current_vol = df['volume'].iloc[-1]
            vol_ratio = current_vol / vol_sma if vol_sma > 0 else 1
            
            # Wenn Volumen 3x √ºber Normal
            if vol_ratio > 3:
                # Pr√ºfe ob ATR auch gespikt ist (Volatilit√§t + Volumen)
                atr = indicators.get('atr_14', 0)
                current_range = df['high'].iloc[-1] - df['low'].iloc[-1]
                
                if current_range > atr * 1.5:
                    # LIQUIDATION CASCADE erkannt!
                    momentum = ExtendedIndicators.momentum(df, 5)
                    
                    if momentum > 0:
                        return {
                            'signal': 'long',
                            'strength': min(vol_ratio / 5, 1),
                            'entry_reason': f'Liquidation Cascade LONG - Vol Spike:{vol_ratio:.1f}x + Momentum'
                        }
                    else:
                        return {
                            'signal': 'short',
                            'strength': min(vol_ratio / 5, 1),
                            'entry_reason': f'Liquidation Cascade SHORT - Vol Spike:{vol_ratio:.1f}x + Momentum'
                        }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class SmartMoneyFootprintAnalysis(BaseStrategy):
    """
    HYDRA SECRET 2: Smart Money Footprint Analysis
    
    Instituionelle K√§ufer hinterlassen 'Footprints':
    - Gro√üe Orders die NICHT sofort ausgef√ºhrt werden
    - Order-Fluss-Imbalance
    - Timing-Pattern zu bestimmten Zeiten
    
    Diese Klasse erkennt diese Patterns!
    """
    def __init__(self, config, logger):
        super().__init__("Smart_Money_Footprint", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if not ob or len(df) < 15:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Analysiere Orderbook Footprint
            bid_vol = sum(b[1] for b in ob.get('bids', [])[:5])
            ask_vol = sum(a[1] for a in ob.get('asks', [])[:5])
            
            imbalance = (bid_vol - ask_vol) / (bid_vol + ask_vol) if (bid_vol + ask_vol) > 0 else 0
            
            # Starke Bid-Imbalance = Smart Money kauft
            if imbalance > 0.3:
                # Pr√ºfe Trend-Best√§tigung
                ema_9 = indicators.get('ema_9', df['close'].iloc[-1])
                ema_21 = indicators.get('ema_21', df['close'].iloc[-1])
                
                if ema_9 > ema_21:
                    return {
                        'signal': 'long',
                        'strength': min(abs(imbalance), 1),
                        'entry_reason': f'Smart Money Footprint - Bid Imbalance:{imbalance:.2%}'
                    }
            
            # Starke Ask-Imbalance = Smart Money verkauft
            if imbalance < -0.3:
                ema_9 = indicators.get('ema_9', df['close'].iloc[-1])
                ema_21 = indicators.get('ema_21', df['close'].iloc[-1])
                
                if ema_9 < ema_21:
                    return {
                        'signal': 'short',
                        'strength': min(abs(imbalance), 1),
                        'entry_reason': f'Smart Money Footprint - Ask Imbalance:{imbalance:.2%}'
                    }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class CharacteristicVolatilityRegime(BaseStrategy):
    """
    HYDRA SECRET 3: Characteristic Volatility Regime
    
    M√§rkte wechseln zwischen 3 Regimes:
    1. High Vol Breakout (gro√üe Moves erwartet)
    2. Low Vol Squeeze (bricht bald aus)
    3. Mean Reversion (zur EMA zur√ºck)
    
    Nur traden wenn Regime dem Setup entspricht!
    """
    def __init__(self, config, logger):
        super().__init__("Characteristic_Vol_Regime", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 50:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Berechne Rolling Volatilit√§t
            returns = df['close'].pct_change()
            vol_20 = returns.rolling(20).std().iloc[-1]
            vol_50 = returns.rolling(50).std().iloc[-1]
            vol_ratio = vol_20 / vol_50 if vol_50 > 0 else 1
            
            current_price = df['close'].iloc[-1]
            ema_50 = indicators.get('ema_50', current_price)
            
            # Squeeze Regime (Vol niedrig = Ausbruch wahrscheinlich)
            if vol_ratio < 0.7:
                # Wenn √ºber EMA -> Long wahrscheinlich
                if current_price > ema_50:
                    return {
                        'signal': 'long',
                        'strength': 0.8,
                        'entry_reason': f'Volatility Squeeze + Above EMA50 - Breakout erwartet'
                    }
                else:
                    return {
                        'signal': 'short',
                        'strength': 0.8,
                        'entry_reason': f'Volatility Squeeze + Below EMA50 - Breakdown erwartet'
                    }
            
            # High Vol Breakout (Vol spike)
            if vol_ratio > 1.5:
                # Fahre in Richtung des Trends weiter
                if current_price > ema_50:
                    return {
                        'signal': 'long',
                        'strength': 0.7,
                        'entry_reason': f'High Vol Regime - Continue Long'
                    }
                else:
                    return {
                        'signal': 'short',
                        'strength': 0.7,
                        'entry_reason': f'High Vol Regime - Continue Short'
                    }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class HiddenOrderBlockDetector(BaseStrategy):
    """
    HYDRA SECRET 4: Hidden Order Block Detector
    
    Order Blocks sind Bereiche wo K√§ufer/Verk√§ufer ihre Positionen
    abgewickelt haben. Wenn Preis zur√ºck zu diesen Areas kommt,
    findet oft Reversal statt!
    
    Diese Strategie erkennt historische Order Blocks.
    """
    def __init__(self, config, logger):
        super().__init__("Hidden_Order_Block", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 100:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            current_price = df['close'].iloc[-1]
            
            # Finde historische Widerstands- und Support-Zonen
            local_highs = df['high'].rolling(20).max()
            local_lows = df['low'].rolling(20).min()
            
            recent_high = df['high'].iloc[-20:].max()
            recent_low = df['low'].iloc[-20:].min()
            
            # Wenn Preis Close zu Recent High ist -> Order Block erkannt
            distance_to_high = (recent_high - current_price) / current_price
            distance_to_low = (current_price - recent_low) / current_price
            
            if distance_to_high < 0.005:  # Innerhalb 0.5%
                # Reversal von hohem Order Block erwartet
                return {
                    'signal': 'short',
                    'strength': 0.75,
                    'entry_reason': f'Order Block @ High - Reversal Expected'
                }
            
            if distance_to_low < 0.005:
                return {
                    'signal': 'long',
                    'strength': 0.75,
                    'entry_reason': f'Order Block @ Low - Reversal Expected'
                }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class MultiTimeframeConfluenceResonance(BaseStrategy):
    """
    HYDRA SECRET 5: Multi-Timeframe Confluence Resonance
    
    Wenn Signals auf 4h, 1h, 15min ALLE align -> sehr stark!
    Diese Strategie simuliert diese Confluence durch
    komplexere technische Muster.
    """
    def __init__(self, config, logger):
        super().__init__("MTF_Confluence_Resonance", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 60:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Simuliere mehrere Timeframes durch verschiedene Perioden
            # 4H √Ñquivalent: 60 candles zur√ºck
            # 1H √Ñquivalent: 15 candles
            # 15min √Ñquivalent: 3 candles
            
            # 4H Trend
            ema_200_long = df['close'].iloc[-60:].ewm(span=40).mean().iloc[-1]
            trend_4h = 'up' if df['close'].iloc[-1] > ema_200_long else 'down'
            
            # 1H Trend
            ema_50_mid = df['close'].iloc[-15:].ewm(span=10).mean().iloc[-1]
            trend_1h = 'up' if df['close'].iloc[-1] > ema_50_mid else 'down'
            
            # 15min Trend (3 letzte Kerzen)
            trend_15m_close = df['close'].iloc[-3:].mean()
            trend_15m = 'up' if df['close'].iloc[-1] > trend_15m_close else 'down'
            
            # Confluence wenn ALLE align
            if trend_4h == 'up' and trend_1h == 'up' and trend_15m == 'up':
                rsi = indicators.get('rsi_14', 50)
                if rsi < 70:  # Nicht overbought
                    return {
                        'signal': 'long',
                        'strength': 0.9,
                        'entry_reason': f'Multi-Timeframe Confluence UP - 4H/1H/15m aligned'
                    }
            
            if trend_4h == 'down' and trend_1h == 'down' and trend_15m == 'down':
                rsi = indicators.get('rsi_14', 50)
                if rsi > 30:  # Nicht oversold
                    return {
                        'signal': 'short',
                        'strength': 0.9,
                        'entry_reason': f'Multi-Timeframe Confluence DOWN - 4H/1H/15m aligned'
                    }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class AccelerationTrapDetector(BaseStrategy):
    """
    HYDRA SECRET 6: Acceleration Trap Detector
    
    Wenn Beschleunigung sinkt obwohl Preis steigt -> Trap!
    Momentum Divergence f√ºhrt zu Reversals.
    """
    def __init__(self, config, logger):
        super().__init__("Acceleration_Trap", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Berechne Beschleunigung (2. Ableitung von Preis)
            returns = df['close'].pct_change().values
            acceleration = np.diff(returns[-10:])  # Returns der Returns
            
            current_accel = acceleration[-1] if len(acceleration) > 0 else 0
            avg_accel = np.mean(acceleration) if len(acceleration) > 0 else 0
            
            # Wenn Preis steigt aber Beschleunigung sinkt -> SHORT
            if returns[-1] > 0 and current_accel < avg_accel * 0.3:
                return {
                    'signal': 'short',
                    'strength': 0.75,
                    'entry_reason': f'Acceleration Trap detected - UP aber Accel{current_accel:.4f}'
                }
            
            # Wenn Preis f√§llt aber Beschleunigung sinkt (wird weniger negativ) -> LONG
            if returns[-1] < 0 and current_accel > avg_accel * 0.3:
                return {
                    'signal': 'long',
                    'strength': 0.75,
                    'entry_reason': f'Acceleration Trap detected - DOWN aber Accel{current_accel:.4f}'
                }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class PulseOscillationReversal(BaseStrategy):
    """
    HYDRA SECRET 7: Pulse Oscillation Reversal
    
    Markten oszillieren in Pulsen (Wellen). Wenn ein Puls sein Ende
    erreicht hat (maximale Ausdehnung), folgt Reversal.
    """
    def __init__(self, config, logger):
        super().__init__("Pulse_Oscillation", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 40:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Erkenne Puls durch h√∂here Highs und Lower Lows
            highs = df['high'].iloc[-20:].values
            lows = df['low'].iloc[-20:].values
            
            # Sind die letzten 3 Highs aufsteigend?
            higher_highs = highs[-1] > highs[-2] > highs[-3]
            # Sind die letzten 3 Lows absteigend?
            lower_lows = lows[-1] < lows[-2] < lows[-3]
            
            # Puls Ende erkannt -> Reversal
            if higher_highs:
                # Trend zu Ende, Reversal down erwartet
                return {
                    'signal': 'short',
                    'strength': 0.7,
                    'entry_reason': f'Pulse UP ending - Higher Highs maxed out'
                }
            
            if lower_lows:
                # Trend zu Ende, Reversal up erwartet
                return {
                    'signal': 'long',
                    'strength': 0.7,
                    'entry_reason': f'Pulse DOWN ending - Lower Lows maxed out'
                }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class InstitutionalWaveMarking(BaseStrategy):
    """
    HYDRA SECRET 8: Institutional Wave Marking
    
    Institutionelle K√§ufer arbeiten in Wellen (Waves).
    Wenn du diese Waves erkennst, kannst du die n√§chste Wave antizipieren!
    
    Basiert auf Volume-Profile und Price-Action.
    """
    def __init__(self, config, logger):
        super().__init__("Institutional_Wave_Marking", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 50:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Analysiere Wellen durch Volume-Pattern
            vol = df['volume'].values
            close = df['close'].values
            
            # Finde die Wellen (Volume Peaks)
            vol_ma = df['volume'].rolling(10).mean().values
            vol_ratio = vol / vol_ma
            
            # Erkenne Wave Pattern
            recent_ratios = vol_ratio[-5:]
            
            # Wenn gerade ein Volume-Peak war (Wave Completion)
            if recent_ratios[-1] > 1.5 and recent_ratios[-2] > 1.2:
                # N√§chste Wave folgt
                if close[-1] > close[-5]:  # Trend up
                    return {
                        'signal': 'long',
                        'strength': 0.8,
                        'entry_reason': f'Wave {np.where(vol_ratio > 1.5)[0][-1]} completed - Next wave UP'
                    }
                else:
                    return {
                        'signal': 'short',
                        'strength': 0.8,
                        'entry_reason': f'Wave {np.where(vol_ratio > 1.5)[0][-1]} completed - Next wave DOWN'
                    }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# 4 ULTRA ENTRY-POINT STRATEGIEN - F√ºr 17%+ Moves mit 20x Hebel!
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ExtremeMicrostructurePulse(BaseStrategy):
    """
    ULTRA ENTRY 1: Extreme Microstructure Pulse
    
    Findet die EXAKTEN Punkte f√ºr 17%+ Moves.
    Basiert auf Ultra-kurz-fristiger Microstructure.
    
    Ein Singapore-Trader hat diese Strategie entwickelt:
    "Wenn der Bid-Ask Spread zusammenzieht und dann pl√∂tzlich explodiert,
    folgt IMMER ein Move von mindestens 15%!"
    """
    def __init__(self, config, logger):
        super().__init__("Extreme_Microstructure", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if not ob or len(df) < 10:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Berechne Spread-Historie
            bids = ob.get('bids', [])
            asks = ob.get('asks', [])
            
            if not bids or not asks:
                return {'signal': 'neutral', 'strength': 0}
            
            spread = asks[0][0] - bids[0][0]
            bid_price = bids[0][0]
            ask_price = asks[0][0]
            mid_price = (bid_price + ask_price) / 2
            spread_pct = (spread / mid_price) * 100
            
            # Bid-Ask Imbalance
            bid_vol = sum(b[1] for b in bids[:3])
            ask_vol = sum(a[1] for a in asks[:3])
            imbalance_pct = abs(bid_vol - ask_vol) / (bid_vol + ask_vol) * 100 if (bid_vol + ask_vol) > 0 else 0
            
            # EXTREME Setup: Tight Spread + High Imbalance
            if spread_pct < 0.02 and imbalance_pct > 25:  # Super tight spread + huge imbalance
                # Die Seite mit mehr Volume gewinnt
                if bid_vol > ask_vol:
                    return {
                        'signal': 'long',
                        'strength': 0.95,
                        'entry_reason': f'EXTREME Microstructure LONG - Spread:{spread_pct:.4f}% Imb:{imbalance_pct:.1f}%'
                    }
                else:
                    return {
                        'signal': 'short',
                        'strength': 0.95,
                        'entry_reason': f'EXTREME Microstructure SHORT - Spread:{spread_pct:.4f}% Imb:{imbalance_pct:.1f}%'
                    }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class QuantumBreakoutAcceleration(BaseStrategy):
    """
    ULTRA ENTRY 2: Quantum Breakout Acceleration
    
    Findet den EXAKTEN Moment wenn ein Breakout beginnt zu beschleunigen.
    Die ersten 3-5 Candles sind KRITISCH f√ºr 17%+ Moves.
    """
    def __init__(self, config, logger):
        super().__init__("Quantum_Breakout_Accel", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 15:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Berechne Acceleration Pattern
            closes = df['close'].iloc[-10:].values
            changes = np.diff(closes)
            
            # Ist die Beschleunigung POSITIV und ACCELERATING?
            recent_3_changes = changes[-3:]
            if len(recent_3_changes) >= 3:
                accel_trend = recent_3_changes[-1] > recent_3_changes[-2] > recent_3_changes[-3]
                
                # Wenn Beschleunigung selbst beschleunigt und Momentum positiv
                if accel_trend and recent_3_changes[-1] > 0:
                    momentum = ExtendedIndicators.momentum(df, 5)
                    roc = ExtendedIndicators.roc(df, 5)
                    
                    if momentum > 0 and roc > 2:
                        return {
                            'signal': 'long',
                            'strength': 0.92,
                            'entry_reason': f'Breakout ACCELERATING - Mom:{momentum:.6f} ROC:{roc:.2f}%'
                        }
                
                # Negative beschleunigte Bewegung
                accel_trend_down = recent_3_changes[-1] < recent_3_changes[-2] < recent_3_changes[-3]
                if accel_trend_down and recent_3_changes[-1] < 0:
                    momentum = ExtendedIndicators.momentum(df, 5)
                    roc = ExtendedIndicators.roc(df, 5)
                    
                    if momentum < 0 and roc < -2:
                        return {
                            'signal': 'short',
                            'strength': 0.92,
                            'entry_reason': f'Breakdown ACCELERATING - Mom:{momentum:.6f} ROC:{roc:.2f}%'
                        }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class CriticalMassConvergence(BaseStrategy):
    """
    ULTRA ENTRY 3: Critical Mass Convergence
    
    Wenn VIELE Indikatoren zur gleichen Zeit EXTREM werden,
    folgt fast IMMER ein 17%+ Move!
    """
    def __init__(self, config, logger):
        super().__init__("Critical_Mass_Convergence", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 20:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            extreme_signals = []
            
            # Sammle EXTREME Signale
            rsi = indicators.get('rsi_14', 50)
            if rsi < 20:
                extreme_signals.append('rsi_extreme_low')
            elif rsi > 80:
                extreme_signals.append('rsi_extreme_high')
            
            stoch_k = indicators.get('stoch_k', 50)
            if stoch_k < 10:
                extreme_signals.append('stoch_extreme_low')
            elif stoch_k > 90:
                extreme_signals.append('stoch_extreme_high')
            
            williams_r = ExtendedIndicators.williams_r(df)
            if williams_r < -95:
                extreme_signals.append('wr_extreme_low')
            elif williams_r > -5:
                extreme_signals.append('wr_extreme_high')
            
            cci = indicators.get('cci', 0)
            if abs(cci) > 150:
                extreme_signals.append('cci_extreme')
            
            roc = ExtendedIndicators.roc(df)
            if abs(roc) > 5:
                extreme_signals.append('roc_extreme')
            
            # Z√§hle Extreme
            bullish_signals = sum(1 for s in extreme_signals if 'low' in s)
            bearish_signals = sum(1 for s in extreme_signals if 'high' in s)
            
            # Critical Mass: 3+ Extreme Signale in gleiche Richtung
            if bullish_signals >= 3:
                return {
                    'signal': 'long',
                    'strength': min(bullish_signals / 5, 1),
                    'entry_reason': f'CRITICAL MASS {bullish_signals}/5 Extreme LOW signals - 17%+ Move incoming!'
                }
            
            if bearish_signals >= 3:
                return {
                    'signal': 'short',
                    'strength': min(bearish_signals / 5, 1),
                    'entry_reason': f'CRITICAL MASS {bearish_signals}/5 Extreme HIGH signals - 17%+ Move incoming!'
                }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


class FuturesPredictiveWaveForm(BaseStrategy):
    """
    ULTRA ENTRY 4: Futures Predictive Wave Form
    
    Diese Strategie basiert auf der Beobachtung, dass Futures
    oft 3-5 Candles VOR Spot bewegen. Wenn du die Futures-Pattern
    erkennst, kannst du den Spot-Move vorhersagen!
    """
    def __init__(self, config, logger):
        super().__init__("Futures_Predictive_Wave", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 25:
            return {'signal': 'neutral', 'strength': 0}
        
        try:
            # Simuliere Futures-Pattern durch √§ltere Candles
            # (In echtem Trading w√ºrdest du echte Futures-Daten nutzen)
            
            # Futures "Preview" - schaue 5 Candles zur√ºck
            preview_high = df['high'].iloc[-10:-5].max()
            preview_low = df['low'].iloc[-10:-5].min()
            preview_close = df['close'].iloc[-5]
            
            current_price = df['close'].iloc[-1]
            
            # Wenn Futures hochging und Spot folgt jetzt -> LONG
            if preview_high > preview_low and preview_close > (preview_high + preview_low) / 2:
                if current_price < preview_high:  # Spot hat noch aufzuholen
                    return {
                        'signal': 'long',
                        'strength': 0.88,
                        'entry_reason': f'Futures_Preview Bullish - Spot catching up to Futures'
                    }
            
            # Wenn Futures runterging und Spot folgt jetzt -> SHORT
            if preview_high > preview_low and preview_close < (preview_high + preview_low) / 2:
                if current_price > preview_low:
                    return {
                        'signal': 'short',
                        'strength': 0.88,
                        'entry_reason': f'Futures_Preview Bearish - Spot catching down to Futures'
                    }
        except:
            pass
        
        return {'signal': 'neutral', 'strength': 0}


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class QuantumTripleConfluence(BaseStrategy):
    """
    üåü MAGISCHE KOMBINATION 1: Quantum Triple Confluence
    
    Kombiniert:
    1. Hurst Exponent (Trend-Persistenz)
    2. Order Flow Imbalance
    3. Institutional Footprint
    
    Nur traden wenn ALLE DREI √ºbereinstimmen!
    """
    def __init__(self, config, logger):
        super().__init__("Quantum_Triple", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 50:
            return {'signal': 'neutral', 'strength': 0}
        
        signals = []
        
        # 1. Hurst Signal
        close = df['close'].values
        hurst = self._quick_hurst(close)
        
        if hurst > 0.6:
            trend_dir = 1 if close[-1] > close[-10] else -1
            signals.append(('hurst', trend_dir, hurst - 0.5))
        elif hurst < 0.4:
            trend_dir = -1 if close[-1] > np.mean(close[-20:]) else 1
            signals.append(('hurst', trend_dir, 0.5 - hurst))
        
        # 2. Order Flow Signal
        imbalance = ob.get('imbalance', 1)
        if imbalance > 1.3:
            signals.append(('orderflow', 1, (imbalance - 1) / 2))
        elif imbalance < 0.77:
            signals.append(('orderflow', -1, (1 - imbalance) / 2))
        
        # 3. Volume/Price Relationship (Institutional Proxy)
        vol_trend = df['volume'].tail(5).mean() / df['volume'].tail(20).mean()
        price_trend = (df['close'].iloc[-1] - df['close'].iloc[-5]) / df['close'].iloc[-5]
        
        if vol_trend > 1.2 and price_trend > 0.005:
            signals.append(('institutional', 1, vol_trend - 1))
        elif vol_trend > 1.2 and price_trend < -0.005:
            signals.append(('institutional', -1, vol_trend - 1))
        
        # Confluence Check
        if len(signals) >= 3:
            directions = [s[1] for s in signals]
            if all(d == 1 for d in directions):
                avg_strength = np.mean([s[2] for s in signals])
                return {
                    'signal': 'long',
                    'strength': min(avg_strength + 0.3, 1),
                    'confluence': 'triple',
                    'components': [s[0] for s in signals]
                }
            elif all(d == -1 for d in directions):
                avg_strength = np.mean([s[2] for s in signals])
                return {
                    'signal': 'short',
                    'strength': min(avg_strength + 0.3, 1),
                    'confluence': 'triple',
                    'components': [s[0] for s in signals]
                }
        
        return {'signal': 'neutral', 'strength': 0}
    
    def _quick_hurst(self, data):
        """Schnelle Hurst-Approximation"""
        if len(data) < 20:
            return 0.5
        
        returns = np.diff(np.log(data + 1e-10))
        
        # Varianz-Ratio als Hurst-Proxy
        var_1 = np.var(returns)
        var_10 = np.var(returns[::10]) if len(returns) >= 10 else var_1
        
        if var_1 > 0:
            ratio = var_10 / var_1
            hurst = 0.5 + np.log(ratio) / (2 * np.log(10))
            return max(0, min(1, hurst))
        
        return 0.5


class SmartMoneyDivergenceMatrix(BaseStrategy):
    """
    üåü MAGISCHE KOMBINATION 2: Smart Money Divergence Matrix
    
    Kombiniert:
    1. Smart Money Flow (CMF + AD Line)
    2. Hidden Divergences
    3. Liquidation Zone Proximity
    
    EXTREM pr√§zise f√ºr gro√üe Moves!
    """
    def __init__(self, config, logger):
        super().__init__("SmartMoney_Matrix", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        score = 0
        reasons = []
        
        # 1. Smart Money Flow
        cmf = self._calculate_cmf(df)
        if cmf > 0.1:
            score += 1
            reasons.append(f'CMF bullish ({cmf:.2f})')
        elif cmf < -0.1:
            score -= 1
            reasons.append(f'CMF bearish ({cmf:.2f})')
        
        # 2. Hidden Divergence Check (RSI)
        rsi = indicators.get('rsi_14', 50)
        price_trend = df['close'].iloc[-1] > df['close'].iloc[-10]
        
        if price_trend and rsi < 45:
            score += 1
            reasons.append('Hidden Bullish Divergence')
        elif not price_trend and rsi > 55:
            score -= 1
            reasons.append('Hidden Bearish Divergence')
        
        # 3. Proximity zu Support (vereinfacht)
        support = df['low'].tail(20).min()
        resistance = df['high'].tail(20).max()
        current = df['close'].iloc[-1]
        
        range_position = (current - support) / (resistance - support) if resistance > support else 0.5
        
        if range_position < 0.3:
            score += 0.5
            reasons.append('Near Support')
        elif range_position > 0.7:
            score -= 0.5
            reasons.append('Near Resistance')
        
        # Signal
        if score >= 2:
            return {
                'signal': 'long',
                'strength': min(score / 3, 1),
                'matrix_score': score,
                'reasons': reasons
            }
        elif score <= -2:
            return {
                'signal': 'short',
                'strength': min(abs(score) / 3, 1),
                'matrix_score': score,
                'reasons': reasons
            }
        
        return {'signal': 'neutral', 'strength': 0}
    
    def _calculate_cmf(self, df, period=20):
        """Chaikin Money Flow"""
        if len(df) < period:
            return 0
        
        high = df['high'].values[-period:]
        low = df['low'].values[-period:]
        close = df['close'].values[-period:]
        volume = df['volume'].values[-period:]
        
        mfm = np.where(
            high != low,
            ((close - low) - (high - close)) / (high - low),
            0
        )
        
        mfv = mfm * volume
        return np.sum(mfv) / np.sum(volume) if np.sum(volume) > 0 else 0


class UltimateRegimeDetector(BaseStrategy):
    """
    üåü MAGISCHE KOMBINATION 3: Ultimate Regime Detector
    
    Kombiniert:
    1. Fractal Dimension (Markt-Komplexit√§t)
    2. Entropy (Unsicherheit)
    3. Volatility Regime
    4. Momentum Regime
    
    Erkennt WELCHES Regime der Markt gerade hat und tradet entsprechend!
    """
    def __init__(self, config, logger):
        super().__init__("Regime_Detector", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 50:
            return {'signal': 'neutral', 'strength': 0}
        
        close = df['close'].values
        
        # 1. Fractal Dimension
        fd = self._calc_fractal_dim(close)
        
        # 2. Entropy
        entropy = self._calc_entropy(close)
        
        # 3. Volatility Regime
        vol = np.std(np.diff(np.log(close + 1e-10)))
        vol_percentile = self._get_vol_percentile(vol, df)
        
        # 4. Momentum
        momentum = (close[-1] - close[-10]) / close[-10]
        
        # Regime Classification
        if fd < 1.3 and entropy < 0.5 and vol_percentile < 50:
            regime = 'STRONG_TREND'
            # Folge dem Trend
            signal = 'long' if momentum > 0 else 'short'
            strength = 0.9
        elif fd > 1.7 and entropy > 0.7:
            regime = 'CHAOTIC'
            # Mean Reversion
            mean = np.mean(close[-20:])
            signal = 'long' if close[-1] < mean else 'short'
            strength = 0.6
        elif vol_percentile > 80:
            regime = 'HIGH_VOLATILITY'
            # Vorsichtig mit Trend
            signal = 'long' if momentum > 0.02 else ('short' if momentum < -0.02 else 'neutral')
            strength = 0.5
        elif vol_percentile < 20:
            regime = 'LOW_VOLATILITY'
            # Breakout erwarten
            bb_width = indicators.get('bb_width', 0.1)
            if bb_width < 0.02:
                signal = 'long' if close[-1] > close[-5] else 'short'
                strength = 0.7
            else:
                signal = 'neutral'
                strength = 0
        else:
            regime = 'NORMAL'
            signal = 'neutral'
            strength = 0
        
        return {
            'signal': signal,
            'strength': strength,
            'regime': regime,
            'fractal_dim': fd,
            'entropy': entropy,
            'vol_percentile': vol_percentile,
            'momentum': momentum
        }
    
    def _calc_fractal_dim(self, data):
        """Schnelle Fractal Dimension"""
        if len(data) < 20:
            return 1.5
        
        data_norm = (data - np.min(data)) / (np.max(data) - np.min(data) + 1e-10)
        
        changes = 0
        for i in range(1, len(data_norm)):
            changes += abs(data_norm[i] - data_norm[i-1])
        
        return 1 + changes / 2
    
    def _calc_entropy(self, data):
        """Schnelle Entropy"""
        returns = np.diff(data) / data[:-1]
        hist, _ = np.histogram(returns, bins=10, density=True)
        hist = hist[hist > 0]
        return -np.sum(hist * np.log2(hist + 1e-10)) / np.log2(10)
    
    def _get_vol_percentile(self, current_vol, df):
        """Volatility Percentile"""
        if len(df) < 50:
            return 50
        
        historical_vols = []
        for i in range(20, len(df)):
            segment = df['close'].iloc[i-20:i].values
            vol = np.std(np.diff(np.log(segment + 1e-10)))
            historical_vols.append(vol)
        
        if not historical_vols:
            return 50
        
        percentile = sum(1 for v in historical_vols if v < current_vol) / len(historical_vols) * 100
        return percentile


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Weitere 8 Genius Strategien
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class VolumeProfileStrategy(BaseStrategy):
    """GENIUS 4: Volume Profile POC Strategy"""
    def __init__(self, config, logger):
        super().__init__("Volume_Profile", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 50:
            return {'signal': 'neutral', 'strength': 0}
        
        # Finde Point of Control (h√∂chstes Volumen-Preisniveau)
        price_volume = {}
        for i in range(len(df)):
            price_bin = round(df['close'].iloc[i], 1)
            price_volume[price_bin] = price_volume.get(price_bin, 0) + df['volume'].iloc[i]
        
        poc = max(price_volume.items(), key=lambda x: x[1])[0]
        current = df['close'].iloc[-1]
        
        distance = (current - poc) / poc
        
        if distance < -0.02:  # Unter POC
            return {'signal': 'long', 'strength': 0.7, 'poc': poc}
        elif distance > 0.02:  # √úber POC
            return {'signal': 'short', 'strength': 0.7, 'poc': poc}
        
        return {'signal': 'neutral', 'strength': 0}


class OrderBlockStrategy(BaseStrategy):
    """GENIUS 5: Order Block Strategy"""
    def __init__(self, config, logger):
        super().__init__("Order_Block", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 20:
            return {'signal': 'neutral', 'strength': 0}
        
        # Finde Order Blocks (letzte Kerze vor impulsiver Bewegung)
        for i in range(-15, -3):
            # Bullish Order Block
            if df['close'].iloc[i] < df['open'].iloc[i]:  # Rote Kerze
                # Gefolgt von starkem Up-Move
                if df['close'].iloc[i+1] > df['high'].iloc[i]:
                    block_top = df['high'].iloc[i]
                    block_bottom = df['low'].iloc[i]
                    current = df['close'].iloc[-1]
                    
                    if block_bottom <= current <= block_top:
                        return {'signal': 'long', 'strength': 0.8, 'order_block': 'bullish'}
            
            # Bearish Order Block
            if df['close'].iloc[i] > df['open'].iloc[i]:  # Gr√ºne Kerze
                if df['close'].iloc[i+1] < df['low'].iloc[i]:
                    block_top = df['high'].iloc[i]
                    block_bottom = df['low'].iloc[i]
                    current = df['close'].iloc[-1]
                    
                    if block_bottom <= current <= block_top:
                        return {'signal': 'short', 'strength': 0.8, 'order_block': 'bearish'}
        
        return {'signal': 'neutral', 'strength': 0}


class BreakoutVolumeConfirmation(BaseStrategy):
    """GENIUS 6: Breakout mit Volume Confirmation"""
    def __init__(self, config, logger):
        super().__init__("Breakout_Volume", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        high_20 = df['high'].tail(20).max()
        low_20 = df['low'].tail(20).min()
        current = df['close'].iloc[-1]
        current_vol = df['volume'].iloc[-1]
        avg_vol = df['volume'].tail(20).mean()
        
        # Breakout mit Volume
        if current > high_20 and current_vol > avg_vol * 2:
            return {'signal': 'long', 'strength': 0.85, 'breakout': 'upside'}
        elif current < low_20 and current_vol > avg_vol * 2:
            return {'signal': 'short', 'strength': 0.85, 'breakout': 'downside'}
        
        return {'signal': 'neutral', 'strength': 0}


class RelativeStrengthDualMomentum(BaseStrategy):
    """GENIUS 7: Dual Momentum Strategy"""
    def __init__(self, config, logger):
        super().__init__("Dual_Momentum", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        # Absolute Momentum
        abs_momentum = (df['close'].iloc[-1] - df['close'].iloc[-20]) / df['close'].iloc[-20]
        
        # Relative Momentum (vs SMA)
        sma_20 = df['close'].tail(20).mean()
        rel_momentum = (df['close'].iloc[-1] - sma_20) / sma_20
        
        # Kombiniert
        if abs_momentum > 0.02 and rel_momentum > 0.01:
            return {'signal': 'long', 'strength': min((abs_momentum + rel_momentum) * 10, 1)}
        elif abs_momentum < -0.02 and rel_momentum < -0.01:
            return {'signal': 'short', 'strength': min(abs(abs_momentum + rel_momentum) * 10, 1)}
        
        return {'signal': 'neutral', 'strength': 0}


class KeltnerChannelStrategy(BaseStrategy):
    """GENIUS 8: Keltner Channel Squeeze"""
    def __init__(self, config, logger):
        super().__init__("Keltner_Squeeze", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 30:
            return {'signal': 'neutral', 'strength': 0}
        
        # Keltner Channel
        ema_20 = indicators.get('ema_21', df['close'].iloc[-1])
        atr = indicators.get('atr_14', 0)
        
        keltner_upper = ema_20 + atr * 2
        keltner_lower = ema_20 - atr * 2
        
        # Bollinger Bands
        bb_upper = indicators.get('bb_upper', keltner_upper)
        bb_lower = indicators.get('bb_lower', keltner_lower)
        
        current = df['close'].iloc[-1]
        
        # Squeeze = BB inside Keltner
        squeeze = bb_upper < keltner_upper and bb_lower > keltner_lower
        
        if squeeze:
            # Warte auf Breakout
            if current > bb_upper:
                return {'signal': 'long', 'strength': 0.75, 'squeeze_breakout': True}
            elif current < bb_lower:
                return {'signal': 'short', 'strength': 0.75, 'squeeze_breakout': True}
        
        return {'signal': 'neutral', 'strength': 0}


class VWAPBandStrategy(BaseStrategy):
    """GENIUS 9: VWAP Bands Reversion"""
    def __init__(self, config, logger):
        super().__init__("VWAP_Bands", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        vwap = indicators.get('vwap', 0)
        
        if vwap == 0:
            return {'signal': 'neutral', 'strength': 0}
        
        # VWAP Bands (1 und 2 Std)
        std = df['close'].tail(20).std()
        vwap_upper_1 = vwap + std
        vwap_lower_1 = vwap - std
        vwap_upper_2 = vwap + std * 2
        vwap_lower_2 = vwap - std * 2
        
        current = df['close'].iloc[-1]
        
        # Mean Reversion bei Extremen
        if current < vwap_lower_2:
            return {'signal': 'long', 'strength': 0.8, 'vwap_band': -2}
        elif current < vwap_lower_1:
            return {'signal': 'long', 'strength': 0.6, 'vwap_band': -1}
        elif current > vwap_upper_2:
            return {'signal': 'short', 'strength': 0.8, 'vwap_band': 2}
        elif current > vwap_upper_1:
            return {'signal': 'short', 'strength': 0.6, 'vwap_band': 1}
        
        return {'signal': 'neutral', 'strength': 0}


class RSIMomentumDivergence(BaseStrategy):
    """GENIUS 10: RSI Momentum Divergence"""
    def __init__(self, config, logger):
        super().__init__("RSI_Mom_Div", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        rsi = indicators.get('rsi_14', 50)
        rsi_7 = indicators.get('rsi_7', 50)
        
        # RSI Momentum = Differenz zwischen schnellem und langsamem RSI
        rsi_momentum = rsi_7 - rsi
        
        if rsi < 35 and rsi_momentum > 5:
            return {'signal': 'long', 'strength': 0.7, 'rsi_momentum': rsi_momentum}
        elif rsi > 65 and rsi_momentum < -5:
            return {'signal': 'short', 'strength': 0.7, 'rsi_momentum': rsi_momentum}
        
        return {'signal': 'neutral', 'strength': 0}


class MultiTimeframeTrend(BaseStrategy):
    """GENIUS 11: Multi-Timeframe Trend Alignment"""
    def __init__(self, config, logger):
        super().__init__("MTF_Trend", config, logger)
        self.requires_agreement = False
    
    def analyze(self, df, indicators, ob):
        if len(df) < 100:
            return {'signal': 'neutral', 'strength': 0}
        
        # Simuliere verschiedene Timeframes durch unterschiedliche Perioden
        trend_5 = 1 if df['close'].iloc[-1] > df['close'].iloc[-5] else -1
        trend_15 = 1 if df['close'].iloc[-1] > df['close'].iloc[-15] else -1
        trend_50 = 1 if df['close'].iloc[-1] > df['close'].iloc[-50] else -1
        
        # Alignment
        total_trend = trend_5 + trend_15 + trend_50
        
        if total_trend == 3:
            return {'signal': 'long', 'strength': 0.85, 'mtf_alignment': 'all_bullish'}
        elif total_trend == -3:
            return {'signal': 'short', 'strength': 0.85, 'mtf_alignment': 'all_bearish'}
        elif total_trend >= 2:
            return {'signal': 'long', 'strength': 0.6, 'mtf_alignment': 'mostly_bullish'}
        elif total_trend <= -2:
            return {'signal': 'short', 'strength': 0.6, 'mtf_alignment': 'mostly_bearish'}
        
        return {'signal': 'neutral', 'strength': 0}


print("=" * 80)
print("PROMETHEUS BOT - Part 2A loaded successfully!")
print("=" * 80)
print("\nPart 2A enth√§lt:")
print("  ‚úì 5 GENIALE NEUE FEATURES:")
print("    - Liquidation Cascade Detector")
print("    - Smart Money Flow Tracker")
print("    - Market Manipulation Shield")
print("    - Institutional Footprint Analyzer")
print("    - Quantum Momentum Predictor")
print("  ‚úì 23 Standard Strategien")
print("  ‚úì 3 Ultra Mega Advanced Strategien")
print("  ‚úì 5 GEHEIME Strategien (0.0001%)")
print("  ‚úì 3 Magische Kombinationen")
print("  ‚úì 8 weitere Genius Strategien")
print("\nSchreibe 'weiter mit Teil 2B' f√ºr die Systeme & Dashboard!")
print("=" * 80)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PROMETHEUS ULTRA TRADING BOT - TEIL 2B
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SYSTEME, MULTI-BRAIN, POSITION MANAGER, DASHBOARD, MAIN LOOP
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# STRATEGY MANAGER - Verwaltet alle Strategien
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class StrategyManager:
    """Verwaltet alle 42 Strategien"""
    
    def __init__(self, config: Config, logger: Logger):
        self.config = config
        self.logger = logger
        self.strategies = self._initialize_strategies()
        self.logger.log(f"Initialized {len(self.strategies)} strategies", "INFO")
    
    def _initialize_strategies(self) -> dict:
        """Initialisiere alle Strategien"""
        strategies = {}
        
        # 23 Standard Strategien (brauchen Agreement)
        standard = [
            RSIOversoldOverbought, MACDCrossover, BollingerBandSqueeze,
            VolumeSpikeDetection, EMACrossover, StochasticRSI,
            ADXTrendStrength, IchimokuTKCross, VWAPDeviation,
            FibonacciRetracement, OrderBookImbalance, FundingRateArbitrage,
            OpenInterestChange, SupportResistanceProximity, CandlestickPatterns,
            MarketStructureBreak, FairValueGap, MovingAverageRibbon,
            MomentumDivergence, CCIExtreme, MFIDivergence,
            OBVTrendConfirmation, ATRBreakout
        ]
        
        for strat_class in standard:
            strat = strat_class(self.config, self.logger)
            strategies[strat.name] = strat
        
        # 3 Ultra Mega Advanced (kein Agreement)
        ultra = [
            FractalDimensionBreakout, EntropyBasedReversal, NeuralMomentumConfluence
        ]
        
        for strat_class in ultra:
            strat = strat_class(self.config, self.logger)
            strategies[strat.name] = strat
        
        # 5 Geheime Strategien (kein Agreement)
        secret = [
            DarkPoolFlowReversal, StopHuntSniper, LiquidityVoidFiller,
            WhaleExhaustionDetector, HiddenDivergenceMatrix
        ]
        
        for strat_class in secret:
            strat = strat_class(self.config, self.logger)
            strategies[strat.name] = strat
        
        # 3 Magische Kombinationen (kein Agreement)
        magic = [
            QuantumTripleConfluence, SmartMoneyDivergenceMatrix, UltimateRegimeDetector
        ]
        
        for strat_class in magic:
            strat = strat_class(self.config, self.logger)
            strategies[strat.name] = strat
        
        # 8 weitere Genius (kein Agreement)
        genius = [
            VolumeProfileStrategy, OrderBlockStrategy, BreakoutVolumeConfirmation,
            RelativeStrengthDualMomentum, KeltnerChannelStrategy, VWAPBandStrategy,
            RSIMomentumDivergence, MultiTimeframeTrend
        ]
        
        for strat_class in genius:
            strat = strat_class(self.config, self.logger)
            strategies[strat.name] = strat
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # 5 NEUE CUSTOM-KOMBINATIONSSTATEGIEN (aus den 23 kombiniert, kein Agreement)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        custom_combos = [
            FisherEMAMACDCombo, RSIStochasticDMICombo, BBWilliamsROCCombo,
            CCI_TRIX_SupertrendCombo, ADXMomentumLinRegCombo
        ]
        
        for strat_class in custom_combos:
            strat = strat_class(self.config, self.logger)
            strategies[strat.name] = strat
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # 8 HYDRA SECRETS - Die 0.00001% Strategien!
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        hydra_secrets = [
            QuantumLiquidationCascade, SmartMoneyFootprintAnalysis, 
            CharacteristicVolatilityRegime, HiddenOrderBlockDetector,
            MultiTimeframeConfluenceResonance, AccelerationTrapDetector,
            PulseOscillationReversal, InstitutionalWaveMarking
        ]
        
        for strat_class in hydra_secrets:
            strat = strat_class(self.config, self.logger)
            strategies[strat.name] = strat
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # 4 ULTRA ENTRY-POINT STRATEGIEN - 17%+ Moves mit 20x Hebel!
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        ultra_entries = [
            ExtremeMicrostructurePulse, QuantumBreakoutAcceleration,
            CriticalMassConvergence, FuturesPredictiveWaveForm
        ]
        
        for strat_class in ultra_entries:
            strat = strat_class(self.config, self.logger)
            strategies[strat.name] = strat
        
        return strategies
    
    def get_all_signals(self, df: pd.DataFrame, indicators: dict, 
                       orderbook_analysis: dict) -> list:
        """Hole Signale von allen Strategien"""
        signals = []
        
        for name, strategy in self.strategies.items():
            try:
                signal = strategy.get_signal(df, indicators, orderbook_analysis)
                signals.append(signal)
            except Exception as e:
                self.logger.log(f"Strategy {name} failed: {e}", "ERROR", True)
        
        return signals
    
    def get_agreement_strategies(self) -> list:
        """Strategien die Agreement brauchen"""
        return [s for s in self.strategies.values() if s.requires_agreement]
    
    def get_standalone_strategies(self) -> list:
        """Strategien die kein Agreement brauchen"""
        return [s for s in self.strategies.values() if not s.requires_agreement]


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
# ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
# ‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
#  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
#   ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
#                              SYSTEM 1: VIPER SCALPER
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ViperScalper:
    """
    SYSTEM 1: VIPER SCALPER
    - Aggressive Scalping
    - 20x Leverage
    - 30 Sekunden - 5 Minuten Haltezeit
    - Nutzt schnelle Indikatoren
    """
    
    def __init__(self, config: Config, logger: Logger, exchange: ExchangeConnector,
                 strategy_manager: StrategyManager, ranking_system: StrategyRankingSystem):
        self.config = config
        self.logger = logger
        self.exchange = exchange
        self.strategies = strategy_manager
        self.ranking = ranking_system
        self.name = "VIPER"
        self.leverage = config.VIPER_LEVERAGE
        
        # Viper-spezifische Strategien (schnelle)
        self.viper_strategies = [
            'RSI_Extreme', 'MACD_Cross', 'Volume_Spike', 'EMA_Cross',
            'Stoch_RSI', 'BB_Squeeze', 'ATR_Breakout', 'OB_Imbalance'
        ]
    
    def scan_for_entry(self, symbol: str, df: pd.DataFrame, indicators: dict,
                      orderbook_analysis: dict) -> dict:
        """Suche nach Scalping Entry"""
        
        # Pr√ºfe Mindest-Volatilit√§t
        volatility = indicators.get('volatility', 0)
        if volatility < self.config.VIPER_MIN_VOLATILITY:
            return {'entry': False, 'reason': 'Low volatility'}
        
        # Pr√ºfe Volume
        if len(df) > 0:
            vol_24h = df['volume'].sum() * df['close'].iloc[-1]
            if vol_24h < self.config.VIPER_MIN_VOLUME_24H:
                return {'entry': False, 'reason': 'Low volume'}
        
        # Sammle Signale von Viper-Strategien
        signals = []
        for strat_name in self.viper_strategies:
            if strat_name in self.strategies.strategies:
                strat = self.strategies.strategies[strat_name]
                signal = strat.get_signal(df, indicators, orderbook_analysis)
                
                if signal['signal'] != 'neutral':
                    # Pr√ºfe Ranking
                    if self.ranking.can_trade(strat_name):
                        signals.append(signal)
        
        if not signals:
            return {'entry': False, 'reason': 'No signals'}
        
        # Z√§hle Agreement
        long_signals = [s for s in signals if s['signal'] == 'long']
        short_signals = [s for s in signals if s['signal'] == 'short']
        
        # F√ºr Viper: Mindestens 4 Signale m√ºssen √ºbereinstimmen
        min_agreement = 4
        
        if len(long_signals) >= min_agreement:
            avg_strength = np.mean([s['strength'] for s in long_signals])
            best_strategy = max(long_signals, key=lambda x: x['strength'])
            
            return {
                'entry': True,
                'side': 'buy',
                'strength': avg_strength,
                'agreement': len(long_signals),
                'strategy': best_strategy['strategy_name'],
                'strategies_agreed': [s['strategy_name'] for s in long_signals],
                'system': self.name,
                'leverage': self.leverage
            }
        
        elif len(short_signals) >= min_agreement:
            avg_strength = np.mean([s['strength'] for s in short_signals])
            best_strategy = max(short_signals, key=lambda x: x['strength'])
            
            return {
                'entry': True,
                'side': 'sell',
                'strength': avg_strength,
                'agreement': len(short_signals),
                'strategy': best_strategy['strategy_name'],
                'strategies_agreed': [s['strategy_name'] for s in short_signals],
                'system': self.name,
                'leverage': self.leverage
            }
        
        return {'entry': False, 'reason': f'Not enough agreement (L:{len(long_signals)}/S:{len(short_signals)})'}
    
    def calculate_exit(self, position: dict, current_price: float, 
                      entry_time: datetime) -> dict:
        """Berechne Exit f√ºr Scalping Position"""
        
        entry_price = position['entry_price']
        side = position['side']
        
        # PnL Berechnung
        if side == 'buy':
            pnl_percent = (current_price - entry_price) / entry_price * 100 * self.leverage
        else:
            pnl_percent = (entry_price - current_price) / entry_price * 100 * self.leverage
        
        # Haltezeit
        hold_time = (datetime.now() - entry_time).total_seconds()
        
        # Exit Bedingungen
        exit_signal = {
            'exit': False,
            'reason': None,
            'pnl_percent': pnl_percent
        }
        
        # 1. Take Profit
        if pnl_percent >= self.config.TAKE_PROFIT_1_PERCENT:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'TP1 reached ({pnl_percent:.2f}%)'
        
        # 2. Stop Loss
        elif pnl_percent <= -self.config.HARD_STOP_LOSS_PERCENT:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'SL hit ({pnl_percent:.2f}%)'
        
        # 3. Max Hold Time
        elif hold_time > self.config.VIPER_MAX_HOLD_TIME_SECONDS:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'Max hold time ({hold_time:.0f}s)'
        
        # 4. Trailing Stop
        elif pnl_percent >= self.config.TRAILING_STOP_ACTIVATION:
            highest_pnl = position.get('highest_pnl', pnl_percent)
            if pnl_percent < highest_pnl - self.config.TRAILING_STOP_DISTANCE:
                exit_signal['exit'] = True
                exit_signal['reason'] = f'Trailing stop ({pnl_percent:.2f}% from {highest_pnl:.2f}%)'
        
        return exit_signal


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù 
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
# ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù 
#                              SYSTEM 2: PHOENIX SWING
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class PhoenixSwing:
    """
    SYSTEM 2: PHOENIX SWING
    - Swing Trading
    - 5-10x Leverage (adaptiv)
    - 1-24 Stunden Haltezeit
    - Multi-Timeframe Analysis
    """
    
    def __init__(self, config: Config, logger: Logger, exchange: ExchangeConnector,
                 strategy_manager: StrategyManager, ranking_system: StrategyRankingSystem):
        self.config = config
        self.logger = logger
        self.exchange = exchange
        self.strategies = strategy_manager
        self.ranking = ranking_system
        self.name = "PHOENIX"
        self.leverage = config.PHOENIX_LEVERAGE
        
        # Phoenix-spezifische Strategien (Trend-following)
        self.phoenix_strategies = [
            'ADX_Trend', 'Ichimoku_TK', 'MA_Ribbon', 'Fib_Retrace',
            'MSB', 'MTF_Trend', 'Dual_Momentum', 'Volume_Profile'
        ]
    
    def scan_for_entry(self, symbol: str, df: pd.DataFrame, indicators: dict,
                      orderbook_analysis: dict) -> dict:
        """Suche nach Swing Entry"""
        
        # Pr√ºfe Trend-St√§rke
        adx = indicators.get('adx', 0)
        if adx < self.config.PHOENIX_MIN_TREND_STRENGTH:
            return {'entry': False, 'reason': f'Weak trend (ADX: {adx:.1f})'}
        
        # Sammle Signale
        signals = []
        for strat_name in self.phoenix_strategies:
            if strat_name in self.strategies.strategies:
                strat = self.strategies.strategies[strat_name]
                signal = strat.get_signal(df, indicators, orderbook_analysis)
                
                if signal['signal'] != 'neutral':
                    if self.ranking.can_trade(strat_name):
                        signals.append(signal)
        
        # Auch Standalone-Strategien pr√ºfen
        for strat in self.strategies.get_standalone_strategies():
            if strat.name not in self.phoenix_strategies:
                signal = strat.get_signal(df, indicators, orderbook_analysis)
                if signal['signal'] != 'neutral' and signal['strength'] > 0.7:
                    signals.append(signal)
        
        if not signals:
            return {'entry': False, 'reason': 'No signals'}
        
        # F√ºr Phoenix: Mindestens 3 Signale
        long_signals = [s for s in signals if s['signal'] == 'long']
        short_signals = [s for s in signals if s['signal'] == 'short']
        
        min_agreement = 3
        
        # Adaptive Leverage basierend auf Signal-St√§rke
        def calc_leverage(signal_strength, agreement):
            base = self.config.PHOENIX_LEVERAGE
            if signal_strength > 0.8 and agreement >= 5:
                return min(base, 10)
            elif signal_strength > 0.6:
                return min(base, 7)
            return 5
        
        if len(long_signals) >= min_agreement:
            avg_strength = np.mean([s['strength'] for s in long_signals])
            adaptive_lev = calc_leverage(avg_strength, len(long_signals))
            best_strategy = max(long_signals, key=lambda x: x['strength'])
            
            return {
                'entry': True,
                'side': 'buy',
                'strength': avg_strength,
                'agreement': len(long_signals),
                'strategy': best_strategy['strategy_name'],
                'strategies_agreed': [s['strategy_name'] for s in long_signals],
                'system': self.name,
                'leverage': adaptive_lev
            }
        
        elif len(short_signals) >= min_agreement:
            avg_strength = np.mean([s['strength'] for s in short_signals])
            adaptive_lev = calc_leverage(avg_strength, len(short_signals))
            best_strategy = max(short_signals, key=lambda x: x['strength'])
            
            return {
                'entry': True,
                'side': 'sell',
                'strength': avg_strength,
                'agreement': len(short_signals),
                'strategy': best_strategy['strategy_name'],
                'strategies_agreed': [s['strategy_name'] for s in short_signals],
                'system': self.name,
                'leverage': adaptive_lev
            }
        
        return {'entry': False, 'reason': f'Not enough agreement'}
    
    def calculate_exit(self, position: dict, current_price: float,
                      entry_time: datetime, indicators: dict) -> dict:
        """Berechne Exit f√ºr Swing Position"""
        
        entry_price = position['entry_price']
        side = position['side']
        leverage = position.get('leverage', self.leverage)
        
        # PnL
        if side == 'buy':
            pnl_percent = (current_price - entry_price) / entry_price * 100 * leverage
        else:
            pnl_percent = (entry_price - current_price) / entry_price * 100 * leverage
        
        hold_time_hours = (datetime.now() - entry_time).total_seconds() / 3600
        
        exit_signal = {
            'exit': False,
            'reason': None,
            'pnl_percent': pnl_percent
        }
        
        # 1. Take Profits (gestaffelt)
        if pnl_percent >= self.config.TAKE_PROFIT_3_PERCENT:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'TP3 reached ({pnl_percent:.2f}%)'
        
        # 2. Stop Loss
        elif pnl_percent <= -self.config.HARD_STOP_LOSS_PERCENT:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'SL hit ({pnl_percent:.2f}%)'
        
        # 3. Max Hold Time
        elif hold_time_hours > self.config.PHOENIX_MAX_HOLD_TIME_HOURS:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'Max hold time ({hold_time_hours:.1f}h)'
        
        # 4. Trend Reversal
        elif indicators:
            adx = indicators.get('adx', 0)
            trend = indicators.get('trend', 'sideways')
            
            if side == 'buy' and trend == 'down' and adx > 25:
                exit_signal['exit'] = True
                exit_signal['reason'] = 'Trend reversal detected'
            elif side == 'sell' and trend == 'up' and adx > 25:
                exit_signal['exit'] = True
                exit_signal['reason'] = 'Trend reversal detected'
        
        # 5. Trailing Stop
        if pnl_percent >= self.config.TRAILING_STOP_ACTIVATION * 1.5:
            highest_pnl = position.get('highest_pnl', pnl_percent)
            if pnl_percent < highest_pnl - self.config.TRAILING_STOP_DISTANCE * 1.5:
                exit_signal['exit'] = True
                exit_signal['reason'] = f'Trailing stop ({pnl_percent:.2f}%)'
        
        return exit_signal


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë  ‚ïö‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë    ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
# ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
#                              SYSTEM 3: HYDRA CONSENSUS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class HydraConsensus:
    """
    SYSTEM 3: HYDRA CONSENSUS
    - 31+ Strategien f√ºr Entry
    - Agreement-basiertes System
    - Standalone Genius-Strategien
    - Ranking-System integriert
    """
    
    def __init__(self, config: Config, logger: Logger, exchange: ExchangeConnector,
                 strategy_manager: StrategyManager, ranking_system: StrategyRankingSystem,
                 optimizer: StrategyOptimizer):
        self.config = config
        self.logger = logger
        self.exchange = exchange
        self.strategies = strategy_manager
        self.ranking = ranking_system
        self.optimizer = optimizer
        self.name = "HYDRA"
        self.leverage = config.HYDRA_LEVERAGE
    
    def scan_for_entry(self, symbol: str, df: pd.DataFrame, indicators: dict,
                      orderbook_analysis: dict) -> dict:
        """
        Scanne mit ALLEN Strategien
        
        2 Wege zum Entry:
        1. Agreement: 12+ Strategien stimmen √ºberein
        2. Standalone: Eine Genius-Strategie mit hoher Confidence
        """
        
        all_signals = self.strategies.get_all_signals(df, indicators, orderbook_analysis)
        
        # Teile in Agreement und Standalone
        agreement_signals = [s for s in all_signals if s.get('requires_agreement', True)]
        standalone_signals = [s for s in all_signals if not s.get('requires_agreement', True)]
        
        # === PATH 1: AGREEMENT-BASED ===
        long_agreement = [s for s in agreement_signals if s['signal'] == 'long']
        short_agreement = [s for s in agreement_signals if s['signal'] == 'short']
        
        min_agreement = self.config.HYDRA_MIN_AGREEMENT
        
        if len(long_agreement) >= min_agreement:
            # Pr√ºfe Ranking f√ºr beste Strategien
            valid_signals = []
            for sig in long_agreement:
                if self.ranking.can_trade(sig['strategy_name']):
                    valid_signals.append(sig)
            
            if len(valid_signals) >= min_agreement:
                avg_strength = np.mean([s['strength'] for s in valid_signals])
                best = max(valid_signals, key=lambda x: x['strength'])
                
                return {
                    'entry': True,
                    'side': 'buy',
                    'strength': avg_strength,
                    'agreement': len(valid_signals),
                    'strategy': best['strategy_name'],
                    'strategies_agreed': [s['strategy_name'] for s in valid_signals],
                    'system': self.name,
                    'leverage': self.leverage,
                    'entry_type': 'agreement'
                }
        
        if len(short_agreement) >= min_agreement:
            valid_signals = []
            for sig in short_agreement:
                if self.ranking.can_trade(sig['strategy_name']):
                    valid_signals.append(sig)
            
            if len(valid_signals) >= min_agreement:
                avg_strength = np.mean([s['strength'] for s in valid_signals])
                best = max(valid_signals, key=lambda x: x['strength'])
                
                return {
                    'entry': True,
                    'side': 'sell',
                    'strength': avg_strength,
                    'agreement': len(valid_signals),
                    'strategy': best['strategy_name'],
                    'strategies_agreed': [s['strategy_name'] for s in valid_signals],
                    'system': self.name,
                    'leverage': self.leverage,
                    'entry_type': 'agreement'
                }
        
        # === PATH 2: STANDALONE GENIUS ===
        if self.config.HYDRA_GENIUS_STRATEGIES_ENABLED:
            for sig in standalone_signals:
                if sig['signal'] != 'neutral' and sig['strength'] >= 0.7:
                    if self.ranking.can_trade(sig['strategy_name']):
                        
                        # Zus√§tzliche Validierung f√ºr Standalone
                        # Mindestens 3 andere Signale in gleiche Richtung
                        supporting = [
                            s for s in all_signals 
                            if s['signal'] == sig['signal'] and s != sig
                        ]
                        
                        if len(supporting) >= 3:
                            return {
                                'entry': True,
                                'side': 'buy' if sig['signal'] == 'long' else 'sell',
                                'strength': sig['strength'],
                                'agreement': 1 + len(supporting),
                                'strategy': sig['strategy_name'],
                                'strategies_agreed': [sig['strategy_name']] + [s['strategy_name'] for s in supporting[:5]],
                                'system': self.name,
                                'leverage': self.leverage,
                                'entry_type': 'standalone_genius'
                            }
        
        return {
            'entry': False, 
            'reason': f'Agreement: L={len(long_agreement)}/S={len(short_agreement)} (need {min_agreement})'
        }
    
    def calculate_exit(self, position: dict, current_price: float,
                      entry_time: datetime, df: pd.DataFrame, 
                      indicators: dict, orderbook_analysis: dict) -> dict:
        """
        Intelligenter Exit f√ºr Hydra
        - Nutzt Strategien f√ºr Exit-Timing
        - 1-30 Minuten Haltezeit
        """
        
        entry_price = position['entry_price']
        side = position['side']
        leverage = position.get('leverage', self.leverage)
        
        # PnL
        if side == 'buy':
            pnl_percent = (current_price - entry_price) / entry_price * 100 * leverage
        else:
            pnl_percent = (entry_price - current_price) / entry_price * 100 * leverage
        
        hold_time_seconds = (datetime.now() - entry_time).total_seconds()
        hold_time_minutes = hold_time_seconds / 60
        
        exit_signal = {
            'exit': False,
            'reason': None,
            'pnl_percent': pnl_percent
        }
        
        # 1. Hard Stop Loss (IMMER!)
        if pnl_percent <= -self.config.HARD_STOP_LOSS_PERCENT:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'HARD SL ({pnl_percent:.2f}%)'
            return exit_signal
        
        # 2. Take Profits
        if pnl_percent >= self.config.TAKE_PROFIT_2_PERCENT:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'TP2 ({pnl_percent:.2f}%)'
            return exit_signal
        
        # 3. Max Hold Time (30 min)
        if hold_time_minutes > 30:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'Max time ({hold_time_minutes:.1f}min)'
            return exit_signal
        
        # 4. Strategy-basierter Exit
        # Wenn Strategien jetzt GEGEN unsere Position signalisieren
        all_signals = self.strategies.get_all_signals(df, indicators, orderbook_analysis)
        
        opposite_signal = 'short' if side == 'buy' else 'long'
        opposite_count = sum(1 for s in all_signals if s['signal'] == opposite_signal)
        
        if opposite_count >= 10 and hold_time_minutes > 5:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'Strategy reversal ({opposite_count} opposite signals)'
            return exit_signal
        
        # 5. Trailing Stop nach TP1
        if pnl_percent >= self.config.TAKE_PROFIT_1_PERCENT:
            highest_pnl = position.get('highest_pnl', pnl_percent)
            trail_distance = self.config.TRAILING_STOP_DISTANCE
            
            if pnl_percent < highest_pnl - trail_distance:
                exit_signal['exit'] = True
                exit_signal['reason'] = f'Trailing ({pnl_percent:.2f}% from {highest_pnl:.2f}%)'
                return exit_signal
        
        # 6. Quick Scalp Exit (wenn wir schnell im Plus sind)
        if hold_time_minutes < 2 and pnl_percent >= 1.5:
            exit_signal['exit'] = True
            exit_signal['reason'] = f'Quick scalp ({pnl_percent:.2f}% in {hold_time_seconds:.0f}s)'
            return exit_signal
        
        return exit_signal


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë
# ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù
#                    MULTI-BRAIN ARCHITECTURE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class MultiBrainController:
    """
    Multi-Brain Controller
    - Koordiniert alle 3 Systeme
    - PRIORISIERT offene Positionen
    - Verhindert √úberlappungen
    - Managed Ressourcen
    """
    
    def __init__(self, config: Config, logger: Logger, exchange: ExchangeConnector,
                 viper: ViperScalper, phoenix: PhoenixSwing, hydra: HydraConsensus,
                 position_manager: 'PositionManager'):
        self.config = config
        self.logger = logger
        self.exchange = exchange
        self.viper = viper
        self.phoenix = phoenix
        self.hydra = hydra
        self.position_manager = position_manager
        
        # Task Queues f√ºr jedes "Gehirn"
        self.position_brain_queue = queue.PriorityQueue()  # H√∂chste Priorit√§t
        self.entry_brain_queue = queue.PriorityQueue()
        
        # Locks
        self.position_lock = threading.Lock()
        self.entry_lock = threading.Lock()
        
        # Status
        self.active = True
        self.entry_paused = False  # Flag um Entry Scanning zu pausieren (z.B. bei MAX_DRAWDOWN)
        self.last_scan_time = {}
    
    def run_position_brain(self):
        """
        GEHIRN 1: Position Management (H√ñCHSTE PRIORIT√ÑT!)
        - √úberwacht offene Positionen
        - Pr√ºft Exit-Bedingungen
        - Updated Trailing Stops
        - SCHNELLER EMERGENCY-EXIT bei kritischen Levels!
        """
        while self.active:
            try:
                with self.position_lock:
                    open_positions = self.position_manager.get_open_positions()
                
                for pos_id, position in open_positions.items():
                    try:
                        self._check_position(pos_id, position)
                    except Exception as e:
                        self.logger.log(f"Position check error for {pos_id}: {e}", "ERROR", True)
                
                time.sleep(self.config.POSITION_CHECK_INTERVAL)
                
            except Exception as e:
                self.logger.log(f"Position brain error: {e}", "ERROR", True)
                time.sleep(5)
    
    def _check_position(self, pos_id: str, position: dict):
        """
        Pr√ºfe einzelne Position - TOP 0.000001% VERSION!
        MIT: Trailing Stop, Liquidation Warning, Fast Price Cache
        """
        symbol = position['symbol']
        
        # WICHTIG: Skippe Manual Positions mit Size=0 (Ghost Positions!)
        if position.get('manual', False):
            size = position.get('position_size', 0) or position.get('contracts', 0)
            if size == 0 or position.get('position_size_usd', 0) == 0:
                return
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # HOLE PREIS - MIT CACHE WENN VERF√úGBAR!
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        try:
            if hasattr(self, 'price_cache') and self.price_cache:
                current_price = self.price_cache.get_price(symbol)
            else:
                ticker = self.exchange.exchange.fetch_ticker(symbol)
                current_price = float(ticker['last'])
        except Exception as e:
            self.logger.log(f"Error fetching price for {symbol}: {e}", "ERROR")
            return
        
        if not current_price or current_price <= 0:
            return
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # GRUNDLEGENDE POSITION-DATEN
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        entry_price = float(position.get('entry_price', 0) or 0)
        side = position.get('side', 'buy')
        leverage = float(position.get('leverage', 10) or 10)
        is_long = side in ['buy', 'long']
        position_size = float(position.get('position_size', 0) or position.get('contracts', 0) or 0)
        
        if entry_price <= 0:
            return
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PnL BERECHNUNG
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if is_long:
            current_pnl = (current_price - entry_price) / entry_price * 100 * leverage
            current_pnl_usd = (current_price - entry_price) * position_size
        else:
            current_pnl = (entry_price - current_price) / entry_price * 100 * leverage
            current_pnl_usd = (entry_price - current_price) * position_size
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # üö® LIQUIDATION CHECK - WARNUNG BEI GEFAHR!
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        liq_price = LiquidationCalculator.calculate_liquidation_price(entry_price, leverage, side)
        liq_distance = LiquidationCalculator.get_liquidation_distance(current_price, liq_price, side)
        
        if LiquidationCalculator.is_liquidation_danger(liq_distance, threshold=10):
            self.logger.log(
                f"‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è LIQUIDATION WARNING: {symbol} | "
                f"Distance to Liq: {liq_distance:.2f}% | "
                f"Liq Price: {liq_price:.6f} | Current: {current_price:.6f}",
                "CRITICAL"
            )
            
            # Auto-Close wenn sehr nah (< 3%)
            if liq_distance < 3:
                self.logger.log(f"üö® AUTO-CLOSE: {symbol} - Liquidation imminent!", "CRITICAL")
                self.position_manager.close_position(pos_id, f"LIQUIDATION_PREVENTION (Dist:{liq_distance:.2f}%)", current_price)
                return
        
        # Speichere Liquidation-Daten in Position
        position['liquidation_price'] = liq_price
        position['liquidation_distance'] = liq_distance
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # üö® EMERGENCY STOP-LOSS CHECK
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        emergency_sl_pct = -1 * self.config.HARD_STOP_LOSS_PERCENT
        if current_pnl <= emergency_sl_pct:
            self.logger.log(
                f"üö® EMERGENCY EXIT: {symbol} | PnL: {current_pnl:.2f}% <= {emergency_sl_pct}% LIMIT!",
                "WARNING"
            )
            self.position_manager.close_position(pos_id, f"EMERGENCY_STOP_LOSS ({current_pnl:.2f}%)", current_price)
            if hasattr(self, 'trailing_manager'):
                self.trailing_manager.remove_trail(pos_id)
            return
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # üéØ TRAILING STOP CHECK
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if hasattr(self, 'trailing_manager') and self.trailing_manager:
            # Hole ATR f√ºr intelligentes Trailing
            try:
                df_temp = self.exchange.fetch_ohlcv(symbol, '5m', 20)
                atr = TechnicalIndicators.atr(df_temp['high'].values, df_temp['low'].values, 
                                               df_temp['close'].values, 14) if len(df_temp) > 14 else None
            except:
                atr = None
            
            trail_result = self.trailing_manager.update_trail(pos_id, position, current_price, atr)
            
            if trail_result['triggered']:
                self.logger.log(
                    f"üéØ TRAILING STOP TRIGGERED: {symbol} | {trail_result['reason']}",
                    "INFO"
                )
                self.position_manager.close_position(pos_id, trail_result['reason'], current_price)
                self.trailing_manager.remove_trail(pos_id)
                return
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # PROFIT PROTECTION (Legacy - zus√§tzlich zum Trailing)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        highest_pnl = position.get('highest_pnl', 0)
        if highest_pnl >= 15 and current_pnl < highest_pnl * 0.4:  # 60% R√ºckgang vom Peak
            self.logger.log(
                f"‚ö° PROFIT PROTECTION: {symbol} | Peak: {highest_pnl:.2f}% -> Current: {current_pnl:.2f}%",
                "WARNING"
            )
            self.position_manager.close_position(pos_id, f"PROFIT_PROTECTION (Peak:{highest_pnl:.2f}%, Now:{current_pnl:.2f}%)", current_price)
            if hasattr(self, 'trailing_manager'):
                self.trailing_manager.remove_trail(pos_id)
            return
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # HOLE DATEN F√úR INTELLIGENTE EXITS
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        df = self.exchange.fetch_ohlcv(symbol, '1m', 50)
        indicators = TechnicalIndicators.calculate_all(df) if len(df) > 0 else {}
        orderbook = self.exchange.get_order_book(symbol)
        ob_analysis = OrderBookAnalyzer(self.config, self.logger).analyze(orderbook, current_price)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # UPDATE POSITION TRACKING
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        position['current_pnl'] = current_pnl
        position['current_pnl_usd'] = current_pnl_usd
        position['highest_pnl'] = max(position.get('highest_pnl', current_pnl), current_pnl)
        position['lowest_pnl'] = min(position.get('lowest_pnl', current_pnl), current_pnl)
        position['highest_price'] = max(position.get('highest_price', current_price), current_price)
        position['lowest_price'] = min(position.get('lowest_price', current_price), current_price)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # 5% MILESTONE TRACKING - MIT CSV UPDATES!
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        last_pnl = position.get('last_pnl', 0)
        milestones = position.get('pnl_milestones', [])
        milestone_crossed = False
        milestone_value = 0
        
        # Pr√ºfe ob wir gerade einen 5er-Schwellenwert √ºberschritten haben
        if current_pnl >= 5 and last_pnl < 5:
            position['pnl_5pct_count'] = position.get('pnl_5pct_count', 0) + 1
            milestones.append({'pnl': 5.0, 'price': current_price, 'timestamp': datetime.now().isoformat()})
            milestone_crossed = True
            milestone_value = 5
        
        if current_pnl >= 10 and last_pnl < 10:
            position['pnl_10pct_count'] = position.get('pnl_10pct_count', 0) + 1
            milestones.append({'pnl': 10.0, 'price': current_price, 'timestamp': datetime.now().isoformat()})
            milestone_crossed = True
            milestone_value = 10
        
        # F√ºr jeden 5er-Block - auch NEGATIVE!
        current_block = int(current_pnl / 5) * 5
        last_block = int(last_pnl / 5) * 5
        
        if current_block != last_block and current_block != 0:
            milestones.append({'pnl': float(current_block), 'price': current_price, 'timestamp': datetime.now().isoformat()})
            milestone_crossed = True
            milestone_value = current_block
        
        # Aktualisiere max_profit_reached
        if current_pnl > position.get('max_profit_reached', 0):
            position['max_profit_reached'] = current_pnl
        
        position['pnl_milestones'] = milestones
        position['last_pnl'] = current_pnl
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # SCHREIBE UPDATE INS CSV WENN MILESTONE ERREICHT!
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if milestone_crossed and position.get('trade_id'):
            update_data = {
                'current_pnl': current_pnl,
                'current_pnl_usd': current_pnl_usd,
                'current_price': current_price,
                'highest_price': position.get('highest_price'),
                'lowest_price': position.get('lowest_price'),
                'highest_pnl': position.get('highest_pnl'),
                'lowest_pnl': position.get('lowest_pnl'),
                'pnl_5pct_count': position.get('pnl_5pct_count', 0),
                'pnl_10pct_count': position.get('pnl_10pct_count', 0),
                'pnl_milestones': milestones,
                'max_profit_reached': position.get('max_profit_reached', 0),
                'milestone_reached': milestone_value,
                'liquidation_price': liq_price,
                'liquidation_distance': liq_distance,
                'exit_reason': f'UPDATE: {milestone_value}% PnL reached',
            }
            try:
                self.position_manager.journal.record_update(
                    position['trade_id'], 
                    update_data, 
                    indicators
                )
                self.logger.log(
                    f"üìä MILESTONE: {symbol} reached {milestone_value}% PnL! "
                    f"(Current: {current_pnl:.2f}%, Price: {current_price})",
                    "INFO"
                )
            except Exception as e:
                self.logger.log(f"Error recording milestone update: {e}", "ERROR")
        
        # SPEICHERE POSITION UPDATES!
        self.position_manager._save_positions()
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # SYSTEM-SPEZIFISCHER EXIT-CHECK
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        system = position.get('system', 'HYDRA')
        entry_time = position.get('entry_time', datetime.now())
        
        if isinstance(entry_time, str):
            try:
                entry_time = datetime.fromisoformat(entry_time)
            except:
                entry_time = datetime.now()
        
        # Exit-Check basierend auf System
        if system == 'VIPER':
            exit_signal = self.viper.calculate_exit(position, current_price, entry_time)
        elif system == 'PHOENIX':
            exit_signal = self.phoenix.calculate_exit(position, current_price, entry_time, indicators)
        else:  # HYDRA
            exit_signal = self.hydra.calculate_exit(
                position, current_price, entry_time, df, indicators, ob_analysis
            )
        
        # Exit ausf√ºhren wenn n√∂tig
        if exit_signal['exit']:
            self.position_manager.close_position(pos_id, exit_signal['reason'], current_price)
            if hasattr(self, 'trailing_manager'):
                self.trailing_manager.remove_trail(pos_id)
    
    def run_entry_brain(self):
        """
        GEHIRN 2: Entry Scanning
        - Scannt nach neuen Entries
        - Koordiniert zwischen Systemen
        """
        while self.active:
            try:
                # Pr√ºfe ob Entry pausiert ist (z.B. wegen MAX_DRAWDOWN)
                if hasattr(self, 'entry_paused') and self.entry_paused:
                    self.logger.log("‚è∏Ô∏è Entry scanning paused (Drawdown limit) - Position management continues", "WARNING")
                    time.sleep(60)  # Warte 60s, pr√ºfe dann wieder
                    continue
                
                # Pr√ºfe Balance ZUERST
                balance = self.exchange.get_balance()
                if balance < 1:  # Weniger als 1 USDT
                    self.logger.log(f"‚ö†Ô∏è Balance too low ({balance:.2f} USDT) - Pausing entry scan for 60s", "WARNING")
                    time.sleep(60)
                    continue
                
                # Pr√ºfe ob wir noch Kapazit√§t haben
                open_count = len(self.position_manager.get_open_positions())
                if open_count >= self.config.MAX_CONCURRENT_POSITIONS:
                    time.sleep(self.config.SCAN_INTERVAL_SECONDS)
                    continue
                
                # Hole Top Coins
                coins = self.exchange.get_top_coins()
                
                for symbol in coins:
                    # Pr√ºfe Balance wieder (kann sich ge√§ndert haben)
                    balance = self.exchange.get_balance()
                    if balance < 1:
                        self.logger.log(f"‚ö†Ô∏è Balance depleted during scan - Stopping entry scan", "WARNING")
                        break
                    
                    # Pr√ºfe ob bereits Position offen
                    if self.position_manager.has_position(symbol):
                        continue
                    
                    # Scan durchf√ºhren
                    self._scan_symbol(symbol)
                    
                    # Rate Limiting
                    time.sleep(0.5)
                
                time.sleep(self.config.SCAN_INTERVAL_SECONDS)
                
            except Exception as e:
                self.logger.log(f"Entry brain error: {e}", "ERROR", True)
                time.sleep(10)
    
    def _scan_symbol(self, symbol: str):
        """Scanne Symbol mit allen Systemen"""
        try:
            # Hole Daten
            df = self.exchange.fetch_ohlcv(symbol, '5m', 100)
            if len(df) < 50:
                return
            
            current_price = df['close'].iloc[-1]
            indicators = TechnicalIndicators.calculate_all(df)
            orderbook = self.exchange.get_order_book(symbol)
            ob_analysis = OrderBookAnalyzer(self.config, self.logger).analyze(orderbook, current_price)
            
            # F√ºge Funding Rate hinzu
            indicators['funding_rate'] = self.exchange.get_funding_rate(symbol)
            
            # Scanne mit allen Systemen
            entries = []
            
            # VIPER
            viper_entry = self.viper.scan_for_entry(symbol, df, indicators, ob_analysis)
            if viper_entry.get('entry'):
                entries.append(viper_entry)
            
            # PHOENIX
            phoenix_entry = self.phoenix.scan_for_entry(symbol, df, indicators, ob_analysis)
            if phoenix_entry.get('entry'):
                entries.append(phoenix_entry)
            
            # HYDRA
            hydra_entry = self.hydra.scan_for_entry(symbol, df, indicators, ob_analysis)
            if hydra_entry.get('entry'):
                entries.append(hydra_entry)
            
            # W√§hle besten Entry
            if entries:
                # WICHTIG: Pr√ºfe nochmal ob Entry pausiert ist (kann w√§hrend Scan gesetzt werden!)
                if hasattr(self, 'entry_paused') and self.entry_paused:
                    self.logger.log(f"‚ö†Ô∏è Entry signal found but entry paused: {symbol}", "WARNING")
                    return
                
                # Sortiere nach Strength und Agreement
                best_entry = max(entries, key=lambda x: x['strength'] * x.get('agreement', 1))
                
                self.logger.log(
                    f"ENTRY SIGNAL: {symbol} | System: {best_entry['system']} | "
                    f"Side: {best_entry['side']} | Strength: {best_entry['strength']:.2f} | "
                    f"Agreement: {best_entry.get('agreement', 1)}",
                    "INFO"
                )
                
                # Entry ausf√ºhren
                self.position_manager.open_position(
                    symbol=symbol,
                    side=best_entry['side'],
                    system=best_entry['system'],
                    strategy=best_entry['strategy'],
                    leverage=best_entry['leverage'],
                    strength=best_entry['strength'],
                    agreement=best_entry.get('agreement', 1),
                    strategies_agreed=best_entry.get('strategies_agreed', []),
                    indicators=indicators,
                    orderbook_analysis=ob_analysis,
                    current_price=current_price
                )
                
        except Exception as e:
            self.logger.log(f"Error scanning {symbol}: {e}", "ERROR", True)
    
    def start(self):
        """Starte beide Gehirne"""
        self.logger.log("Starting Multi-Brain Controller...", "INFO")
        
        # Position Brain (h√∂chste Priorit√§t)
        pos_thread = threading.Thread(target=self.run_position_brain, daemon=True)
        pos_thread.start()
        
        # Entry Brain
        entry_thread = threading.Thread(target=self.run_entry_brain, daemon=True)
        entry_thread.start()
        
        self.logger.log("Multi-Brain Controller started!", "INFO")
        
        return pos_thread, entry_thread
    
    def stop(self):
        """Stoppe Controller"""
        self.active = False
        self.logger.log("Multi-Brain Controller stopped", "INFO")


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
# ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
#                          POSITION MANAGER
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class PositionManager:
    """
    Position Manager
    - √ñffnet/Schlie√üt Positionen
    - Verwaltet Hard Stop-Losses
    - Tracked alle Daten f√ºr CSV
    - Holt ECHTEN Exit-Preis
    """
    
    def __init__(self, config: Config, logger: Logger, exchange: ExchangeConnector,
                 journal: TradeJournal, ranking: StrategyRankingSystem,
                 state_manager: StateManager):
        self.config = config
        self.logger = logger
        self.exchange = exchange
        self.journal = journal
        self.ranking = ranking
        self.state = state_manager
        
        self.open_positions = {}  # In-Memory
        self.lock = threading.Lock()
        
        # Lade persistierte Positionen
        self._load_positions()
    
    def _load_positions(self):
        """Lade Positionen aus State"""
        saved = self.state.get('open_positions', {})
        if saved:
            self.open_positions = saved
            self.logger.log(f"Loaded {len(saved)} open positions from state", "INFO")
    
    def _save_positions(self):
        """Speichere Positionen"""
        self.state.set('open_positions', self.open_positions)
    
    def get_open_positions(self) -> dict:
        """Thread-safe Zugriff auf offene Positionen"""
        with self.lock:
            return self.open_positions.copy()
    
    def has_position(self, symbol: str) -> bool:
        """Pr√ºfe ob Position f√ºr Symbol offen ist"""
        with self.lock:
            for pos in self.open_positions.values():
                if pos['symbol'] == symbol:
                    return True
        return False
    
    def open_position(self, symbol: str, side: str, system: str, strategy: str,
                     leverage: int, strength: float, agreement: int,
                     strategies_agreed: list, indicators: dict,
                     orderbook_analysis: dict, current_price: float) -> bool:
        """
        √ñffne neue Position
        - Setzt Leverage KORREKT
        - Berechnet Position Size KORREKT
        - Setzt Hard Stop-Loss
        - Logged ALLES
        """
        
        self.logger.log(f"Opening position: {symbol} {side} (System: {system})", "INFO")
        
        try:
            # 1. Pr√ºfe Balance
            balance = self.exchange.get_balance()
            if balance <= 0:
                self.logger.log("No balance available!", "ERROR")
                return False
            
            # 2. Berechne Position Size
            position_size, actual_leverage = self.exchange.calculate_position_size(
                symbol, current_price, leverage
            )
            
            if position_size <= 0:
                self.logger.log(f"Position size too small for {symbol}", "ERROR")
                return False
            
            # 3. Berechne Stop-Loss Preis
            if side == 'buy':
                stop_loss_price = current_price * (1 - self.config.HARD_STOP_LOSS_PERCENT / 100 / leverage)
            else:
                stop_loss_price = current_price * (1 + self.config.HARD_STOP_LOSS_PERCENT / 100 / leverage)
            
            # Runde Stop-Loss
            market_info = self.exchange.get_market_info(symbol)
            if market_info:
                price_precision = int(market_info['price_precision'])  # FIXED: War float
                stop_loss_price = round(stop_loss_price, price_precision)
            
            # 4. Platziere Order
            order = self.exchange.place_order(
                symbol=symbol,
                side=side,
                amount=position_size,
                leverage=actual_leverage,
                stop_loss=stop_loss_price
            )
            
            if not order:
                self.logger.log(f"Order placement failed for {symbol}", "ERROR")
                return False
            
            # 5. Hole tats√§chlichen Fill-Preis - MIT SICHEREN DEFAULTS!
            actual_entry_price = order.get('actual_fill_price') or order.get('price') or current_price
            actual_amount = order.get('actual_fill_amount') or order.get('filled') or position_size
            
            # KRITISCHER CHECK: Falls immer noch None, nutze current_price
            if actual_entry_price is None:
                self.logger.log(f"‚ö†Ô∏è actual_entry_price was None, using current_price: {current_price}", "WARNING")
                actual_entry_price = current_price
            
            if actual_amount is None or actual_amount == 0:
                self.logger.log(f"‚ö†Ô∏è actual_amount was None or 0, using position_size: {position_size}", "WARNING")
                actual_amount = position_size
            
            # 6. Berechne Fees
            entry_fee = actual_amount * actual_entry_price * self.config.TAKER_FEE
            
            # 7. Erstelle Position Record
            position_id = order['id']
            entry_time = datetime.now()
            
            position = {
                'position_id': position_id,
                'symbol': symbol,
                'side': side,
                'system': system,
                'strategy': strategy,
                'leverage': actual_leverage,
                'entry_price': actual_entry_price,
                'target_entry_price': current_price,
                'position_size': actual_amount,
                'position_size_usd': actual_amount * actual_entry_price,
                'stop_loss_price': stop_loss_price,
                'stop_loss_order_id': order.get('stop_loss_order_id'),
                'entry_time': entry_time.isoformat(),
                'entry_fee': entry_fee,
                'strength': strength,
                'agreement': agreement,
                'strategies_agreed': strategies_agreed,
                'highest_price': actual_entry_price,
                'lowest_price': actual_entry_price,
                'highest_pnl': 0,
                'lowest_pnl': 0,
                # ‚ïê‚ïê‚ïê 5% MILESTONE TRACKING ‚ïê‚ïê‚ïê
                'pnl_5pct_count': 0,  # Wie oft +5% √ºberschritten
                'pnl_10pct_count': 0,  # Wie oft +10% √ºberschritten
                'pnl_milestones': [],  # Alle erreichten Profit-Punkte
                'max_profit_reached': 0,  # Maximum PnL w√§hrend Trade
                'last_pnl': 0,  # Letzter PnL zum Vergleichen
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                'balance_before': balance,
            }
            
            # 8. Speichere Position
            with self.lock:
                self.open_positions[position_id] = position
            self._save_positions()
            
            # 9. Log to CSV (Entry)
            trade_data = {
                'symbol': symbol,
                'system': system,
                'strategy': strategy,
                'side': side,
                'leverage': actual_leverage,
                'entry_price': actual_entry_price,
                'target_exit_price': None,
                'stop_loss_price': stop_loss_price,
                'position_size': actual_amount,
                'position_size_usd': actual_amount * actual_entry_price,
                'entry_fee': entry_fee,
                'strategy_confidence': strength,
                'agreement_count': agreement,
                'account_balance_before': balance,
                
                # Indikatoren - MIT SICHEREN DEFAULTS!
                # WICHTIG: Wenn Indikator fehlt (Key nicht im dict), nutze 0
                'ind_rsi_14': indicators.get('rsi_14', 0) if 'rsi_14' in indicators else 0,
                'ind_rsi_7': indicators.get('rsi_7', 0) if 'rsi_7' in indicators else 0,
                'ind_macd': indicators.get('macd', 0) if 'macd' in indicators else 0,
                'ind_macd_signal': indicators.get('macd_signal', 0) if 'macd_signal' in indicators else 0,
                'ind_macd_hist': indicators.get('macd_hist', 0) if 'macd_hist' in indicators else 0,
                'ind_ema_9': indicators.get('ema_9', 0) if 'ema_9' in indicators else 0,
                'ind_ema_21': indicators.get('ema_21', 0) if 'ema_21' in indicators else 0,
                'ind_ema_50': indicators.get('ema_50', 0) if 'ema_50' in indicators else 0,
                'ind_ema_200': indicators.get('ema_200', 0) if 'ema_200' in indicators else 0,
                'ind_bb_upper': indicators.get('bb_upper', 0) if 'bb_upper' in indicators else 0,
                'ind_bb_middle': indicators.get('bb_middle', 0) if 'bb_middle' in indicators else 0,
                'ind_bb_lower': indicators.get('bb_lower', 0) if 'bb_lower' in indicators else 0,
                'ind_bb_width': indicators.get('bb_width', 0) if 'bb_width' in indicators else 0,
                'ind_atr_14': indicators.get('atr_14', 0) if 'atr_14' in indicators else 0,
                'ind_adx': indicators.get('adx', 0) if 'adx' in indicators else 0,
                'ind_plus_di': indicators.get('plus_di', 0) if 'plus_di' in indicators else 0,
                'ind_minus_di': indicators.get('minus_di', 0) if 'minus_di' in indicators else 0,
                'ind_stoch_k': indicators.get('stoch_k', 0) if 'stoch_k' in indicators else 0,
                'ind_stoch_d': indicators.get('stoch_d', 0) if 'stoch_d' in indicators else 0,
                'ind_cci': indicators.get('cci', 0) if 'cci' in indicators else 0,
                'ind_mfi': indicators.get('mfi', 0) if 'mfi' in indicators else 0,
                'ind_obv': indicators.get('obv', 0) if 'obv' in indicators else 0,
                'ind_vwap': indicators.get('vwap', 0) if 'vwap' in indicators else 0,
                'ind_volume_sma': indicators.get('volume_sma', 0) if 'volume_sma' in indicators else 0,
                'ind_ichimoku_tenkan': indicators.get('ichimoku_tenkan', 0) if 'ichimoku_tenkan' in indicators else 0,
                'ind_ichimoku_kijun': indicators.get('ichimoku_kijun', 0) if 'ichimoku_kijun' in indicators else 0,
                
                # Orderbook - MIT DEFAULTS
                'ob_bid_volume': orderbook_analysis.get('bid_volume', 0) or 0,
                'ob_ask_volume': orderbook_analysis.get('ask_volume', 0) or 0,
                'ob_imbalance': orderbook_analysis.get('imbalance', 0) or 0,
                'ob_spread': orderbook_analysis.get('spread', 0) or 0,
                'ob_whale_bids': orderbook_analysis.get('whale_bids', 0) or 0,
                'ob_whale_asks': orderbook_analysis.get('whale_asks', 0) or 0,
                
                # Markt-Kontext - MIT DEFAULTS
                'market_trend': indicators.get('trend', 'neutral'),
                'volatility_1h': indicators.get('volatility', 0) or 0,
                'funding_rate': indicators.get('funding_rate', 0) or 0,
            }
            
            trade_id = self.journal.record_entry(trade_data, all_indicators=indicators)
            position['trade_id'] = trade_id
            
            # 10. Update Ranking
            self.ranking.register_strategy(strategy)
            self.ranking.record_trade_attempt(strategy)
            
            self.logger.log(
                f"‚úÖ POSITION OPENED: {symbol} | {side.upper()} | "
                f"Entry: {actual_entry_price} | Size: {actual_amount} | "
                f"Leverage: {actual_leverage}x | SL: {stop_loss_price}",
                "INFO"
            )
            
            return True
            
        except Exception as e:
            self.logger.log(f"Error opening position: {e}", "ERROR", True)
            return False
    
    def close_position(self, position_id: str, reason: str, current_price: float = None) -> bool:
        """
        Schlie√üe Position - KOMPLETT √úBERARBEITET!
        - Holt ECHTEN Exit-Preis mit MEHRFACH-FALLBACK
        - Berechnet ECHTEN PnL - NIEMALS None!
        - Updated CSV - IMMER!
        - Updated Rankings - GARANTIERT!
        """
        
        with self.lock:
            if position_id not in self.open_positions:
                self.logger.log(f"Position {position_id} not found", "WARNING")
                return False
            
            position = self.open_positions[position_id].copy()  # Kopie f√ºr sichere Verarbeitung
        
        symbol = position['symbol']
        self.logger.log(f"Closing position: {symbol} ({reason})", "INFO")
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ROBUSTE VARIABLEN-INITIALISIERUNG - NIEMALS None!
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        entry_price = float(position.get('entry_price', 0) or 0)
        side = position.get('side', 'buy')
        leverage = float(position.get('leverage', 1) or 1)
        strategy = position.get('strategy', 'unknown')
        
        # Hole aktuellen Preis als Backup SOFORT
        if current_price is None:
            try:
                ticker = self.exchange.exchange.fetch_ticker(symbol)
                current_price = float(ticker['last'])
            except:
                current_price = entry_price  # Letzter Fallback
        
        # Amount mit Fallback-Kette
        amount = float(
            position.get('position_size') 
            or position.get('contracts') 
            or position.get('amount')
            or position.get('contracts_original')
            or 0
        )
        
        position_size_usd = float(position.get('position_size_usd', amount * entry_price) or (amount * entry_price))
        
        # Defaults f√ºr PnL (falls alles fehlschl√§gt)
        actual_exit_price = current_price
        actual_exit_amount = amount
        gross_pnl_percent = 0.0
        gross_pnl_usd = 0.0
        net_pnl_percent = 0.0
        net_pnl_usd = 0.0
        exit_fee = 0.0
        total_fees = 0.0
        slippage_exit = 0.0
        close_success = False
        
        try:
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 1. VERSUCHE POSITION ZU SCHLIESSEN
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if amount <= 0:
                self.logger.log(
                    f"‚ö†Ô∏è Cannot close position {symbol} - no valid amount! Using tracking data.",
                    "WARNING"
                )
                # Nutze current_price als Exit
                actual_exit_price = current_price
                close_success = True  # Als "erfolgreich" markieren um Position zu entfernen
            else:
                try:
                    close_result = self.exchange.close_position(
                        symbol=symbol,
                        side=side,
                        amount=amount
                    )
                    
                    if close_result:
                        close_success = True
                        # Extrahiere Exit-Preis mit Fallbacks
                        actual_exit_price = (
                            close_result.get('actual_exit_price') 
                            or close_result.get('price')
                            or current_price
                            or entry_price
                        )
                        actual_exit_amount = close_result.get('actual_exit_amount') or amount
                        
                except Exception as e:
                    error_str = str(e)
                    if "No open positions" in error_str or "300009" in error_str:
                        self.logger.log(f"‚ö†Ô∏è Position {symbol} already closed on exchange", "WARNING")
                        close_success = True
                        actual_exit_price = current_price or entry_price
                    else:
                        self.logger.log(f"Exchange close error: {e}", "ERROR")
                        # Trotzdem fortfahren mit Tracking-Update!
                        close_success = True
                        actual_exit_price = current_price or entry_price
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 2. BERECHNE PnL - MIT SICHEREN DEFAULTS!
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # Stelle sicher dass alle Werte numerisch sind
            actual_exit_price = float(actual_exit_price or current_price or entry_price)
            actual_exit_amount = float(actual_exit_amount or amount)
            
            is_long = side in ['buy', 'long']
            
            if entry_price > 0:
                if is_long:
                    gross_pnl_percent = (actual_exit_price - entry_price) / entry_price * 100 * leverage
                    gross_pnl_usd = (actual_exit_price - entry_price) * actual_exit_amount
                else:
                    gross_pnl_percent = (entry_price - actual_exit_price) / entry_price * 100 * leverage
                    gross_pnl_usd = (entry_price - actual_exit_price) * actual_exit_amount
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 3. BERECHNE FEES
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            entry_fee = float(position.get('entry_fee', 0) or 0)
            exit_fee = actual_exit_amount * actual_exit_price * self.config.TAKER_FEE
            total_fees = entry_fee + exit_fee
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 4. NETTO PnL
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            net_pnl_usd = gross_pnl_usd - total_fees
            
            margin_used = position_size_usd / leverage if leverage > 0 else position_size_usd
            if margin_used > 0:
                fee_impact_percent = (total_fees / margin_used) * 100
                net_pnl_percent = gross_pnl_percent - fee_impact_percent
            else:
                net_pnl_percent = gross_pnl_percent
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 5. SLIPPAGE
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            if current_price and current_price > 0:
                slippage_exit = abs(actual_exit_price - current_price) / current_price * 100
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 6. HALTEZEIT
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            entry_time = position.get('entry_time')
            if isinstance(entry_time, str):
                try:
                    entry_time = datetime.fromisoformat(entry_time)
                except:
                    entry_time = datetime.now()
            hold_time = (datetime.now() - entry_time).total_seconds() if entry_time else 0
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 7. BALANCE
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            try:
                balance_after = self.exchange.get_balance()
            except:
                balance_after = 0
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 8. INDIKATOREN F√úR CSV
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            try:
                df = self.exchange.fetch_ohlcv(symbol, '1m', 20)
                indicators = TechnicalIndicators.calculate_all(df) if len(df) > 0 else {}
            except:
                indicators = {}
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 9. UPDATE CSV - IMMER!
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            exit_data = {
                'timestamp_exit': datetime.now().isoformat(),
                'exit_signal_price': current_price,
                'target_exit_price': current_price,
                'actual_exit_price': actual_exit_price,
                'highest_price': position.get('highest_price', actual_exit_price),
                'lowest_price': position.get('lowest_price', actual_exit_price),
                'exit_fee': exit_fee,
                'total_fees': total_fees,
                'slippage_exit': slippage_exit,
                'gross_pnl_percent': gross_pnl_percent,
                'net_pnl_percent': net_pnl_percent,
                'gross_pnl_usd': gross_pnl_usd,
                'net_pnl_usd': net_pnl_usd,
                'pnl_at_highest': position.get('highest_pnl', 0),
                'pnl_at_lowest': position.get('lowest_pnl', 0),
                'pnl_5pct_count': position.get('pnl_5pct_count', 0),
                'pnl_10pct_count': position.get('pnl_10pct_count', 0),
                'pnl_milestones': position.get('pnl_milestones', []),
                'max_profit_reached': position.get('max_profit_reached', 0),
                'hold_time_seconds': hold_time,
                'exit_reason': reason,
                'account_balance_after': balance_after,
            }
            
            if position.get('trade_id'):
                try:
                    self.journal.update_exit(position['trade_id'], exit_data, all_indicators=indicators)
                except Exception as e:
                    self.logger.log(f"CSV update error (non-critical): {e}", "WARNING")
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 10. UPDATE RANKING - GARANTIERT!
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            try:
                self.ranking.record_trade_result(strategy, net_pnl_percent, net_pnl_usd)
                self.logger.log(
                    f"üìä Ranking updated: {strategy} | PnL: {net_pnl_percent:+.2f}% (${net_pnl_usd:+.2f})",
                    "INFO"
                )
            except Exception as e:
                self.logger.log(f"Ranking update error: {e}", "ERROR")
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 11. UPDATE STATE
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            try:
                daily_pnl = (self.state.get('daily_pnl') or 0) + net_pnl_usd
                self.state.set('daily_pnl', daily_pnl)
                
                total_pnl = (self.state.get('total_pnl') or 0) + net_pnl_usd
                self.state.set('total_pnl', total_pnl)
            except Exception as e:
                self.logger.log(f"State update error: {e}", "WARNING")
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 12. ENTFERNE POSITION
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            with self.lock:
                if position_id in self.open_positions:
                    del self.open_positions[position_id]
            self._save_positions()
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 13. CANCEL HARD SL ORDER
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            try:
                if position.get('stop_loss_order_id'):
                    self.exchange.exchange.cancel_order(position['stop_loss_order_id'], symbol)
            except:
                pass
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # 14. LOG RESULT
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            emoji = "‚úÖ" if net_pnl_percent > 0 else "‚ùå"
            self.logger.log(
                f"{emoji} POSITION CLOSED: {symbol} | "
                f"Entry: {entry_price:.6f} | Exit: {actual_exit_price:.6f} | "
                f"Gross: {gross_pnl_percent:+.2f}% | Net: {net_pnl_percent:+.2f}% (${net_pnl_usd:+.2f}) | "
                f"Reason: {reason}",
                "INFO"
            )
            
            return True
            
        except Exception as e:
            self.logger.log(f"CRITICAL Error in close_position: {e}", "ERROR", True)
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # EMERGENCY: Auch bei Fehler versuchen das Ranking zu updaten!
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            try:
                # Berechne PnL basierend auf verf√ºgbaren Daten
                if entry_price > 0 and current_price:
                    is_long = side in ['buy', 'long']
                    if is_long:
                        emergency_pnl = (current_price - entry_price) / entry_price * 100 * leverage
                    else:
                        emergency_pnl = (entry_price - current_price) / entry_price * 100 * leverage
                    
                    emergency_pnl_usd = emergency_pnl / 100 * (position_size_usd / leverage)
                    
                    self.ranking.record_trade_result(strategy, emergency_pnl, emergency_pnl_usd)
                    self.logger.log(
                        f"‚ö†Ô∏è Emergency ranking update: {strategy} | Est. PnL: {emergency_pnl:+.2f}%",
                        "WARNING"
                    )
            except Exception as e2:
                self.logger.log(f"Emergency ranking update failed: {e2}", "ERROR")
            
            # Entferne Position trotzdem
            try:
                with self.lock:
                    if position_id in self.open_positions:
                        del self.open_positions[position_id]
                self._save_positions()
            except:
                pass
            
            return False
    
    def sync_with_exchange(self):
        """Synchronisiere mit Exchange - ERKENNT MANUELLE TRADES!"""
        try:
            self.logger.log("üîÑ Syncing positions with exchange...", "INFO")
            exchange_positions = self.exchange.get_open_positions()
            
            # ‚úÖ FIX #2: API Validierung - Falls API Error, abbrechen!
            if not exchange_positions or len(exchange_positions) == 0:
                self.logger.log(
                    "‚ö†Ô∏è Exchange returned NO positions - possible API error! "
                    "Skipping sync to prevent false deletions!",
                    "WARNING"
                )
                return  # Fr√ºh exit - nicht l√∂schen!
            
            # 1. Finde Positionen die auf Exchange sind aber nicht in unserem Tracking
            for ex_pos in exchange_positions:
                symbol = ex_pos['symbol']
                side = ex_pos['side']
                size = ex_pos['contracts']
                entry_price = ex_pos['entryPrice']
                
                # Pr√ºfe ob wir diese Position kennen
                found = False
                for our_pos_id, our_pos in self.open_positions.items():
                    # ‚úÖ FIX #1: Besseres Matching - Normalisierung
                    # Symbol: Strip whitespace & Upper
                    our_symbol_clean = our_pos['symbol'].strip().upper()
                    ex_symbol_clean = symbol.strip().upper()
                    
                    # Side: Normalisiere buy/long zu long, sell/short zu short
                    our_side_normalized = 'long' if our_pos['side'] in ['buy', 'long'] else 'short'
                    ex_side_normalized = 'long' if side in ['buy', 'long'] else 'short'
                    
                    # Jetzt vergleiche
                    if our_symbol_clean == ex_symbol_clean and our_side_normalized == ex_side_normalized:
                        found = True
                        
                        # Update aktuelle Werte
                        our_pos['contracts'] = size
                        our_pos['current_price'] = ex_pos.get('markPrice', entry_price)
                        
                        # Berechne aktuellen PnL
                        # WICHTIG: KuCoin gibt side='long' oder 'short' zur√ºck!
                        # ABER Bot speichert side='buy' oder 'sell'!
                        # Normalisiere: long/buy = gleiche Richtung, short/sell = gleiche Richtung
                        
                        is_long = ex_side_normalized == 'long'  # Normalisiert!
                        
                        if is_long:
                            # LONG: Profit wenn Preis steigt
                            pnl_percent = (our_pos['current_price'] - our_pos['entry_price']) / our_pos['entry_price'] * 100
                        else:
                            # SHORT: Profit wenn Preis f√§llt
                            pnl_percent = (our_pos['entry_price'] - our_pos['current_price']) / our_pos['entry_price'] * 100
                        
                        our_pos['current_pnl'] = pnl_percent
                        our_pos['current_pnl_usd'] = pnl_percent * our_pos.get('position_size_usd', 0) / 100 * our_pos['leverage']
                        
                        # Update Highest/Lowest
                        if our_pos['current_price'] > our_pos.get('highest_price', 0):
                            our_pos['highest_price'] = our_pos['current_price']
                            our_pos['highest_pnl'] = pnl_percent
                        
                        if our_pos['current_price'] < our_pos.get('lowest_price', float('inf')):
                            our_pos['lowest_price'] = our_pos['current_price']
                            our_pos['lowest_pnl'] = pnl_percent
                        
                        break
                
                if not found:
                    # NEUE POSITION! Wurde manuell er√∂ffnet
                    self.logger.log(f"‚ö†Ô∏è Found MANUAL position: {symbol} {side.upper()}", "WARNING")
                    
                    # ‚úÖ FIX #4: Bessere Size Handling f√ºr MANUAL Positionen
                    # Stelle SICHER dass size > 0 ist
                    if size == 0 or size is None:
                        self.logger.log(
                            f"‚ö†Ô∏è WARNING: Position size is 0/None for {symbol}! "
                            f"May have trouble closing this position!",
                            "WARNING"
                        )
                    
                    # F√ºge zu unserem Tracking hinzu
                    position_id = f"{symbol}_{side}_{int(time.time())}"
                    
                    new_position = {
                        'position_id': position_id,
                        'symbol': symbol,
                        'side': side,
                        'entry_price': entry_price,
                        'contracts': size,
                        'position_size': size,              # KRITISCH f√ºr close_position!
                        'amount': size,                     # BACKUP
                        'contracts_original': size,         # EXTRA BACKUP
                        'leverage': ex_pos.get('leverage', 10),
                        'position_size_usd': size * entry_price / ex_pos.get('leverage', 10),
                        'entry_time': datetime.now(),
                        'system': 'MANUAL',
                        'strategy': 'manual_trade',
                        'current_price': ex_pos.get('markPrice', entry_price),
                        'current_pnl': 0,
                        'current_pnl_usd': 0,
                        'highest_price': entry_price,
                        'lowest_price': entry_price,
                        'highest_pnl': 0,
                        'lowest_pnl': 0,
                        'take_profit': None,
                        'stop_loss': None,
                        'trailing_stop_active': False,
                        'manual': True  # Markiere als manuell
                    }
                    
                    with self.lock:
                        self.open_positions[position_id] = new_position
                    
                    self._save_positions()
                    self.logger.log(f"‚úÖ Manual position added to tracking: {symbol} (size={size})", "INFO")
            
            # 2. Finde Positionen die in unserem Tracking sind aber nicht mehr auf Exchange
            positions_to_remove = []
            
            for our_pos_id, our_pos in self.open_positions.items():
                symbol = our_pos['symbol']
                side = our_pos['side']
                
                # ‚úÖ FIX #1: Besseres Matching - Normalisierung
                our_symbol_clean = symbol.strip().upper()
                our_side_normalized = 'long' if side in ['buy', 'long'] else 'short'
                
                # Pr√ºfe ob Position noch auf Exchange existiert
                found_on_exchange = False
                for ex_pos in exchange_positions:
                    # Normalisiere Exchange Position auch
                    ex_symbol_clean = ex_pos['symbol'].strip().upper()
                    ex_side_normalized = 'long' if ex_pos['side'] in ['buy', 'long'] else 'short'
                    
                    # Vergleiche normalisierte Werte
                    if ex_symbol_clean == our_symbol_clean and ex_side_normalized == our_side_normalized:
                        found_on_exchange = True
                        break
                
                if not found_on_exchange:
                    # Position wurde bereits geschlossen (z.B. durch SL/TP oder manuell)
                    self.logger.log(f"‚ö†Ô∏è Position already closed on exchange: {symbol}", "WARNING")
                    positions_to_remove.append(our_pos_id)
            
            # Entferne geschlossene Positionen aus unserem Tracking
            for pos_id in positions_to_remove:
                pos = self.open_positions[pos_id]
                
                # Hole finalen Preis vom Exchange
                try:
                    ticker = self.exchange.exchange.fetch_ticker(pos['symbol'])
                    final_price = ticker['last']
                except:
                    final_price = pos.get('current_price', pos['entry_price'])
                
                # WICHTIG: Position ist schon auf Exchange geschlossen!
                # Wir m√ºssen sie NICHT nochmal schlie√üen, nur aus Tracking entfernen!
                self.logger.log(f"üîÑ Auto-closing tracked position: {pos['symbol']}", "INFO")
                
                # Berechne PnL f√ºr CSV
                entry_price = pos['entry_price']
                side = pos['side']
                
                # Normalisiere Side
                is_long = side in ['buy', 'long']
                
                if is_long:
                    pnl_percent = (final_price - entry_price) / entry_price * 100
                else:
                    pnl_percent = (entry_price - final_price) / entry_price * 100
                
                # Nur wenn es eine Bot-Position war, logge zu CSV
                if not pos.get('manual', False):
                    try:
                        self.journal.log_exit(
                            trade_id=pos.get('trade_id', 'unknown'),
                            exit_price=final_price,
                            exit_reason='exchange_closed',
                            pnl_percent=pnl_percent,
                            balance_after=self.exchange.get_balance()
                        )
                    except Exception as e:
                        self.logger.log(f"Error logging exit: {e}", "ERROR")
                
                # Entferne aus Tracking OHNE Exchange Order
                with self.lock:
                    if pos_id in self.open_positions:
                        del self.open_positions[pos_id]
                
                self._save_positions()
                self.logger.log(f"‚úÖ Ghost position removed: {pos['symbol']}", "INFO")
            
            self.logger.log(f"‚úÖ Sync complete: {len(exchange_positions)} positions on exchange, {len(self.open_positions)} in tracking", "INFO")
            
        except Exception as e:
            self.logger.log(f"Error syncing positions: {e}", "ERROR", True)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
# ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
# ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù 
#                         VOLLST√ÑNDIGES DASHBOARD
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Dashboard:
    """
    Vollst√§ndiges Dashboard mit ALLEN Informationen
    """
    
    def __init__(self, config: Config, logger: Logger, exchange: ExchangeConnector,
                 position_manager: PositionManager, ranking: StrategyRankingSystem,
                 state_manager: StateManager):
        self.config = config
        self.logger = logger
        self.exchange = exchange
        self.positions = position_manager
        self.ranking = ranking
        self.state = state_manager
        
        self.start_time = datetime.now()
        self.last_update = None
    
    def render(self) -> str:
        """Rendere vollst√§ndiges modernes Dashboard"""
        try:
            balance = self.exchange.get_balance()
            open_positions = self.positions.get_open_positions()
            rankings = self.ranking.get_ranking()
            
            # Stats
            total_pnl = self.state.get('total_pnl', 0)
            daily_pnl = self.state.get('daily_pnl', 0)
            start_balance = self.state.get('start_balance', balance)
            peak_balance = self.state.get('peak_balance', balance)
            if peak_balance is None:
                peak_balance = balance
            
            if isinstance(balance, (int, float)) and isinstance(peak_balance, (int, float)) and balance > peak_balance:
                self.state.set('peak_balance', balance)
                peak_balance = balance
            
            # Erweiterte Metriken
            # WICHTIG: Berechne Reserved Margin + Unrealized PnL
            reserved_margin = 0
            unrealized_pnl = 0
            
            for pos in open_positions.values():
                # Berechne reservierte Margin
                position_size_usd = pos.get('position_size_usd', 0)
                leverage = pos.get('leverage', 1)
                margin = position_size_usd / leverage if leverage > 0 else 0
                reserved_margin += margin
                
                # Unrealized PnL
                unrealized_pnl += pos.get('current_pnl_usd', 0)
            
            # Total Equity = Balance + Reserved Margin + Unrealized PnL
            total_equity = balance + reserved_margin + unrealized_pnl
            
            # Drawdown basierend auf Total Equity
            drawdown = (peak_balance - total_equity) / peak_balance * 100 if peak_balance > 0 else 0
            roi = (total_equity - start_balance) / start_balance * 100 if start_balance > 0 else 0
            
            # Runtime & Timestamps
            runtime = datetime.now() - self.start_time
            hours = runtime.total_seconds() / 3600
            days = int(hours / 24)
            remaining_hours = hours % 24
            
            # Trade Stats
            trade_stats = self._get_trade_stats()
            
            # System Performance Metriken
            sharpe_ratio = self._calculate_sharpe_ratio(trade_stats)
            expectancy = self._calculate_expectancy(trade_stats)
            kelly_criterion = self._calculate_kelly(trade_stats)
            
            # Position Details
            total_exposure = sum(pos.get('position_size_usd', 0) for pos in open_positions.values())
            exposure_percent = (total_exposure / balance * 100) if balance > 0 else 0
            
            # Berechne gesch√§tzte Funding Fees
            estimated_funding = self._estimate_funding_fees(open_positions)
            
            dashboard = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üî• PROMETHEUS ULTRA v3.0 - LIVE DASHBOARD üî•              ‚ïë
‚ïë                         "170 Jahre seiner Zeit voraus"                       ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ‚è∞ Runtime: {days}d {remaining_hours:.1f}h | üïê {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | üîÑ Auto-refresh: 5s   ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                          üí∞ ACCOUNT & PERFORMANCE                            ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Balance:         ${balance:>12.2f} USDT                                     ‚ïë
‚ïë  Reserved Margin: ${reserved_margin:>12.2f} USDT                                     ‚ïë
‚ïë  Unrealized PnL:  ${unrealized_pnl:>+12.2f} USDT                                     ‚ïë
‚ïë  Total Equity:    ${total_equity:>12.2f} USDT                                     ‚ïë
‚ïë  Start Capital:   ${start_balance:>12.2f} USDT                                     ‚ïë
‚ïë  Peak Equity:     ${peak_balance:>12.2f} USDT                                     ‚ïë
‚ïë  ROI (Total):     {roi:>+12.2f}% {'üöÄ' if roi > 10 else 'üìà' if roi > 0 else 'üìâ'}                                       ‚ïë
‚ïë  Total PnL:       ${total_pnl:>+12.2f} USDT                                       ‚ïë
‚ïë  Daily PnL:       ${daily_pnl:>+12.2f} USDT {'‚úÖ' if daily_pnl >= 0 else '‚ö†Ô∏è'}                                 ‚ïë
‚ïë  Current DD:      {drawdown:>12.2f}% {'üö®' if drawdown > 10 else '‚ö†Ô∏è' if drawdown > 5 else '‚úÖ'}                                  ‚ïë
‚ïë  Free Margin:     ${balance - total_exposure:>12.2f} USDT                                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                         üìä TRADING PERFORMANCE METRICS                       ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Total Trades:    {trade_stats['total']:>6}          Win Rate: {trade_stats['win_rate']:>6.1f}% {'üéØ' if trade_stats['win_rate'] > 60 else 'üìä'}       ‚ïë
‚ïë  Wins / Losses:   {trade_stats['wins']:>6} / {trade_stats['losses']:<6}                                        ‚ïë
‚ïë  Avg Win:         {trade_stats['avg_win']:>+6.2f}%         Best Trade:  {trade_stats['best']:>+6.2f}% üèÜ         ‚ïë
‚ïë  Avg Loss:        {trade_stats['avg_loss']:>+6.2f}%         Worst Trade: {trade_stats['worst']:>+6.2f}% üíÄ         ‚ïë
‚ïë  Profit Factor:   {trade_stats['profit_factor']:>6.2f}x {'üî•' if trade_stats['profit_factor'] > 2 else '‚úÖ' if trade_stats['profit_factor'] > 1 else '‚ö†Ô∏è'}                                             ‚ïë
‚ïë  Expectancy:      ${expectancy:>+6.2f}         Kelly Criterion: {kelly_criterion:>4.1f}%              ‚ïë
‚ïë  Sharpe Ratio:    {sharpe_ratio:>6.2f} {'‚≠ê' if sharpe_ratio > 2 else '‚úÖ' if sharpe_ratio > 1 else 'üìä'}                                              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"""
            
            # Z√§hle Bot vs Manuelle Positionen
            bot_positions = sum(1 for p in open_positions.values() if not p.get('manual', False))
            manual_positions = sum(1 for p in open_positions.values() if p.get('manual', False))
            
            dashboard += f"""
‚ïë                    üìà POSITIONS: {bot_positions} Bot / {manual_positions} Manual (Max: {self.config.MAX_CONCURRENT_POSITIONS}) - EXPOSURE: {exposure_percent:.1f}%              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"""
            
            if open_positions:
                for pos_id, pos in open_positions.items():
                    pnl = pos.get('current_pnl', 0)
                    pnl_usd = pos.get('current_pnl_usd', 0)
                    emoji = "üü¢" if pnl > 0 else "üî¥"
                    side_emoji = "üìà" if pos['side'] == 'buy' else "üìâ"
                    
                    # Berechne Hold-Zeit
                    entry_time = pos.get('entry_time')
                    if isinstance(entry_time, str):
                        entry_time = datetime.fromisoformat(entry_time)
                    hold_mins = (datetime.now() - entry_time).total_seconds() / 60 if entry_time else 0
                    
                    # TP/SL Distances
                    current_price = pos.get('current_price', pos['entry_price'])
                    entry = pos['entry_price']
                    tp_dist = ((pos.get('take_profit', 0) - current_price) / current_price * 100) if pos.get('take_profit') else 0
                    sl_dist = ((current_price - pos.get('stop_loss', 0)) / current_price * 100) if pos.get('stop_loss') else 0
                    
                    dashboard += f"""
‚ïë  {emoji} {pos['symbol']:<10} {side_emoji} {pos['side'].upper():<4} | Entry: ${entry:.4f} | Cur: ${current_price:.4f}         ‚ïë
‚ïë     PnL: {pnl:>+6.2f}% (${pnl_usd:>+8.2f}) | Size: ${pos.get('position_size_usd', 0):>8.0f} | Lev: {pos['leverage']:>2}x       ‚ïë
‚ïë     System: {pos['system']:<10} | Strategy: {pos['strategy']:<20}          ‚ïë
‚ïë     Hold: {hold_mins:.0f}min | TP: {tp_dist:>+5.1f}% | SL: {sl_dist:>+5.1f}% | Est.Fee: ${estimated_funding.get(pos['symbol'], 0):.2f}    ‚ïë"""
            else:
                dashboard += """
‚ïë  üîç Scanning for opportunities... No positions currently open               ‚ïë"""
            
            dashboard += f"""
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                         üèÜ TOP 10 STRATEGY RANKINGS                          ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"""
            
            for rank, name, data in rankings[:10]:
                elo = data['elo']
                wins = data['wins']
                losses = data['losses']
                total = wins + losses
                wr = wins / total * 100 if total > 0 else 0
                avg_profit = data.get('avg_profit', 0)
                trades_today = data.get('trades_today', 0)
                
                # Medal f√ºr Top 3
                medal = "ü•á" if rank == 1 else "ü•à" if rank == 2 else "ü•â" if rank == 3 else f"#{rank}"
                
                dashboard += f"""
‚ïë  {medal:<3} {name:<23} | Elo: {elo:>4.0f} | {wins}/{losses} ({wr:>4.0f}%) | Avg: {avg_profit:>+5.2f}%    ‚ïë"""
            
            dashboard += f"""
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                         ‚öôÔ∏è SYSTEM STATUS & CONFIGURATION                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üêç VIPER Scalper:    {'üü¢ ACTIVE' if True else 'üî¥ INACTIVE':<12}  Lev: {self.config.VIPER_LEVERAGE:>2}x | Max Hold: 5min      ‚ïë
‚ïë  üî• PHOENIX Swing:    {'üü¢ ACTIVE' if True else 'üî¥ INACTIVE':<12}  Lev: {self.config.PHOENIX_LEVERAGE:>2}x | Max Hold: 24h        ‚ïë
‚ïë  üêâ HYDRA Consensus:  {'üü¢ ACTIVE' if True else 'üî¥ INACTIVE':<12}  Lev: {self.config.HYDRA_LEVERAGE:>2}x | Min Agree: {self.config.HYDRA_MIN_AGREEMENT}     ‚ïë
‚ïë  Position Size:       {self.config.POSITION_SIZE_PERCENT*100:>4.1f}% per trade                                      ‚ïë
‚ïë  Hard Stop-Loss:      {self.config.HARD_STOP_LOSS_PERCENT:>4.1f}% (Exchange-side SL)                           ‚ïë
‚ïë  Trailing Stop:       Activates at +{self.config.TRAILING_STOP_ACTIVATION:.1f}%, Distance: {self.config.TRAILING_STOP_DISTANCE:.1f}%            ‚ïë
‚ïë  Strategies Active:   42 total (23 standard + 11 genius + 8 secret)         ‚ïë
‚ïë  Optimizer:           {'üü¢ ENABLED' if self.config.OPTIMIZER_ENABLED else 'üî¥ DISABLED'} (Every {self.config.OPTIMIZER_INTERVAL_HOURS}h)                          ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                         üõ°Ô∏è RISK MANAGEMENT STATUS                            ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Daily Loss:      {abs(daily_pnl) if daily_pnl < 0 else 0:>6.2f}% / {self.config.MAX_DAILY_LOSS_PERCENT}% {'üö® CRITICAL' if abs(daily_pnl/start_balance*100) >= self.config.MAX_DAILY_LOSS_PERCENT else '‚ö†Ô∏è WARNING' if abs(daily_pnl/start_balance*100) > self.config.MAX_DAILY_LOSS_PERCENT*0.7 else '‚úÖ SAFE':<20}    ‚ïë
‚ïë  Drawdown:        {drawdown:>6.2f}% / {self.config.MAX_DRAWDOWN_PERCENT}% {'üö® DANGER' if drawdown >= self.config.MAX_DRAWDOWN_PERCENT*0.9 else '‚ö†Ô∏è WARNING' if drawdown > self.config.MAX_DRAWDOWN_PERCENT*0.6 else '‚úÖ HEALTHY':<20}    ‚ïë
‚ïë  Exposure:        {exposure_percent:>6.1f}% {'‚ö†Ô∏è HIGH' if exposure_percent > 80 else '‚úÖ OK':<20}                                   ‚ïë
‚ïë  Bot Positions:   {bot_positions}/{self.config.MAX_CONCURRENT_POSITIONS} {'‚ö†Ô∏è' if bot_positions >= self.config.MAX_CONCURRENT_POSITIONS else '‚úÖ'} | Manual: {manual_positions}                                ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                         üì° CONNECTION & MONITORING                           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Exchange:        KuCoin Futures {'üü¢ CONNECTED' if self.exchange else 'üî¥ DISCONNECTED'}                         ‚ïë
‚ïë  Last Trade:      {self._get_last_trade_time():<30}                      ‚ïë
‚ïë  Scan Interval:   {self.config.SCAN_INTERVAL_SECONDS}s                                                      ‚ïë
‚ïë  CSV Logging:     {'‚úÖ ACTIVE' if os.path.exists(self.config.TRADE_CSV) else '‚ö†Ô∏è INACTIVE'}                                                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
            
            self.last_update = datetime.now()
            return dashboard
            
        except Exception as e:
            return f"Dashboard Error: {e}\n{traceback.format_exc()}"
    
    def _get_trade_stats(self) -> dict:
        """Hole Trade-Statistiken aus CSV"""
        try:
            if not os.path.exists(self.config.TRADE_CSV):
                return {
                    'total': 0, 'wins': 0, 'losses': 0, 'win_rate': 0,
                    'avg_win': 0, 'avg_loss': 0, 'best': 0, 'worst': 0,
                    'profit_factor': 0
                }
            
            df = pd.read_csv(self.config.TRADE_CSV)
            
            if len(df) == 0 or 'net_pnl_percent' not in df.columns:
                return {
                    'total': 0, 'wins': 0, 'losses': 0, 'win_rate': 0,
                    'avg_win': 0, 'avg_loss': 0, 'best': 0, 'worst': 0,
                    'profit_factor': 0
                }
            
            # Nur abgeschlossene Trades
            df_closed = df[df['net_pnl_percent'].notna()]
            
            if len(df_closed) == 0:
                return {
                    'total': len(df), 'wins': 0, 'losses': 0, 'win_rate': 0,
                    'avg_win': 0, 'avg_loss': 0, 'best': 0, 'worst': 0,
                    'profit_factor': 0
                }
            
            wins = df_closed[df_closed['net_pnl_percent'] > 0]
            losses = df_closed[df_closed['net_pnl_percent'] <= 0]
            
            total_wins = wins['net_pnl_percent'].sum() if len(wins) > 0 else 0
            total_losses = abs(losses['net_pnl_percent'].sum()) if len(losses) > 0 else 0
            
            return {
                'total': len(df_closed),
                'wins': len(wins),
                'losses': len(losses),
                'win_rate': len(wins) / len(df_closed) * 100 if len(df_closed) > 0 else 0,
                'avg_win': wins['net_pnl_percent'].mean() if len(wins) > 0 else 0,
                'avg_loss': losses['net_pnl_percent'].mean() if len(losses) > 0 else 0,
                'best': df_closed['net_pnl_percent'].max(),
                'worst': df_closed['net_pnl_percent'].min(),
                'profit_factor': total_wins / total_losses if total_losses > 0 else total_wins
            }
            
        except Exception as e:
            self.logger.log(f"Error getting trade stats: {e}", "ERROR")
            return {
                'total': 0, 'wins': 0, 'losses': 0, 'win_rate': 0,
                'avg_win': 0, 'avg_loss': 0, 'best': 0, 'worst': 0,
                'profit_factor': 0
            }
    
    def _calculate_sharpe_ratio(self, trade_stats: dict) -> float:
        """Berechne Sharpe Ratio (vereinfacht)"""
        try:
            if trade_stats['total'] < 2:
                return 0.0
            
            if not os.path.exists(self.config.TRADE_CSV):
                return 0.0
            
            df = pd.read_csv(self.config.TRADE_CSV)
            df_closed = df[df['net_pnl_percent'].notna()]
            
            if len(df_closed) < 2:
                return 0.0
            
            returns = df_closed['net_pnl_percent'].values
            mean_return = np.mean(returns)
            std_return = np.std(returns)
            
            if std_return == 0:
                return 0.0
            
            # Sharpe = (Mean Return - Risk Free Rate) / Std Dev
            # Risk Free Rate = 0 f√ºr Crypto
            sharpe = mean_return / std_return
            return sharpe
            
        except Exception as e:
            return 0.0
    
    def _calculate_expectancy(self, trade_stats: dict) -> float:
        """Berechne Trade Expectancy in USD"""
        try:
            if trade_stats['total'] == 0:
                return 0.0
            
            win_rate = trade_stats['win_rate'] / 100
            avg_win = trade_stats['avg_win']
            avg_loss = abs(trade_stats['avg_loss'])
            
            # Expectancy = (Win% * AvgWin) - (Loss% * AvgLoss)
            expectancy = (win_rate * avg_win) - ((1 - win_rate) * avg_loss)
            return expectancy
            
        except Exception as e:
            return 0.0
    
    def _calculate_kelly(self, trade_stats: dict) -> float:
        """Berechne Kelly Criterion f√ºr optimale Position Size"""
        try:
            if trade_stats['total'] == 0 or trade_stats['avg_loss'] == 0:
                return 0.0
            
            win_rate = trade_stats['win_rate'] / 100
            win_loss_ratio = abs(trade_stats['avg_win'] / trade_stats['avg_loss']) if trade_stats['avg_loss'] != 0 else 0
            
            # Kelly = W - (1-W)/R
            # W = Win Rate, R = Win/Loss Ratio
            kelly = win_rate - ((1 - win_rate) / win_loss_ratio) if win_loss_ratio > 0 else 0
            
            # Begrenzen auf sinnvolle Werte (0-50%)
            kelly = max(0, min(kelly * 100, 50))
            return kelly
            
        except Exception as e:
            return 0.0
    
    def _estimate_funding_fees(self, positions: dict) -> dict:
        """Sch√§tze Funding Fees f√ºr offene Positionen"""
        funding_fees = {}
        try:
            # Funding Fee auf KuCoin = ~0.01% alle 8h
            funding_rate = 0.0001  # 0.01%
            
            for pos_id, pos in positions.items():
                symbol = pos['symbol']
                position_size = pos.get('position_size_usd', 0)
                
                # Berechne wie viele Funding Periods vergangen sind
                entry_time = pos.get('entry_time')
                if isinstance(entry_time, str):
                    entry_time = datetime.fromisoformat(entry_time)
                
                hours_held = (datetime.now() - entry_time).total_seconds() / 3600 if entry_time else 0
                funding_periods = int(hours_held / 8)
                
                # Sch√§tze total Funding
                estimated_fee = position_size * funding_rate * funding_periods
                funding_fees[symbol] = estimated_fee
            
            return funding_fees
            
        except Exception as e:
            return {}
    
    def _get_last_trade_time(self) -> str:
        """Hole Zeit des letzten Trades"""
        try:
            if not os.path.exists(self.config.TRADE_CSV):
                return "No trades yet"
            
            df = pd.read_csv(self.config.TRADE_CSV)
            if len(df) == 0:
                return "No trades yet"
            
            # Hole neuesten Trade
            if 'timestamp_exit' in df.columns:
                last_exit = df[df['timestamp_exit'].notna()]['timestamp_exit'].iloc[-1] if len(df[df['timestamp_exit'].notna()]) > 0 else None
                if last_exit:
                    last_time = datetime.fromisoformat(last_exit)
                    minutes_ago = (datetime.now() - last_time).total_seconds() / 60
                    
                    if minutes_ago < 60:
                        return f"{int(minutes_ago)}min ago"
                    elif minutes_ago < 1440:
                        return f"{int(minutes_ago/60)}h ago"
                    else:
                        return f"{int(minutes_ago/1440)}d ago"
            
            return "Unknown"
            
        except Exception as e:
            return "Error"
    
    def show(self):
        """Zeige Dashboard im Terminal"""
        print("\033[H\033[J")  # Clear screen
        print(self.render())
    
    def show_jupyter(self):
        """Zeige Dashboard in Jupyter - OHNE HTML SPAM!"""
        from IPython.display import clear_output
        clear_output(wait=True)
        print(self.render())  # Nutze normales Text-Dashboard


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
# ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
# ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
# ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù 
# ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     
# ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù     
#                           MAIN LOOP & START
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class PrometheusBot:
    """
    Main Bot Controller - TOP 0.000001% VERSION!
    Mit allen Ultra-Performance Features
    """
    
    def __init__(self):
        self.config = Config()
        self.logger = Logger(self.config.LOG_FILE)
        self.running = False
        self.entry_paused = False  # Flag um Entry Scanning zu pausieren
        
        self.logger.log("=" * 60, "INFO")
        self.logger.log("PROMETHEUS ULTRA TRADING BOT v3.0 - TOP 0.000001% VERSION", "INFO")
        self.logger.log("=" * 60, "INFO")
    
    def initialize(self):
        """Initialisiere alle Komponenten - INKL. ULTRA PERFORMANCE MODULE!"""
        try:
            # Exchange
            self.logger.log("Connecting to KuCoin Futures...", "INFO")
            self.exchange = ExchangeConnector(self.config, self.logger)
            
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # üöÄ ULTRA PERFORMANCE MODULE INITIALISIERUNG
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            self.logger.log("Initializing Ultra Performance Modules...", "INFO")
            
            # Fast Price Cache - 90% weniger API Calls!
            self.price_cache = FastPriceCache(self.exchange, self.logger)
            
            # Rate Limiter - Verhindert API Blocks
            self.rate_limiter = RateLimiter(self.logger)
            
            # Slippage Tracker - Analysiert Fill-Qualit√§t
            self.slippage_tracker = SlippageTracker(self.logger)
            
            # Trailing Stop Manager - Intelligente Profit-Sicherung
            self.trailing_manager = TrailingStopManager(self.config, self.logger)
            
            # Parallel Position Checker - 3-5x schneller!
            self.parallel_checker = ParallelPositionChecker(self.config, self.logger)
            
            self.logger.log("‚úÖ Ultra Performance Modules initialized!", "INFO")
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            # State Manager
            self.state = StateManager(self.config.STATE_FILE, self.logger)
            
            # Setze Start-Balance
            balance = self.exchange.get_balance()
            if not self.state.get('start_balance'):
                self.state.set('start_balance', balance)
            
            # Trade Journal
            self.journal = TradeJournal(self.config.TRADE_CSV, self.logger)
            
            # Ranking System
            self.ranking = StrategyRankingSystem(self.config, self.logger, self.state)
            
            # Strategy Optimizer
            self.optimizer = StrategyOptimizer(self.config, self.logger, self.journal)
            
            # Strategy Manager
            self.strategy_manager = StrategyManager(self.config, self.logger)
            
            # Position Manager - MIT ULTRA FEATURES!
            self.position_manager = PositionManager(
                self.config, self.logger, self.exchange,
                self.journal, self.ranking, self.state
            )
            # Injiziere Ultra Features in Position Manager
            self.position_manager.trailing_manager = self.trailing_manager
            self.position_manager.slippage_tracker = self.slippage_tracker
            self.position_manager.price_cache = self.price_cache
            
            # Systeme
            self.viper = ViperScalper(
                self.config, self.logger, self.exchange,
                self.strategy_manager, self.ranking
            )
            
            self.phoenix = PhoenixSwing(
                self.config, self.logger, self.exchange,
                self.strategy_manager, self.ranking
            )
            
            self.hydra = HydraConsensus(
                self.config, self.logger, self.exchange,
                self.strategy_manager, self.ranking, self.optimizer
            )
            
            # Features
            self.liquidation_detector = LiquidationCascadeDetector(
                self.config, self.logger, self.exchange
            )
            self.smart_money = SmartMoneyFlowTracker(self.config, self.logger)
            self.manipulation_shield = MarketManipulationShield(self.config, self.logger)
            self.institutional = InstitutionalFootprintAnalyzer(self.config, self.logger)
            self.quantum = QuantumMomentumPredictor(self.config, self.logger)
            
            # Multi-Brain Controller - MIT ULTRA FEATURES!
            self.brain = MultiBrainController(
                self.config, self.logger, self.exchange,
                self.viper, self.phoenix, self.hydra,
                self.position_manager
            )
            # Injiziere Ultra Features in Brain
            self.brain.trailing_manager = self.trailing_manager
            self.brain.price_cache = self.price_cache
            self.brain.rate_limiter = self.rate_limiter
            
            # Dashboard
            self.dashboard = Dashboard(
                self.config, self.logger, self.exchange,
                self.position_manager, self.ranking, self.state
            )
            
            self.logger.log("All components initialized successfully!", "INFO")
            self.logger.log("üöÄ ULTRA PERFORMANCE MODE ACTIVE!", "INFO")
            return True
            
        except Exception as e:
            self.logger.log(f"Initialization failed: {e}", "ERROR", True)
            return False
    
    def run(self):
        """Hauptloop mit Position Sync"""
        if not self.initialize():
            return
        
        self.running = True
        self.logger.log("Starting PROMETHEUS Bot...", "INFO")
        
        # Starte Multi-Brain
        pos_thread, entry_thread = self.brain.start()
        
        # Dashboard Loop
        dashboard_interval = 5  # Sekunden
        last_dashboard = 0
        
        # Position Sync Loop
        sync_interval = 30  # Sekunden - alle 30s mit Exchange synchronisieren
        last_sync = 0
        
        # Erkenne ob in Jupyter
        try:
            from IPython import get_ipython
            in_jupyter = get_ipython() is not None
        except:
            in_jupyter = False
        
        try:
            while self.running:
                current_time = time.time()
                
                # Dashboard Update
                if current_time - last_dashboard >= dashboard_interval:
                    try:
                        if in_jupyter:
                            self.dashboard.show_jupyter()  # HTML Dashboard in Jupyter
                        else:
                            self.dashboard.show()  # Terminal Dashboard
                        last_dashboard = current_time
                    except Exception as e:
                        self.logger.log(f"Dashboard error: {e}", "ERROR")
                
                # Position Sync mit Exchange (NEU!)
                if current_time - last_sync >= sync_interval:
                    try:
                        self.position_manager.sync_with_exchange()
                        last_sync = current_time
                    except Exception as e:
                        self.logger.log(f"Position sync error: {e}", "ERROR")
                
                # Pr√ºfe Risk Limits
                self._check_risk_limits()
                
                # Pr√ºfe Thread Health
                if not pos_thread.is_alive():
                    self.logger.log("Position brain died! Restarting...", "ERROR")
                    pos_thread, entry_thread = self.brain.start()
                
                if not entry_thread.is_alive():
                    self.logger.log("Entry brain died! Restarting...", "ERROR")
                    pos_thread, entry_thread = self.brain.start()
                
                time.sleep(1)
                
        except KeyboardInterrupt:
            self.logger.log("Shutdown requested by user...", "INFO")
        
        except Exception as e:
            self.logger.log(f"Main loop error: {e}", "ERROR", True)
        
        finally:
            self.shutdown()
    
    def _check_risk_limits(self):
        """Pr√ºfe Risk Limits - MIT KORREKTEM EQUITY (Balance + Margin + PnL)!"""
        try:
            # Hole alle Werte mit sicheren Defaults
            daily_pnl = self.state.get('daily_pnl') or 0
            start_balance = self.state.get('start_balance') or 1
            current_balance = self.exchange.get_balance() or 0
            peak_balance = self.state.get('peak_balance') or current_balance
            
            # Type checks
            if not isinstance(daily_pnl, (int, float)):
                daily_pnl = 0
            if not isinstance(start_balance, (int, float)):
                start_balance = 1
            if not isinstance(current_balance, (int, float)):
                current_balance = 0
            if not isinstance(peak_balance, (int, float)):
                peak_balance = current_balance
            
            # WICHTIG: Berechne TOTAL EQUITY (Balance + Reserved Margin + Unrealized PnL)
            open_positions = self.position_manager.get_open_positions()
            reserved_margin = 0
            unrealized_pnl = 0
            
            for pos in open_positions.values():
                # Berechne reservierte Margin f√ºr diese Position
                position_size_usd = pos.get('position_size_usd', 0)
                leverage = pos.get('leverage', 1)
                margin_for_position = position_size_usd / leverage if leverage > 0 else 0
                reserved_margin += margin_for_position
                
                # Hole aktuellen PnL der Position
                pnl_usd = pos.get('current_pnl_usd', 0)
                unrealized_pnl += pnl_usd if pnl_usd else 0
            
            # Total Equity = Balance + Reserved Margin + Unrealized PnL
            # WICHTIG: Die reservierte Margin ist NICHT verloren, nur blockiert!
            total_equity = current_balance + reserved_margin + unrealized_pnl
            
            # Daily Loss Check (auf Basis von realized PnL)
            if start_balance > 0:
                daily_loss_percent = abs(daily_pnl) / start_balance * 100 if daily_pnl < 0 else 0
            else:
                daily_loss_percent = 0
            
            if daily_loss_percent >= self.config.MAX_DAILY_LOSS_PERCENT:
                self.logger.log(
                    f"‚ö†Ô∏è DAILY LOSS LIMIT REACHED ({daily_loss_percent:.2f}%)! "
                    f"Bot will pause for 24 hours.",
                    "WARNING"
                )
            
            # Drawdown Check - JETZT KORREKT mit Total Equity!
            if peak_balance > 0:
                # Update Peak wenn Equity h√∂her
                if total_equity > peak_balance:
                    peak_balance = total_equity
                    self.state.set('peak_balance', peak_balance)
                
                # Berechne Drawdown basierend auf Total Equity
                drawdown = (peak_balance - total_equity) / peak_balance * 100
            else:
                drawdown = 0
            
            # Log f√ºr Debugging
            if len(open_positions) > 0:
                self.logger.log(
                    f"üí∞ Equity Check: Balance=${current_balance:.2f} + "
                    f"Reserved Margin=${reserved_margin:.2f} + "
                    f"Unrealized PnL=${unrealized_pnl:.2f} = "
                    f"Total Equity=${total_equity:.2f} | "
                    f"Drawdown: {drawdown:.2f}%",
                    "DEBUG"
                )
            
            # MAX_DRAWDOWN Check - DISABLED (zu aggressiv f√ºr kleine Accounts)
            # if drawdown >= self.config.MAX_DRAWDOWN_PERCENT:
            #     self.brain.entry_paused = True
            
            # Daily Reset Check
            today = datetime.now().strftime("%Y-%m-%d")
            last_date = self.state.get('last_trade_date')
            
            if last_date != today:
                self.state.set('daily_pnl', 0)
                self.state.set('last_trade_date', today)
                self.logger.log("Daily PnL reset", "INFO")
                
        except Exception as e:
            self.logger.log(f"Risk check error: {e}", "ERROR")
    
    def shutdown(self):
        """Sauberes Herunterfahren"""
        self.logger.log("Shutting down PROMETHEUS Bot...", "INFO")
        
        self.running = False
        self.brain.stop()
        
        # Speichere State
        self.state.save_state()
        
        self.logger.log("PROMETHEUS Bot shutdown complete.", "INFO")


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# START FUNCTION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def start_prometheus():
    """Starte den PROMETHEUS Bot"""
    print("""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                                                                              ‚ïë
    ‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ïë
    ‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïë
    ‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ïë
    ‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ïë
    ‚ïë   ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ïë
    ‚ïë   ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïë
    ‚ïë                                                                              ‚ïë
    ‚ïë                    ULTRA TRADING BOT v3.0                                    ‚ïë
    ‚ïë                    "170 Jahre seiner Zeit voraus"                            ‚ïë
    ‚ïë                                                                              ‚ïë
    ‚ïë   üî• 42 Strategien (inkl. 5 GEHEIME)                                        ‚ïë
    ‚ïë   üî• 3 Trading-Systeme (VIPER, PHOENIX, HYDRA)                              ‚ïë
    ‚ïë   üî• 5 Genius Features (Liquidation Detector, Smart Money, etc.)            ‚ïë
    ‚ïë   üî• Multi-Brain Architecture                                               ‚ïë
    ‚ïë   üî• Vollst√§ndiges CSV-Logging mit 50+ Spalten                              ‚ïë
    ‚ïë                                                                              ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    bot = PrometheusBot()
    bot.run()


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# EXECUTION
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

if __name__ == "__main__":
    start_prometheus()


print("=" * 80)
print("PROMETHEUS BOT - Part 2B loaded successfully!")
print("=" * 80)
print("\nPart 2B enth√§lt:")
print("  ‚úì Strategy Manager (verwaltet alle 42 Strategien)")
print("  ‚úì VIPER SCALPER System (20x Leverage)")
print("  ‚úì PHOENIX SWING System (5-10x adaptiv)")
print("  ‚úì HYDRA CONSENSUS System (Agreement + Standalone)")
print("  ‚úì Multi-Brain Controller (Priorisiert offene Positionen)")
print("  ‚úì Position Manager (Korrekter Exit-Preis, CSV-Logging)")
print("  ‚úì Vollst√§ndiges Dashboard")
print("  ‚úì Main Loop mit Risk Management")
print("  ‚úì Start Function")
print("\n" + "=" * 80)
print("BOT IST KOMPLETT!")
print("=" * 80)
print("\nSo startest du:")
print("1. Kopiere Teil 1, Teil 2A und Teil 2B in EINE Jupyter-Zelle")
print("2. F√ºhre die Zelle aus")
print("3. Rufe start_prometheus() auf")
print("=" * 80)
